diff --git a/Generator/.ipynb_checkpoints/script_training_data-checkpoint.m b/Generator/.ipynb_checkpoints/script_training_data-checkpoint.m
deleted file mode 100644
index cf5617e..0000000
--- a/Generator/.ipynb_checkpoints/script_training_data-checkpoint.m
+++ /dev/null
@@ -1,44 +0,0 @@
-addpath('library');
-addpath('ml_tools');
-addpath('asim');
-addpath('objects_training')
-
-% Where are the STL files stored 
-object_dir = 'objects_training/';
-
-%object_dir = fullfile('E:\','objects_training',filesep);
-Dr0        = 5;            % turbulence strength D/r0 =5 (low) /D/r0 = 15 (medium) / D/r0=21 (strong)
-n_poses    = 1000;             % how many random or specified poses 
-dsf        = 4;             % downsample factor (controls image grid size)
-fov        = 0.5;           % field of view
-
-% generate specific object poses 
-% v_az = zeros(1,11);
-% v_el = 0:10:100;
-% n_poses = length(v_el);
-
-% measure elapsed time
-t = cputime;
-
-adir = dir([ object_dir '*.stl']);
-for ss=1:length(adir)
-    if adir(ss).isdir==0
-        stl_fname   = [ object_dir filesep adir(ss).name ];
-        
-       [g, v_az, v_el]   = gen_object_poses(stl_fname, n_poses, dsf);  % generate random poses 
-%        [g, ~, ~]  = gen_object_poses(stl_fname, n_poses, dsf, v_az, v_el);  % generate specific poses 
-        g2   = scale_fov(g, 0.5);           % change the FOV - make object smaller<1 /bigger >1
-        gp  = blur_object_poses(g2, Dr0);       % Specify turbulence strength via D/r0 value
-        
-        for n=1:n_poses
-            imwrite(gp(:,:,n), ["output/" adir(ss).name "_" int2str(n) ".JPEG"], "JPEG");
-        end
-    end
-end
-
-% record elapsed time
-e = cputime -t;
-
-% diplay elapsed time
-disp('elapsed time:')
-disp(e)
\ No newline at end of file
diff --git a/Generator/.ipynb_checkpoints/stlread1-checkpoint.m b/Generator/.ipynb_checkpoints/stlread1-checkpoint.m
deleted file mode 100755
index 10c5162..0000000
--- a/Generator/.ipynb_checkpoints/stlread1-checkpoint.m
+++ /dev/null
@@ -1,135 +0,0 @@
-function varargout = stlread(file)
-% STLREAD imports geometry from an STL file into MATLAB.
-%    FV = STLREAD(FILENAME) imports triangular faces from the ASCII or binary
-%    STL file idicated by FILENAME, and returns the patch struct FV, with fields
-%    'faces' and 'vertices'.
-%
-%    [F,V] = STLREAD(FILENAME) returns the faces F and vertices V separately.
-%
-%    [F,V,N] = STLREAD(FILENAME) also returns the face normal vectors.
-%
-%    The faces and vertices are arranged in the format used by the PATCH plot
-%    object.
-
-% Copyright 2011 The MathWorks, Inc.
-
-    if ~exist(file,'file')
-        error(['File ''%s'' not found. If the file is not on MATLAB''s path' ...
-               ', be sure to specify the full path to the file.'], file);
-    end
-
-    fid = fopen(file,'r');    
-    if ~isempty(ferror(fid))
-        error(lasterror); %#ok
-    end
-    
-    M = fread(fid,inf,'uint8=>uint8');
-    fclose(fid);
-    
-    [f,v,n] = stlbinary(M);
-    %if( isbinary(M) ) % This may not be a reliable test
-    %    [f,v,n] = stlbinary(M);
-    %else
-    %    [f,v,n] = stlascii(M);
-    %end
-    
-    varargout = cell(1,nargout);
-    switch nargout        
-        case 2
-            varargout{1} = f;
-            varargout{2} = v;
-        case 3
-            varargout{1} = f;
-            varargout{2} = v;
-            varargout{3} = n;
-        otherwise
-            varargout{1} = struct('faces',f,'vertices',v);
-    end
-
-end
-
-
-function [F,V,N] = stlbinary(M)
-
-    F = [];
-    V = [];
-    N = [];
-    
-    if length(M) < 84
-        error('MATLAB:stlread:incorrectFormat', ...
-              'Incomplete header information in binary STL file.');
-    end
-    
-    % Bytes 81-84 are an unsigned 32-bit integer specifying the number of faces
-    % that follow.
-    numFaces = typecast(M(81:84),'uint32');
-    %numFaces = double(numFaces);
-    if numFaces == 0
-        warning('MATLAB:stlread:nodata','No data in STL file.');
-        return
-    end
-    
-    T = M(85:end);
-    F = NaN(numFaces,3);
-    V = NaN(3*numFaces,3);
-    N = NaN(numFaces,3);
-    
-    numRead = 0;
-    while numRead < numFaces
-        % Each facet is 50 bytes
-        %  - Three single precision values specifying the face normal vector
-        %  - Three single precision values specifying the first vertex (XYZ)
-        %  - Three single precision values specifying the second vertex (XYZ)
-        %  - Three single precision values specifying the third vertex (XYZ)
-        %  - Two unused bytes
-        i1    = 50 * numRead + 1;
-        i2    = i1 + 50 - 1;
-        facet = T(i1:i2)';
-        
-        n  = typecast(facet(1:12),'single');
-        v1 = typecast(facet(13:24),'single');
-        v2 = typecast(facet(25:36),'single');
-        v3 = typecast(facet(37:48),'single');
-        
-        n = double(n);
-        v = double([v1; v2; v3]);
-        
-        % Figure out where to fit these new vertices, and the face, in the
-        % larger F and V collections.        
-        fInd  = numRead + 1;        
-        vInd1 = 3 * (fInd - 1) + 1;
-        vInd2 = vInd1 + 3 - 1;
-        
-        V(vInd1:vInd2,:) = v;
-        F(fInd,:)        = vInd1:vInd2;
-        N(fInd,:)        = n;
-        
-        numRead = numRead + 1;
-    end
-    
-end
-
-
-function [F,V,N] = stlascii(M)
-    warning('MATLAB:stlread:ascii','ASCII STL files currently not supported.');
-    F = [];
-    V = [];
-    N = [];
-end
-
-% TODO: Change the testing criteria! Some binary STL files still begin with
-% 'solid'.
-function tf = isbinary(A)
-% ISBINARY uses the first line of an STL file to identify its format.
-    if isempty(A) || length(A) < 5
-        error('MATLAB:stlread:incorrectFormat', ...
-              'File does not appear to be an ASCII or binary STL file.');
-    end    
-    if strcmpi('solid',char(A(1:5)'))
-        tf = false; % ASCII
-    else
-        tf = true;  % Binary
-    end
-end
-
-
diff --git a/Generator/asim/._gen_psfs.m b/Generator/asim/._gen_psfs.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/asim/._gen_psfs.m and /dev/null differ
diff --git a/Generator/asim/._gen_psfs_wind_2layers.m b/Generator/asim/._gen_psfs_wind_2layers.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/asim/._gen_psfs_wind_2layers.m and /dev/null differ
diff --git a/Generator/asim/._gen_psfs_wind_layers.m b/Generator/asim/._gen_psfs_wind_layers.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/asim/._gen_psfs_wind_layers.m and /dev/null differ
diff --git a/Generator/asim/._genphase.m b/Generator/asim/._genphase.m
deleted file mode 100644
index 6ae6fc1..0000000
Binary files a/Generator/asim/._genphase.m and /dev/null differ
diff --git a/Generator/asim/._kolmogorov.m b/Generator/asim/._kolmogorov.m
deleted file mode 100644
index db170ca..0000000
Binary files a/Generator/asim/._kolmogorov.m and /dev/null differ
diff --git a/Generator/asim/._legendre_basis.m b/Generator/asim/._legendre_basis.m
deleted file mode 100644
index d332841..0000000
Binary files a/Generator/asim/._legendre_basis.m and /dev/null differ
diff --git a/Generator/asim/._make_speckle.m b/Generator/asim/._make_speckle.m
deleted file mode 100644
index 428a2b9..0000000
Binary files a/Generator/asim/._make_speckle.m and /dev/null differ
diff --git a/Generator/asim/gen_psfs.m b/Generator/asim/gen_psfs.m
deleted file mode 100644
index 9491b3c..0000000
--- a/Generator/asim/gen_psfs.m
+++ /dev/null
@@ -1,62 +0,0 @@
-function gen_psfs(Dr0,v_x,v_y,uber_cfg)
-
-% gen_psfs(Dr0,v_x,v_y) 
-% 
-% Dr0    Turbulence Strength
-% v_x 	 x-shift
-% v_y    y-shift 
-%
-pad_dim     = (uber_cfg.mdim - uber_cfg.pdim)/2;
-
-pupil_amp = padarray(uber_cfg.pupil_mask,[ pad_dim pad_dim],0,'both');
-pupil_amp = pupil_amp./max(pupil_amp(:));
-pupil_amp = (uber_cfg.mdim.*pupil_amp)./sqrt(sum(sum(pupil_amp.^2)));
-
-
-Nseq_length = 100;
-for k1=1:length(v_x)
-    
-    vmag = sqrt(v_x(k1).^2 + v_y(k1).^2);
-
-    tic
-    grid_sz = 2*(2^ceil(log2(uber_cfg.pdim*vmag)));
-    phase2  = kolmogorov(grid_sz, Dr0 );
-    p0      = (grid_sz - uber_cfg.pdim)/2;
-    v_co    = (p0+1):(p0+uber_cfg.pdim);
-    cube    = zeros(uber_cfg.pdim,uber_cfg.pdim,Nseq_length);
-
-    tmp     = phase2;
-    for k=1:100
-        cube(:,:,k) = tmp(v_co,v_co);
-        if v_x>0
-            tmp=shiftr(tmp,0,abs(v_x));
-        elseif v_x<0
-            tmp=shiftl(tmp,0,abs(v_x));
-        end
-        if v_y>0
-            tmp=shiftu(tmp,0,abs(v_y));
-        elseif v_y<0
-            tmp=shiftd(tmp,0,abs(v_y));
-        end
-    end
-
-    phase       = padarray(cube,[pad_dim pad_dim],0,'both');
-    psf         = zeros(size(phase));
-
-
-
-    for k=1:size(phase,3)
-        a   = ifft2(pupil_amp.*exp(sqrt(-1).*phase(:,:,k)));
-        h   = abs(ifftshift(abs(a).^2));
-        psf(:,:,k) = h;
-    end
-
-    save(['mc' num2str(k1) '_psfs.mat' ],'psf');
-
-    tt=toc;
-    fprintf([ 'MC: ' num2str(k1) ' \t v = (' num2str(v_x(k1)) ',' num2str(v_y(k1)) ') \t elapsed time: ' num2str(tt,'%5.3f seconds') '\n' ]);
-%     fitswrite(psf,['mc' num2str(k1) '_psfs.fits' ]);
-end
-
-
-
diff --git a/Generator/asim/gen_psfs_wind_2layers.m b/Generator/asim/gen_psfs_wind_2layers.m
deleted file mode 100644
index a4db0b8..0000000
--- a/Generator/asim/gen_psfs_wind_2layers.m
+++ /dev/null
@@ -1,108 +0,0 @@
-function gen_psfs_wind_layers(Dr0,wind_v,uber_cfg)
-
-% gen_psfs(Dr0,v_x,v_y) 
-% 
-% Dr0    Turbulence Strength
-% v_x 	 x-shift
-% v_y    y-shift 
-%
-pad_dim     = (uber_cfg.mdim - uber_cfg.pdim)/2;
-
-pupil_amp = padarray(uber_cfg.pupil_mask,[ pad_dim pad_dim],0,'both');
-pupil_amp = pupil_amp./max(pupil_amp(:));
-pupil_amp = (uber_cfg.mdim.*pupil_amp)./sqrt(sum(sum(pupil_amp.^2)));
-
-
-v_x1 = wind_v(:,1,1);v_y1 = wind_v(:,2,1);
-v_x2 = wind_v(:,1,2);v_y2 = wind_v(:,2,2);
-
-
-Nseq_length = 200;
-arr = zeros(uber_cfg.mdim,uber_cfg.mdim,Nseq_length);
-kk_ct = 0;
-for k1=1:size(wind_v,1)
-    
-    L1_v = [ v_x1(k1) v_y1(k1) ];
-    L2_v = [ v_x2(k1) v_y2(k1) ];
-    
-    vmag1   = sqrt(v_x1(k1).^2 + v_y1(k1).^2);
-    vmag2   = sqrt(v_x2(k1).^2 + v_y2(k1).^2);
-    vmag    = max(vmag1,vmag2);
-    
-
-    if vmag1>0 & vmag2 >0
-        tic
-        grid_sz = 4*(2^ceil(log2(uber_cfg.pdim*vmag)));
-        xscale = grid_sz/uber_cfg.mdim;
-        
-        % Generate layer-1 
-        phase2  = kolmogorov(grid_sz, xscale.*Dr0 );
-        p0      = (grid_sz - uber_cfg.pdim)/2;
-        v_co    = (p0+1):(p0+uber_cfg.pdim);
-        cube1    = zeros(uber_cfg.pdim,uber_cfg.pdim,Nseq_length);cube2 = cube1;
-
-        % Propagate the large phase screen using randomly chosen L1-wind vectors 
-        tmp     = phase2;
-        for k=1:Nseq_length
-            cube1(:,:,k) = tmp(v_co,v_co);
-            if v_x1(k1)>0
-                tmp=shiftr(tmp,0,abs(v_x1(k1)));
-            elseif v_x1(k1)<0
-                tmp=shiftl(tmp,0,abs(v_x1(k1)));
-            end
-            if v_y1(k1)>0
-                tmp=shiftu(tmp,0,abs(v_y1(k1)));
-            elseif v_y1(k1)<0
-                tmp=shiftd(tmp,0,abs(v_y1(k1)));
-            end
-        end
-        cube1        = cube1.*uber_cfg.pupil_mask;
-               
-
-        % Generate layer-2 
-        grid_sz = 4*(2^ceil(log2(uber_cfg.pdim*vmag)));
-        xscale = grid_sz/uber_cfg.mdim;        
-        phase2  = kolmogorov(grid_sz, xscale.*Dr0 );
-        p0      = (grid_sz - uber_cfg.pdim)/2;
-        v_co    = (p0+1):(p0+uber_cfg.pdim);
-
-        % Propagate the large phase screen using randomly chosen L1-wind vectors 
-        tmp     = phase2;
-        for k=1:Nseq_length
-            cube2(:,:,k) = tmp(v_co,v_co);
-            if v_x2(k1)>0
-                tmp=shiftr(tmp,0,abs(v_x2(k1)));
-            elseif v_x2(k1)<0
-                tmp=shiftl(tmp,0,abs(v_x2(k1)));
-            end
-            if v_y2(k1)>0
-                tmp=shiftu(tmp,0,abs(v_y2(k1)));
-            elseif v_y2(k1)<0
-                tmp=shiftd(tmp,0,abs(v_y2(k1)));
-            end
-        end
-        cube2       = cube2.*uber_cfg.pupil_mask;
-        
-        % Generate a second layer with a differnt random veloicty 
-        phase       = padarray(cube1+cube2,[pad_dim pad_dim],0,'both');
-        psf         = zeros(size(phase));
-
-        for k=1:size(phase,3)
-            a   = ifft2(pupil_amp.*exp(sqrt(-1).*phase(:,:,k)));
-            h   = abs(ifftshift(abs(a).^2));
-            psf(:,:,k) = h;
-        end
-
-        arr = abs(fftshift(fft2(psf))).^2;
-        save(['mc' num2str(k1) '_2L_psf_modulus_squared.mat' ],'arr','psf','phase','cube1','cube2','L1_v','L2_v');
-        tt=toc;
-        kk_ct = kk_ct+1;
-        sL1 = [ 'L1_v = (' num2str(v_x1(k1)) ',' num2str(v_y1(k1)) ')' ];
-        sL2 = [ 'L2_v = (' num2str(v_x2(k1)) ',' num2str(v_y2(k1)) ')' ];
-        
-        fprintf([ 'MC: ' num2str(kk_ct) ' \t' sL1 '  ' sL2 '\t elapsed time: ' num2str(tt,'%5.3f seconds') '\n' ]);
-    end
-end
-
-
-
diff --git a/Generator/asim/gen_psfs_wind_layers.m b/Generator/asim/gen_psfs_wind_layers.m
deleted file mode 100644
index f65f035..0000000
--- a/Generator/asim/gen_psfs_wind_layers.m
+++ /dev/null
@@ -1,71 +0,0 @@
-function gen_psfs_wind_layers(Dr0,v_x,v_y,uber_cfg)
-
-% gen_psfs(Dr0,v_x,v_y) 
-% 
-% Dr0    Turbulence Strength
-% v_x 	 x-shift
-% v_y    y-shift 
-%
-pad_dim     = (uber_cfg.mdim - uber_cfg.pdim)/2;
-
-pupil_amp = padarray(uber_cfg.pupil_mask,[ pad_dim pad_dim],0,'both');
-pupil_amp = pupil_amp./max(pupil_amp(:));
-pupil_amp = (uber_cfg.mdim.*pupil_amp)./sqrt(sum(sum(pupil_amp.^2)));
-
-
-Nseq_length = 200;
-arr = zeros(uber_cfg.mdim,uber_cfg.mdim,Nseq_length);
-kk_ct = 0;
-for k1=1:length(v_x)
-    
-    vmag = sqrt(v_x(k1).^2 + v_y(k1).^2);
-    if vmag>0
-        tic
-        grid_sz = 4*(2^ceil(log2(uber_cfg.pdim*vmag)));
-        xscale = grid_sz/uber_cfg.mdim;
-        
-        % Generate layer-1 
-        phase2  = kolmogorov(grid_sz, xscale*Dr0 );
-        p0      = (grid_sz - uber_cfg.pdim)/2;
-        v_co    = (p0+1):(p0+uber_cfg.pdim);
-        cube    = zeros(uber_cfg.pdim,uber_cfg.pdim,Nseq_length);
-
-        % Propagate the large layer using randomly chosen wind vectors 
-        tmp     = phase2;
-        for k=1:Nseq_length
-            cube(:,:,k) = tmp(v_co,v_co);
-            if v_x(k1)>0
-                tmp=shiftr(tmp,0,abs(v_x(k1)));
-            elseif v_x(k1)<0
-                tmp=shiftl(tmp,0,abs(v_x(k1)));
-            end
-            if v_y(k1)>0
-                tmp=shiftu(tmp,0,abs(v_y(k1)));
-            elseif v_y(k1)<0
-                tmp=shiftd(tmp,0,abs(v_y(k1)));
-            end
-        end
-        cube        = cube.*uber_cfg.pupil_mask;
-        
-        % Generate a second layer with a differnt random veloicty 
-        phase       = padarray(cube,[pad_dim pad_dim],0,'both');
-        psf         = zeros(size(phase));
-
-
-
-        for k=1:size(phase,3)
-            a   = ifft2(pupil_amp.*exp(sqrt(-1).*phase(:,:,k)));
-            h   = abs(ifftshift(abs(a).^2));
-            psf(:,:,k) = h;
-        end
-
-        arr = abs(fftshift(fft2(psf))).^2;
-        save(['mc' num2str(k1) '_psf_modulus_squared.mat' ],'arr','psf');
-        tt=toc;
-        kk_ct = kk_ct+1;
-        fprintf([ 'MC: ' num2str(kk_ct) ' \t v = (' num2str(v_x(k1)) ',' num2str(v_y(k1)) ') \t elapsed time: ' num2str(tt,'%5.3f seconds') '\n' ]);
-    end
-end
-
-
-
diff --git a/Generator/asim/genphase.m b/Generator/asim/genphase.m
deleted file mode 100644
index 3c80623..0000000
--- a/Generator/asim/genphase.m
+++ /dev/null
@@ -1,109 +0,0 @@
-function [phase] = genphase(num_increases)
-%  Generates a phase screen with Kolmogorov statistics.
-%
-%  function [phase] = genphase(num_increases)
-%
-%  Inputs       num_increases   - the number of times the original 15x15
-%                                 screen is to be interpolated
-%
-%  Outputs      phase           - the interpolated phase screen with the
-%                                 edges removed
-%
-%  Rachel Johnston and Cressida Harding
-%  Department of Electrical and Electronic Engineering
-%  University of Canterbury
-%  Christchurch
-%  New Zealand
-%
-%  Code may be copied and used freely provided acknowledgement of the original source
-%  is maintained.
-%
-% First load the singular vectors and values of a 15x 15 turbulence
-% [u,d,v]. Code should be modified to read the file outside the function
-% and pass u,d,v as parameters if greater speed is required.
-%
-load svectors4
-%
-residual = 0.08441735664383*3^(5/3);
-
-inter1 = [...
--0.00166566566045,  0,-0.03407545836221, 0,-0.03407545836221, 0,-0.00166566566045;...
-               0,  0,                0, 0,                0, 0,                0;...
--0.03407545836221,  0, 0.31981657662220, 0, 0.31981657662220, 0,-0.03407545836221;...
-               0,  0,                0, 1,                0, 0,                0;...
--0.03407545836221,  0, 0.31981657662220, 0, 0.31981657662220, 0,-0.03407545836221;...
-               0,  0,                0, 0,                0, 0,                0;...
--0.00166566566045,  0,-0.03407545836221, 0,-0.03407545836221, 0,-0.00166566566045];
-
-inter2 = [ ...
-               0,                0,                0,-0.00166566566045,                0,                0,                0;...
-               0,                0,-0.03407545836221,                0,-0.03407545836221,                0,                0;...
-               0,-0.03407545836221,                0, 0.31981657662220,                0,-0.03407545836221,                0;...
--0.00166566566045,                0, 0.31981657662220,                1, 0.31981657662220,                0,-0.00166566566045;...
-               0,-0.03407545836221,                0, 0.31981657662220,                0,-0.03407545836221,                0;...
-               0,                0,-0.03407545836221,                0,-0.03407545836221,                0,                0;...
-               0,                0,                0,-0.00166566566045,                0,                0,                0];
-
-
-eigd = sqrt(diag(d));
-N = size(eigd,1);
-eigd = eigd .* randn(N,1);
-M = sqrt(N);
-phase = reshape(u*eigd,M,M);
-
-
-rhat = 1/(M-1); % spacing between the samples
-%
-%
-total_points = M;
-for i = 1:num_increases
-%
-% First interpolation
-%
-   clear filled
-   [rows,cols] = size(phase);
-   filled (1:2:2*rows-1,1:2:2*cols-1) = phase;
-   new = conv2(filled, inter1,'same');
-
-%
-%  Next addition of random residual
-%
-   mask = zeros(2*rows-1,2*cols-1);
-   mask(2:2:2*rows-1,2:2:2*cols-1) = ones(rows-1,cols-1);
-   new1 = new + mask .* sqrt(residual*rhat^(5/3)) .* ...
-               randn(2*rows-1,2*cols-1);
-
-%
-% Second interpolation
-%
-   mask1a = zeros(2*rows-1, 2*cols-1);
-   mask1b = zeros(2*rows-1, 2*cols-1);
-
-   mask1a(1:2:2*rows-1, 2:2:2*cols-1) = ones(rows, cols-1);
-   mask1b(2:2:2*rows-1,1:2:2*cols-1)  = ones(rows-1,cols);
-   mask1 = mask1a + mask1b;
-%
-   new2 =  conv2(new1, inter2,'same');
-
-   rhat = rhat/sqrt(2);
-   phase =  new2 + mask1.*  sqrt(residual*rhat^(5/3)) .* ...
-               randn(2*rows-1,2*cols-1);
-%
-% Calculation to work out the size of the new phase screen after
-% truncation to remove edge effects. We llose 5 rows each side.
-% New span of phase screen is (2*rows-12)/(2*rows-2)
-%
-       rhat = rhat/sqrt(2);
-
-       phase = phase(6:2*rows-6,6:2*rows-6);
-       size_phase = size(phase,1);
-
-       total_points = 2*total_points - 1;
-end
-
-try
-scale = (total_points/(size_phase -1))^(5/6);
-phase = phase*scale;
-catch
-    3
-end
\ No newline at end of file
diff --git a/Generator/asim/kolmogorov.m b/Generator/asim/kolmogorov.m
deleted file mode 100644
index afd8796..0000000
--- a/Generator/asim/kolmogorov.m
+++ /dev/null
@@ -1,54 +0,0 @@
-
-function [screen] = kolmogorov(grid_size, D_ro);
-%  Simulation of a phase screen with Kolmogorov Statistics
-%
-%  function [screen] = kolmogorov(grid_size, D_ro);
-%
-%  Inputs       grid_size       - desired phase screen size
-%               D_ro            - D/r0 value, determines severity of turbulence
-%
-%  Outputs      screen          - a phase screen with Kolmogorov Statistics
-%                                 of size [grid_size, grid_size]
-%
-%  Requires     genphase.m
-%               svectors4.mat
-%
-%
-%  Rachel Johnston, Cressida Harding and Richard Lane April 1999
-%  Department of Electrical and Electronic Engineering
-%  University of Canterbury
-%  Christchurch
-%  New Zealand
-%
-%  Code may be copied and used freely provided acknowledgement of the original source
-%  is maintained.
-%
-% Finding the number of increases required
-% Starting from a phasescreen of 15 by 15
-start_size  = 15;
-no_increases = 0;
-final_size = 0;
-while (final_size < grid_size)
-       final_size = 2*start_size - 11;
-       start_size = final_size;
-       no_increases = no_increases + 1;
-end
-
-if no_increases == 0 
-   3 
-end
-%Generating the phasescreen
-full_screen = genphase(no_increases);
-chopped_screen = full_screen(1:grid_size, 1:grid_size);
-
-%Need to rescale the screen so that it has the appropriate D_ro after
-%the chopping
-size_chopped = size(chopped_screen,1);
-size_full = size(full_screen,1);
-scale = (size_full/(size_chopped - 1))^(5/6);
-scaled_screen = chopped_screen*scale;
-
-%Scaling so it has the specfied D_ro
-for b=1:length(D_ro)
-    screen(:,:,b) = scaled_screen*((D_ro(b))^(5/6));
-end
diff --git a/Generator/asim/legendre_basis.m b/Generator/asim/legendre_basis.m
deleted file mode 100644
index 127ef34..0000000
--- a/Generator/asim/legendre_basis.m
+++ /dev/null
@@ -1,14 +0,0 @@
-function v_basis = legendre_basis(x);
-
-v_basis=zeros(length(x),11);
-v_basis(:,1) = 1;
-v_basis(:,2) = x;
-v_basis(:,3) = 3.*x.^2 - 1;
-v_basis(:,4) = 5.*x.^3 - 3.*x;
-v_basis(:,5) = 35.*x.^4 - 30.*x.^2+3;
-v_basis(:,6) = 63.*x.^5-70.*x.^3+15.*x;
-v_basis(:,7) = 231.*x.^6-315.*x.^4+105.*x.^2-5;
-v_basis(:,8) = 429.*x.^7-693.*x.^5+315.*x.^3-35.*x;
-v_basis(:,9) = 6435.*x.^8-12012.*x.^6+6930.*x.^4-1260.*x.^2+35;
-v_basis(:,10) = 12155.*x.^9-25740.*x.^7+18018.*x.^5-4620.*x.^3+315.*x;
-v_basis(:,11) = 46189.*x.^10-109395.*x.^8+90090.*x.^6-30030.*x.^4+3465.*x.^2-63;
diff --git a/Generator/asim/make_speckle.m b/Generator/asim/make_speckle.m
deleted file mode 100644
index 3bc7791..0000000
--- a/Generator/asim/make_speckle.m
+++ /dev/null
@@ -1,52 +0,0 @@
-%
-%  Code to generate a speckle image with a given D/r0
-%
-%  Oversampling increases the sampling rate by this factor
-%  above Nyquist, and the makes speckles are easier to see,
-%  although it is not efficient for processing.
-%
-% function [speckle] = make_speckle(D, r0, oversampling, dim_aperture)
-%
-%  Inputs       dim_aperture    - the number of sample points for the aperture
-%           D - Telescope diameter corresponding to the number of points
-%           r0 - Fried's parameter (vector) for computing PSF's integrated
-%           over spectral band
-%           oversampling - the increase over Nyquist of the speckle
-%                                                                       sampling
-%
-%
-%  Outputs      speckle - a speckle image of size dim_aperture*oversampling
-%                                                               normalised to sum to 1.
-%
-%  Uses genphase.m, kolmogorov.m
-%
-%   Richard Lane June 2001
-%   Department of Electrical and Electronic Engineering
-%   University of Canterbury
-%   Christchurch
-%   New Zealand
-%
-%   Code may be copied and used freely provided acknowledgement of the original source
-%   is maintained.
-%
-function [int_speckle,phase] = make_speckle(D, r0, oversampling, dim_aperture, photons)
-%
-aperture = circle2(dim_aperture/2, dim_aperture);
-
-nB = length(r0);
-int_speckle = zeros(2*dim_aperture*oversampling);
-
-
-phase2 = kolmogorov(dim_aperture, D./r0);
-
-for b=1:nB
-    phase       = phase2(:,:,b);
-    cmplx_aper  = exp(sqrt(-1)*phase).*aperture;
-    cmplx_aperture = zeros(2*dim_aperture*oversampling);
-    cmplx_aperture(1:dim_aperture,1:dim_aperture) = cmplx_aper;
-    cmplx_image = ifft2(cmplx_aperture)*(2*dim_aperture);
-    speckle = fftshift(abs(cmplx_image).^2);
-
-    speckle = speckle/sum(sum(speckle));
-    int_speckle = int_speckle + speckle;
-end
diff --git a/Generator/asim/svectors4.mat b/Generator/asim/svectors4.mat
deleted file mode 100644
index 88fbf9a..0000000
Binary files a/Generator/asim/svectors4.mat and /dev/null differ
diff --git a/Generator/library/.DS_Store b/Generator/library/.DS_Store
deleted file mode 100755
index a93bd8f..0000000
Binary files a/Generator/library/.DS_Store and /dev/null differ
diff --git a/Generator/library/._.DS_Store b/Generator/library/._.DS_Store
deleted file mode 100755
index 09fa6bd..0000000
Binary files a/Generator/library/._.DS_Store and /dev/null differ
diff --git a/Generator/library/._FourierShift2D.m b/Generator/library/._FourierShift2D.m
deleted file mode 100644
index 735d55a..0000000
Binary files a/Generator/library/._FourierShift2D.m and /dev/null differ
diff --git a/Generator/library/._GetPupilDiams.m b/Generator/library/._GetPupilDiams.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/library/._GetPupilDiams.m and /dev/null differ
diff --git a/Generator/library/._GradientReconTools b/Generator/library/._GradientReconTools
deleted file mode 100755
index 23f6476..0000000
Binary files a/Generator/library/._GradientReconTools and /dev/null differ
diff --git a/Generator/library/._GradxMatrix.m b/Generator/library/._GradxMatrix.m
deleted file mode 100755
index cc5062a..0000000
Binary files a/Generator/library/._GradxMatrix.m and /dev/null differ
diff --git a/Generator/library/._GradyMatrix.m b/Generator/library/._GradyMatrix.m
deleted file mode 100755
index cc5062a..0000000
Binary files a/Generator/library/._GradyMatrix.m and /dev/null differ
diff --git a/Generator/library/._ObjectReconTools b/Generator/library/._ObjectReconTools
deleted file mode 100755
index dfcf643..0000000
Binary files a/Generator/library/._ObjectReconTools and /dev/null differ
diff --git a/Generator/library/._OptimTools b/Generator/library/._OptimTools
deleted file mode 100755
index 39c3965..0000000
Binary files a/Generator/library/._OptimTools and /dev/null differ
diff --git a/Generator/library/._PhaseReconTools b/Generator/library/._PhaseReconTools
deleted file mode 100755
index 23f6476..0000000
Binary files a/Generator/library/._PhaseReconTools and /dev/null differ
diff --git a/Generator/library/._ReconstructPhase_Layers.m b/Generator/library/._ReconstructPhase_Layers.m
deleted file mode 100644
index 570d041..0000000
Binary files a/Generator/library/._ReconstructPhase_Layers.m and /dev/null differ
diff --git a/Generator/library/._ReconstructPhase_fast.m b/Generator/library/._ReconstructPhase_fast.m
deleted file mode 100755
index 32a3d3b..0000000
Binary files a/Generator/library/._ReconstructPhase_fast.m and /dev/null differ
diff --git a/Generator/library/._SimpleImresize.m b/Generator/library/._SimpleImresize.m
deleted file mode 100644
index 8f48d87..0000000
Binary files a/Generator/library/._SimpleImresize.m and /dev/null differ
diff --git a/Generator/library/._TestProblem.m b/Generator/library/._TestProblem.m
deleted file mode 100644
index a258ab8..0000000
Binary files a/Generator/library/._TestProblem.m and /dev/null differ
diff --git a/Generator/library/._azi_avg.m b/Generator/library/._azi_avg.m
deleted file mode 100755
index a258ab8..0000000
Binary files a/Generator/library/._azi_avg.m and /dev/null differ
diff --git a/Generator/library/._block_avg.m b/Generator/library/._block_avg.m
deleted file mode 100644
index a258ab8..0000000
Binary files a/Generator/library/._block_avg.m and /dev/null differ
diff --git a/Generator/library/._block_rep.m b/Generator/library/._block_rep.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/library/._block_rep.m and /dev/null differ
diff --git a/Generator/library/._brent.m b/Generator/library/._brent.m
deleted file mode 100755
index e7df5f9..0000000
Binary files a/Generator/library/._brent.m and /dev/null differ
diff --git a/Generator/library/._centroid.m b/Generator/library/._centroid.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/library/._centroid.m and /dev/null differ
diff --git a/Generator/library/._check_derivatives.m b/Generator/library/._check_derivatives.m
deleted file mode 100755
index a258ab8..0000000
Binary files a/Generator/library/._check_derivatives.m and /dev/null differ
diff --git a/Generator/library/._compute_dwfs.m b/Generator/library/._compute_dwfs.m
deleted file mode 100644
index 6c2772f..0000000
Binary files a/Generator/library/._compute_dwfs.m and /dev/null differ
diff --git a/Generator/library/._dfridr.m b/Generator/library/._dfridr.m
deleted file mode 100755
index a062fc6..0000000
Binary files a/Generator/library/._dfridr.m and /dev/null differ
diff --git a/Generator/library/._dora_make_mask.m b/Generator/library/._dora_make_mask.m
deleted file mode 100644
index 6c2772f..0000000
Binary files a/Generator/library/._dora_make_mask.m and /dev/null differ
diff --git a/Generator/library/._echo_out.m b/Generator/library/._echo_out.m
deleted file mode 100755
index 47ed7af..0000000
Binary files a/Generator/library/._echo_out.m and /dev/null differ
diff --git a/Generator/library/._f_special.m b/Generator/library/._f_special.m
deleted file mode 100644
index a258ab8..0000000
Binary files a/Generator/library/._f_special.m and /dev/null differ
diff --git a/Generator/library/._fourier_view.m b/Generator/library/._fourier_view.m
deleted file mode 100644
index a258ab8..0000000
Binary files a/Generator/library/._fourier_view.m and /dev/null differ
diff --git a/Generator/library/._func_golden.m b/Generator/library/._func_golden.m
deleted file mode 100755
index e7df5f9..0000000
Binary files a/Generator/library/._func_golden.m and /dev/null differ
diff --git a/Generator/library/._func_mnbrak.m b/Generator/library/._func_mnbrak.m
deleted file mode 100755
index e7df5f9..0000000
Binary files a/Generator/library/._func_mnbrak.m and /dev/null differ
diff --git a/Generator/library/._func_object_move.m b/Generator/library/._func_object_move.m
deleted file mode 100644
index a258ab8..0000000
Binary files a/Generator/library/._func_object_move.m and /dev/null differ
diff --git a/Generator/library/._gamrnd.m b/Generator/library/._gamrnd.m
deleted file mode 100644
index a258ab8..0000000
Binary files a/Generator/library/._gamrnd.m and /dev/null differ
diff --git a/Generator/library/._gauss3filter.m b/Generator/library/._gauss3filter.m
deleted file mode 100755
index cee5533..0000000
Binary files a/Generator/library/._gauss3filter.m and /dev/null differ
diff --git a/Generator/library/._gaussian_kernel.m b/Generator/library/._gaussian_kernel.m
deleted file mode 100644
index a258ab8..0000000
Binary files a/Generator/library/._gaussian_kernel.m and /dev/null differ
diff --git a/Generator/library/._hsymmetry.m b/Generator/library/._hsymmetry.m
deleted file mode 100755
index e7df5f9..0000000
Binary files a/Generator/library/._hsymmetry.m and /dev/null differ
diff --git a/Generator/library/._image_com.m b/Generator/library/._image_com.m
deleted file mode 100644
index f0bfaa1..0000000
Binary files a/Generator/library/._image_com.m and /dev/null differ
diff --git a/Generator/library/._image_rmse.m b/Generator/library/._image_rmse.m
deleted file mode 100644
index 2acebef..0000000
Binary files a/Generator/library/._image_rmse.m and /dev/null differ
diff --git a/Generator/library/._imnoisex.m b/Generator/library/._imnoisex.m
deleted file mode 100644
index a258ab8..0000000
Binary files a/Generator/library/._imnoisex.m and /dev/null differ
diff --git a/Generator/library/._make_circle_mask.m b/Generator/library/._make_circle_mask.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/library/._make_circle_mask.m and /dev/null differ
diff --git a/Generator/library/._model_polychromatic_psf.m b/Generator/library/._model_polychromatic_psf.m
deleted file mode 100755
index eb72e87..0000000
Binary files a/Generator/library/._model_polychromatic_psf.m and /dev/null differ
diff --git a/Generator/library/._movingmean.m b/Generator/library/._movingmean.m
deleted file mode 100755
index 664d8ca..0000000
Binary files a/Generator/library/._movingmean.m and /dev/null differ
diff --git a/Generator/library/._objectDL_start_ovar2.m b/Generator/library/._objectDL_start_ovar2.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/library/._objectDL_start_ovar2.m and /dev/null differ
diff --git a/Generator/library/._p_GetPupilDiams.m b/Generator/library/._p_GetPupilDiams.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/library/._p_GetPupilDiams.m and /dev/null differ
diff --git a/Generator/library/._p_ImgScale.m b/Generator/library/._p_ImgScale.m
deleted file mode 100755
index 0e8cfa4..0000000
Binary files a/Generator/library/._p_ImgScale.m and /dev/null differ
diff --git a/Generator/library/._p_dora_color_psf.m b/Generator/library/._p_dora_color_psf.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/library/._p_dora_color_psf.m and /dev/null differ
diff --git a/Generator/library/._pad_arrayX.m b/Generator/library/._pad_arrayX.m
deleted file mode 100755
index a062fc6..0000000
Binary files a/Generator/library/._pad_arrayX.m and /dev/null differ
diff --git a/Generator/library/._padarray2.m b/Generator/library/._padarray2.m
deleted file mode 100755
index a062fc6..0000000
Binary files a/Generator/library/._padarray2.m and /dev/null differ
diff --git a/Generator/library/._phases_from_image_com.m b/Generator/library/._phases_from_image_com.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/library/._phases_from_image_com.m and /dev/null differ
diff --git a/Generator/library/._poissrndX.m b/Generator/library/._poissrndX.m
deleted file mode 100644
index a258ab8..0000000
Binary files a/Generator/library/._poissrndX.m and /dev/null differ
diff --git a/Generator/library/._pupil2otfmask.m b/Generator/library/._pupil2otfmask.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/library/._pupil2otfmask.m and /dev/null differ
diff --git a/Generator/library/._randraw b/Generator/library/._randraw
deleted file mode 100755
index 980d033..0000000
Binary files a/Generator/library/._randraw and /dev/null differ
diff --git a/Generator/library/._rndcheck.m b/Generator/library/._rndcheck.m
deleted file mode 100644
index a258ab8..0000000
Binary files a/Generator/library/._rndcheck.m and /dev/null differ
diff --git a/Generator/library/._sepblockfun.m b/Generator/library/._sepblockfun.m
deleted file mode 100755
index 4b669b3..0000000
Binary files a/Generator/library/._sepblockfun.m and /dev/null differ
diff --git a/Generator/library/._sm_centroid.m b/Generator/library/._sm_centroid.m
deleted file mode 100644
index a258ab8..0000000
Binary files a/Generator/library/._sm_centroid.m and /dev/null differ
diff --git a/Generator/library/._sub_modes.m b/Generator/library/._sub_modes.m
deleted file mode 100755
index 34e7548..0000000
Binary files a/Generator/library/._sub_modes.m and /dev/null differ
diff --git a/Generator/library/._tight_subplot.m b/Generator/library/._tight_subplot.m
deleted file mode 100644
index 409ccd2..0000000
Binary files a/Generator/library/._tight_subplot.m and /dev/null differ
diff --git a/Generator/library/._upsample_data2newgrid.m b/Generator/library/._upsample_data2newgrid.m
deleted file mode 100644
index 6c2b764..0000000
Binary files a/Generator/library/._upsample_data2newgrid.m and /dev/null differ
diff --git a/Generator/library/._xpadarray.m b/Generator/library/._xpadarray.m
deleted file mode 100755
index 30465b0..0000000
Binary files a/Generator/library/._xpadarray.m and /dev/null differ
diff --git a/Generator/library/._zernike.m b/Generator/library/._zernike.m
deleted file mode 100644
index 95d36fc..0000000
Binary files a/Generator/library/._zernike.m and /dev/null differ
diff --git a/Generator/library/._zernikes.m b/Generator/library/._zernikes.m
deleted file mode 100644
index b33fbde..0000000
Binary files a/Generator/library/._zernikes.m and /dev/null differ
diff --git a/Generator/library/FFM/.DS_Store b/Generator/library/FFM/.DS_Store
deleted file mode 100755
index 0f16e07..0000000
Binary files a/Generator/library/FFM/.DS_Store and /dev/null differ
diff --git a/Generator/library/FFM/._.DS_Store b/Generator/library/FFM/._.DS_Store
deleted file mode 100755
index 09fa6bd..0000000
Binary files a/Generator/library/FFM/._.DS_Store and /dev/null differ
diff --git a/Generator/library/FFM/._GradientReconTools b/Generator/library/FFM/._GradientReconTools
deleted file mode 100755
index 25a956c..0000000
Binary files a/Generator/library/FFM/._GradientReconTools and /dev/null differ
diff --git a/Generator/library/FFM/._PhaseReconTools b/Generator/library/FFM/._PhaseReconTools
deleted file mode 100755
index 25a956c..0000000
Binary files a/Generator/library/FFM/._PhaseReconTools and /dev/null differ
diff --git a/Generator/library/FFM/._ReconstructGradient_Naive.m b/Generator/library/FFM/._ReconstructGradient_Naive.m
deleted file mode 100755
index 7d21b14..0000000
Binary files a/Generator/library/FFM/._ReconstructGradient_Naive.m and /dev/null differ
diff --git a/Generator/library/FFM/._p_FFM.m b/Generator/library/FFM/._p_FFM.m
deleted file mode 100755
index 7d21b14..0000000
Binary files a/Generator/library/FFM/._p_FFM.m and /dev/null differ
diff --git a/Generator/library/FFM/._p_ReconstructGradient.m b/Generator/library/FFM/._p_ReconstructGradient.m
deleted file mode 100755
index 7d21b14..0000000
Binary files a/Generator/library/FFM/._p_ReconstructGradient.m and /dev/null differ
diff --git a/Generator/library/FFM/._p_ReconstructPhase.m b/Generator/library/FFM/._p_ReconstructPhase.m
deleted file mode 100755
index 47ef751..0000000
Binary files a/Generator/library/FFM/._p_ReconstructPhase.m and /dev/null differ
diff --git a/Generator/library/FFM/GradientReconTools/._AffineTransform.m b/Generator/library/FFM/GradientReconTools/._AffineTransform.m
deleted file mode 100755
index cc5062a..0000000
Binary files a/Generator/library/FFM/GradientReconTools/._AffineTransform.m and /dev/null differ
diff --git a/Generator/library/FFM/GradientReconTools/._BuildInterpMatrix.m b/Generator/library/FFM/GradientReconTools/._BuildInterpMatrix.m
deleted file mode 100755
index 696751e..0000000
Binary files a/Generator/library/FFM/GradientReconTools/._BuildInterpMatrix.m and /dev/null differ
diff --git a/Generator/library/FFM/GradientReconTools/._GetCompositeGridSize.m b/Generator/library/FFM/GradientReconTools/._GetCompositeGridSize.m
deleted file mode 100755
index 7d21b14..0000000
Binary files a/Generator/library/FFM/GradientReconTools/._GetCompositeGridSize.m and /dev/null differ
diff --git a/Generator/library/FFM/GradientReconTools/._GetCompositeGridSizes.m b/Generator/library/FFM/GradientReconTools/._GetCompositeGridSizes.m
deleted file mode 100755
index a258ab8..0000000
Binary files a/Generator/library/FFM/GradientReconTools/._GetCompositeGridSizes.m and /dev/null differ
diff --git a/Generator/library/FFM/GradientReconTools/._GetCompositeMask.m b/Generator/library/FFM/GradientReconTools/._GetCompositeMask.m
deleted file mode 100755
index 7d21b14..0000000
Binary files a/Generator/library/FFM/GradientReconTools/._GetCompositeMask.m and /dev/null differ
diff --git a/Generator/library/FFM/GradientReconTools/._GetPixelCenters2D.m b/Generator/library/FFM/GradientReconTools/._GetPixelCenters2D.m
deleted file mode 100755
index 696751e..0000000
Binary files a/Generator/library/FFM/GradientReconTools/._GetPixelCenters2D.m and /dev/null differ
diff --git a/Generator/library/FFM/GradientReconTools/._MotionMatrix.m b/Generator/library/FFM/GradientReconTools/._MotionMatrix.m
deleted file mode 100755
index cc5062a..0000000
Binary files a/Generator/library/FFM/GradientReconTools/._MotionMatrix.m and /dev/null differ
diff --git a/Generator/library/FFM/GradientReconTools/._SpaceToMidx2D.m b/Generator/library/FFM/GradientReconTools/._SpaceToMidx2D.m
deleted file mode 100755
index 696751e..0000000
Binary files a/Generator/library/FFM/GradientReconTools/._SpaceToMidx2D.m and /dev/null differ
diff --git a/Generator/library/FFM/GradientReconTools/._SubsampleMatrix.m b/Generator/library/FFM/GradientReconTools/._SubsampleMatrix.m
deleted file mode 100755
index cc5062a..0000000
Binary files a/Generator/library/FFM/GradientReconTools/._SubsampleMatrix.m and /dev/null differ
diff --git a/Generator/library/FFM/GradientReconTools/._TransformCoordinates2D.m b/Generator/library/FFM/GradientReconTools/._TransformCoordinates2D.m
deleted file mode 100755
index 696751e..0000000
Binary files a/Generator/library/FFM/GradientReconTools/._TransformCoordinates2D.m and /dev/null differ
diff --git a/Generator/library/FFM/GradientReconTools/._WindowMatrix.m b/Generator/library/FFM/GradientReconTools/._WindowMatrix.m
deleted file mode 100755
index cc5062a..0000000
Binary files a/Generator/library/FFM/GradientReconTools/._WindowMatrix.m and /dev/null differ
diff --git a/Generator/library/FFM/GradientReconTools/AffineTransform.m b/Generator/library/FFM/GradientReconTools/AffineTransform.m
deleted file mode 100755
index 0993e99..0000000
--- a/Generator/library/FFM/GradientReconTools/AffineTransform.m
+++ /dev/null
@@ -1,146 +0,0 @@
-function T = AffineTransform(n_ap, n_frames, deltax, deltay)
-%
-%    T = AffineTransform(n_ap, n_frames, deltax, deltay);
-%
-%  This function generates affine tranformations from given motion data.
-%
-%  Input: 
-%   n_ap       - number of pixels across the aperture (diameter)
-%   n_frames   - number of frames
-%   deltax     - motion information of each of the layers; number of
-%                high resolution pixels shifting in x - direction.
-%   deltay     - motion information of each of the layers; number of
-%                high resolution pixels shifting in y - direction.
-%
-%  Output:
-%   T          - affine tranformations
-%
-
-%
-%  Remark: We could include rotation in this as well, but for now we
-%          only implement only shifts. If later we want to include
-%          rotations, then we will need to edit this code as follows:
-%          * include an additional input: delta_theta
-%          * uncomment the lines below that pertain to rotation
-%
-
-n_layers = size(deltax,1);
-
-if size(deltax,2) > 1
-  % The velocity is not constant, so this should be n_frames-1 in
-  % length
-  if size(deltax,2) ~= n_frames-1
-    error('incorrect deltax for nonconstant velocity')
-  end
-  deltax_vec = deltax;
-else
-  deltax_vec = deltax(:,ones(1,n_frames-1));
-end
-if size(deltay,2) > 1
-  % The velocity is not constant, so this should be n_frames-1 in
-  % length
-  if size(deltay,2) ~= n_frames-1
-    error('incorrect deltay for nonconstant velocity')
-  end
-  deltay_vec = deltay;
-else
-  deltay_vec = deltay(:,ones(1,n_frames-1));
-end
-%----------------------------------
-% ROTATION STATMENTS:
-%
-% If we edit this code to allow for rotation, uncomment the following:
-%
-%if size(delta_theta,2) > 1
-%  % The velocity is not constant, so this should be n_frames-1 in
-%  % length
-%  if size(delta_theta,2) ~= n_frames-1
-%    error('incorrect delta_theta for nonconstant velocity')
-%  end
-%  delta_theta_vec = delta_theta;
-%else
-%  delta_theta_vec = delta_theta(:,ones(1,n_frames-1));
-%end
-%
-%----------------------------------
-
-T = zeros(3, 3, n_frames, n_layers);
-
-for L = 1:n_layers
-  %
-  %  The first frame is the reference frame, so the affine transformation
-  %  should be the identity.
-  %
-  T(:,:,1,L) = eye(3);
-  
-  for k = 2:n_frames
-    dx = sum(deltax_vec(L,1:k-1)); % the shifting = integral of velocity * delta_time
-    dy = sum(deltay_vec(L,1:k-1));
-    %----------------------------------
-    % ROTATION CODES: If we want to use rotations, uncomment this line:
-    %
-    % theta = sum(delta_theta_vec(L,1:k-1));
-    %
-    %----------------------------------
-        
-    %
-    % Get spatial coordinates of center points of pixels:
-    %   Note: If we assume the image is defined on a standard Euclidean
-    %         coordinate system:
-    %
-    %              y ^
-    %                |
-    %                |
-    %                |-------->
-    %                         x
-    %
-    %          then an affine
-        
-    %
-    % Now shift the coordinate system:
-    % Create affine transformation to do the shifting of coordinates:
-    % Note: According to our coordinate system, dx > 0 means move right,
-    %       and dy > 0 means moves up.
-    %
-    % The affine transformation for this is:
-    %
-    T_shift = [1 0 0; 0 1 0; -dx -dy 1];
-
-    %----------------------------------
-    % ROTATION CODES: If we want to include rotation, uncomment these lines
-    %
-    % % Now consider a rotation about the center of the image.
-    % %  Rotation is clockwise by an angle theta.
-    % %  and that the center of rotation is the point ((n+1)/2, (m+1)/2)
-    % %  where the image is m-by-n pixels.
-    % %
-    % %  Note that standard rotation is about (0,0).  So we first need
-    % %  to shift the center of the image to the coordinate (0,0), then
-    % %  rotate, then shift back.
-    % %
-    % %  Shfit to (0,0):
-    % %
-    % SL = [1 0 0;0 1 0;-(n-1)/2 -(n_ap-1)/2 1];
-    % %  Rotate by angle theta.
-    % TR = [cos(theta), sin(theta), 0;-sin(theta), cos(theta), 0; 0, 0, 1];
-    % %  Now shift back.
-    % SR = [1 0 0;0 1 0; (n-1)/2,  (m-1)/2, 1];
-    % % The combined transformation is:
-    % T_rot_center = SL*TR*SR;
-    %
-    %----------------------------------
-    %
-    % ROTATION CODES: If we want to includ rotation, comment out this
-    %                 next line:
-    %
-    T_rot_center = eye(3);
-    %
-    %----------------------------------
-    %
-    %  Finally, the combined tranformation that shifts and rotates about
-    %  center is:
-    %
-    T(:,:,k,L) = T_shift * T_rot_center;
-    %   
-  end
-end
diff --git a/Generator/library/FFM/GradientReconTools/BuildInterpMatrix.m b/Generator/library/FFM/GradientReconTools/BuildInterpMatrix.m
deleted file mode 100755
index ba2111a..0000000
--- a/Generator/library/FFM/GradientReconTools/BuildInterpMatrix.m
+++ /dev/null
@@ -1,77 +0,0 @@
-function S = BuildInterpMatrix(I, J, m, n)
-%
-%  Given pixel coordinates, (I,J) = (row, col), which
-%  are not necessarily integers, this function computes
-%  an interpolation matrix S so that y = S*x interpolates
-%  pixel values in the image x to give pixel values in
-%  the image y.
-%
-%  Here we use linear interpolation.
-%
-%  Input:
-%    I and J are arrays of size m-by-n (same as image dimensions).
-%       These contain coordinates of an image transformation.
-%    m, n is the size of the image.
-%
-%  Output:
-%    S is a sparse matrix
-%
-
-% First find integer coordinates that surround each
-% (I(i,j),J(i,j))
-% These will be the bilinear interpolation coordinates.
-%
-i0 = floor(I(:));
-i1 = ceil(I(:));
-j0 = floor(J(:));
-j1 = ceil(J(:));
-
-i1 = i0+1;
-j1 = j0+1;
-
-%
-% To avoid playing games with indices, we are very sloppy
-% around the border.  Interpolation is only done if ALL of the
-% points that surround (I(i,j),J(i,j)) are within the image
-% boarders.  This makes it easier to compute the interpolation
-% weights without having to use special conditions near
-% the borders.  If we assume black areas near the border,
-% then this should not cause any problems.
-%
-% The first step, then, is to find the rows that will contain
-% weights.
-%
-row_idx = find(1<=i0 & i1<=m & 1<=j0 & j1<=n);
-i = [row_idx; row_idx; row_idx; row_idx];
-
-% Since we only consider interior pixel values, then each
-% row will have exactly four weights.  So next we find the
-% four column indices where these weights should be put.
-% We are assuming column ordering of the image.
-%
-i0 = i0(row_idx);, i1 = i1(row_idx);, j0 = j0(row_idx);, j1 = j1(row_idx);
-
-col_idx1 = i0 + m*(j0-1);
-col_idx2 = i1 + m*(j0-1);
-col_idx3 = i0 + m*(j1-1);
-col_idx4 = i1 + m*(j1-1);
-j = [col_idx1; col_idx2; col_idx3; col_idx4];
-
-%
-% Now we compute the weights that go into the matrix.
-%
-deltai = I(row_idx) - i0;
-deltaj = J(row_idx) - j0;
-w1 = (1 - deltai).*(1 - deltaj);
-w2 = (1 - deltaj).*deltai;
-w3 = (1 - deltai).*deltaj;
-w4 = deltai.*deltaj;
-s = [w1; w2; w3; w4];
-
-
-%
-% Now let's put the weights in the sparse matrix.
-%
-S = sparse(i, j, s, m*n, m*n);
-
-
diff --git a/Generator/library/FFM/GradientReconTools/GetCompositeGridSize.m b/Generator/library/FFM/GradientReconTools/GetCompositeGridSize.m
deleted file mode 100755
index 6b38a8d..0000000
--- a/Generator/library/FFM/GradientReconTools/GetCompositeGridSize.m
+++ /dev/null
@@ -1,30 +0,0 @@
-function [n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay)
-%
-%  [n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay);
-%  
-% This function computes the grid size needed to store the composite
-% high resolution gradients and phases.
-%
-% Input:
-%   n_ap       - number of pixels across the aperture (diameter)
-%   n_frames   - number of frames
-%   deltax     - motion information of each of the layers; number of
-%                high resolution pixels shifting in x - direction.
-%   deltay     - motion information of each of the layers; number of
-%                high resolution pixels shifting in y - direction.
-%
-% Output:
-%   n_comp     - composit grid size
-%   n_comp_pad - amount the aperture needs to be padded to get to the
-%                composite grid size
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-n_comp_pad = max( max( ceil( abs([deltax, deltay])*n_frames ) ) );
-n_comp = n_ap + 2*n_comp_pad;
-
-
diff --git a/Generator/library/FFM/GradientReconTools/GetCompositeGridSizes.m b/Generator/library/FFM/GradientReconTools/GetCompositeGridSizes.m
deleted file mode 100755
index 5cfc889..0000000
--- a/Generator/library/FFM/GradientReconTools/GetCompositeGridSizes.m
+++ /dev/null
@@ -1,42 +0,0 @@
-function [n_comp, n_comp_pad] = GetCompositeGridSizes(n_ap, n_WFS_frames, wind_vecs, ssp)
-%
-%  n_comp = GetCompositeGridSizes(n_ap, n_WFS_frames, wind_vecs);
-%  
-% This function computes the grid sizes needed to store the composite
-% high resolution gradients and phases for a set of FFM frames.
-%
-% Input:
-%   n_ap         - number of pixels across the aperture (diameter)
-%   n_WFS_frames - vector containing the number of frames used for each
-%                  FFM reconstruction
-%   wind_vecs    - 2D double array that specifies angle (theta) and 
-%                  magnitude (r) of wind velocity for each layer:
-%                      wind_vecs(L,1) = r   
-%                      wind_vecs(L,2) = theta 
-%                  L = 1, 2, ..., n_layers.
-%
-% Output:
-%   n_comp     - vector containing composite grid sizes
-%   n_comp_pad - amount the aperture needs to be padded to get to the
-%                composite grid sizes
-%
-
-%
-%  J. Nagy
-%  October, 2013
-%
-
-%
-%  Convert wind_vecs into pixel shif\t values:
-%
-deltax = ssp*wind_vecs(:,1) .* cos(wind_vecs(:,2));
-deltay = ssp*wind_vecs(:,1) .* sin(wind_vecs(:,2));
-nframes = length(n_WFS_frames);
-n_comp = zeros(nframes,1);
-for k = 1:nframes
-  %
-  %  We need to find a composite grid size, and the amount of padding needed
-  %  to get from n_ap to n_conmp.  
-  %
-  [n_comp(k), n_comp_pad] = GetCompositeGridSize(n_ap, n_WFS_frames(k), deltax, deltay);
-end
\ No newline at end of file
diff --git a/Generator/library/FFM/GradientReconTools/GetCompositeMask.m b/Generator/library/FFM/GradientReconTools/GetCompositeMask.m
deleted file mode 100755
index c7811e8..0000000
--- a/Generator/library/FFM/GradientReconTools/GetCompositeMask.m
+++ /dev/null
@@ -1,50 +0,0 @@
-function pupil_maskC = GetCompositeMask(pupil_mask,wind_vecs, ssp, n_ap, n_comp, n_comp_pad, n_frames, n_layers)
-%
-%  pupil_maskC = GetCompositeMask(pupil_mask, wind_vecs, ssp, n_ap, ...
-%        n_comp, n_comp_pad, n_frames, n_layers);
-%
-%  This function comptues the mask of the composit grid.
-%
-%  Input:
-%    pupil_mask  - pupil mask
-%    wind_vecs   - specifies angle (theta) and magnitude (r) of wind 
-%                  velocity for each layer:
-%                       wind_vecs(L,1) = r   
-%                       wind_vecs(L,2) = theta 
-%                  L = 1, 2, ..., n_layers.
-%    ssp         - subsampling parameter that relates low resolution
-%                  grid to high resolution grid
-%    n_ap        - size of aperture
-%    n_comp      - size of composite grid
-%    n_comp_pad  - size of padding to get from n_ap to n_comp
-%                  (see GetCompositeGridSize.m)
-%    n_frames    - number of frames of data
-%    n_layers    - number of atmospheric layers
-%
-%  Output:
-%    pupil_maskC - 3D logical array containing mask for composite
-%                  information (phases and gradients) on leach layer.
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-%
-%    * Start with the pupil mask on the composite grid.
-%    * Move the pupil mask across the composite grid
-%    * BUT make sure that the pupil mask moves in the opposite 
-%      direction as the sky.  This done by adding pi to the
-%      angle of the wind vectors.
-%
-deltax2 = ssp*wind_vecs(:,1) .* cos(pi+wind_vecs(:,2));
-deltay2 = ssp*wind_vecs(:,1) .* sin(pi+wind_vecs(:,2));
-
-A2 = MotionMatrix(deltax2, deltay2, n_comp, n_ap, n_frames);
-pupil_mask_pad = padarray(pupil_mask, [n_comp_pad,n_comp_pad],0,'both');
-N = n_comp*n_comp;
-v = kron(speye(n_layers),pupil_mask_pad(:));
-v = full(A2*v);
-v = reshape(v, N, n_frames, n_layers);
-pupil_maskC = reshape(squeeze(sum(v, 2) > 0),n_comp,n_comp,n_layers);
diff --git a/Generator/library/FFM/GradientReconTools/GetPixelCenters2D.m b/Generator/library/FFM/GradientReconTools/GetPixelCenters2D.m
deleted file mode 100755
index 959b55d..0000000
--- a/Generator/library/FFM/GradientReconTools/GetPixelCenters2D.m
+++ /dev/null
@@ -1,23 +0,0 @@
-function [X, Y] = GetPixelCenters2D(m,n)
-%
-%           [X, Y] = GetPixelCenters(m,n);
-%
-%  Find the (x,y) coordinates of the centers of pixels of an image.
-%  NOTE:  Here it is assumed that the image boundaries are defined by the
-%         standard Euclidean coordinate system:
-%              y ^
-%                |
-%                |
-%                |-------->
-%                         x
-%         and the centers of the pixels are given at (x,y), where
-%         x = 0, 1, 2, ..., n-1, 
-%         y = 0, 1, 2, ..., m-1
-%
-%  Input:  m, n = dimension of the image
-%
-%  Output: X = x-coordinates of centers of the pixels
-%          Y = y-coordinates of centers of the pixels
-%
-
-[X, Y] = meshgrid(0:n-1, m-1:-1:0);
\ No newline at end of file
diff --git a/Generator/library/FFM/GradientReconTools/MotionMatrix.m b/Generator/library/FFM/GradientReconTools/MotionMatrix.m
deleted file mode 100755
index 3d78343..0000000
--- a/Generator/library/FFM/GradientReconTools/MotionMatrix.m
+++ /dev/null
@@ -1,66 +0,0 @@
-function A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames)
-%
-%     A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames);
-%
-%  Use the motion information, as given by deltax and deltay,
-%  to create a sparse matrix that, when multiplied to the large 
-%  global wavefront (or gradient fields) will move them to get the
-%  wavefronts (or gradient fields) in the position corresponding to
-%  each frame.
-%
-%  Input:
-%   deltax     - motion information of each of the layers; number of
-%                high resolution pixels shifting in x - direction.
-%   deltay     - motion information of each of the layers; number of
-%                high resolution pixels shifting in y - direction.
-%   n_comp     - composit grid size
-%   n_ap       - number of pixels across the aperture (diameter)
-%   n_frames   - number of frames
-%
-%  Output:
-%   A          - sparse matrix
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-n_layers = size(deltax,1);
-
-%
-%  Get affine transformations for the motion:
-%
-T = AffineTransform(n_ap, n_frames, deltax, deltay);
-
-A = [];
-for L = 1:n_layers 
-  %
-  % Get pixel centers of composite image.
-  %
-  [X, Y] = GetPixelCenters2D(n_comp, n_comp);
-
-  AA = [];
-  %h = waitbar(0, sprintf('Building motion matrices for layer %d', L));
-  for k = 1:n_frames
-    %
-    %  Use affine transfromation to transfrom coordinates:
-    %
-    [Xnew, Ynew] = TransformCoordinates2D(T(:,:,k,L), X, Y);
- 
-    %
-    %  Get MATLAB indices corresponding to these new coordinates:
-    %
-    [I, J] = SpaceToMidx2D(Xnew, Ynew);
-  
-    %
-    % Now build the sparse matrix that does the geometric
-    % transformation on the image.
-    %
-    S = BuildInterpMatrix(I, J, n_comp, n_comp);
-    AA = [AA; S];
-    
-    %waitbar(k/n_frames)
-  end
-  %close(h)
-  A = [A, AA];
-end
diff --git a/Generator/library/FFM/GradientReconTools/SpaceToMidx2D.m b/Generator/library/FFM/GradientReconTools/SpaceToMidx2D.m
deleted file mode 100755
index 94a4f18..0000000
--- a/Generator/library/FFM/GradientReconTools/SpaceToMidx2D.m
+++ /dev/null
@@ -1,20 +0,0 @@
-function [I, J] = SpaceToMidx2D(X, Y, m, n)
-%
-%  Convert the Euclidean spatial coordinates given by (X,Y) to
-%  MATLAB indices.  That is, assume the image array is situated
-%  on the Eucldean axes:
-%
-%              y ^
-%                |
-%                |
-%                |-------->
-%                         x
-%
-if nargin < 3
-  m = size(Y,1);
-  n = size(X,2);
-elseif nargin < 2
-  n = m;
-end
-I = m - Y;
-J = X + 1;
diff --git a/Generator/library/FFM/GradientReconTools/SubsampleMatrix.m b/Generator/library/FFM/GradientReconTools/SubsampleMatrix.m
deleted file mode 100755
index 15bd4eb..0000000
--- a/Generator/library/FFM/GradientReconTools/SubsampleMatrix.m
+++ /dev/null
@@ -1,28 +0,0 @@
-function R = SubsampleMatrix(n, ssp)
-%
-%   R = SubsampleMatrix(n, ssp);
-%   
-% This function constructs a sparse matrix that implements subsampling
-% on an image vector. 
-%
-% Input:
-%   n   - dimension of high resolution grid, assumed square (that is
-%         the high resolution grid is n-by-n pixels)
-%   ssp - subsampling parameter, which must divide n with no remainder
-%
-% Output: 
-%   R   - sparse matrix 
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-if rem(n,ssp)~=0
-  error('n must divide subsampling');
-end 
-
-D = kron(speye(n/ssp),ones(1,ssp));
-R = kron(D,D)/ssp^2;
-
diff --git a/Generator/library/FFM/GradientReconTools/TransformCoordinates2D.m b/Generator/library/FFM/GradientReconTools/TransformCoordinates2D.m
deleted file mode 100755
index 143ce9a..0000000
--- a/Generator/library/FFM/GradientReconTools/TransformCoordinates2D.m
+++ /dev/null
@@ -1,11 +0,0 @@
-function [Xnew, Ynew] = TransformCoordinates2D(T, X, Y)
-%
-%  Transform (x,y) coordinates given by X and Y using the
-%  affine transformation given by T.  That is,
-%     [xnew, ynew] = [x, y, 1]*T
-%
-
-W = [X(:), Y(:), ones(length(X(:)), 1)] * T;
-
-Xnew = reshape(W(:,1), size(X));
-Ynew = reshape(W(:,2), size(Y));
diff --git a/Generator/library/FFM/GradientReconTools/WindowMatrix.m b/Generator/library/FFM/GradientReconTools/WindowMatrix.m
deleted file mode 100755
index 186dd2c..0000000
--- a/Generator/library/FFM/GradientReconTools/WindowMatrix.m
+++ /dev/null
@@ -1,32 +0,0 @@
-function W = WindowMatrix(n_ap, n_comp, pupil_mask, row_start, col_start)
-%
-%  W = WindowMatrix(n_ap, n_comp, pupil_mask, row_start, col_start);
-%
-%  This function constructs a sparse matrix that operates as a mask 
-%  to grab a certain region from an image array.
-%
-%  Input:
-%    n_ap       - size of high resolution image domain at telescope 
-%                       (e.g., 128-by-128)
-%    n_comp     - size of large (global, or composite) image
-%    pupil_mask - pupil mask of telescope
-%    row_start  -  These tell were the rectangular winow, which contains
-%    col_start  /  the pupil mask, should begin in the composite grid.
-%
-%  Output:
-%    W          - sparse matrix
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-jw1 = kron((0:n_ap-1)',n_comp*ones(n_ap,1));
-%jw2 = kron(ones(n_ap,1),(1:n_ap)');
-t1 = n_comp*(col_start-1)+row_start;
-jw2 = kron(ones(n_ap,1),(t1:t1+n_ap-1)');
-jw = jw1+jw2;
-iw = (1:n_ap*n_ap)';
-W = sparse(iw, jw, pupil_mask(:), n_ap*n_ap, n_comp*n_comp);
-%Wh = sparse(iw, jw, ones(n_ap*n_ap,1), n_ap*n_ap, n_comp*n_comp);
diff --git a/Generator/library/FFM/PhaseReconTools/.DS_Store b/Generator/library/FFM/PhaseReconTools/.DS_Store
deleted file mode 100755
index 5008ddf..0000000
Binary files a/Generator/library/FFM/PhaseReconTools/.DS_Store and /dev/null differ
diff --git a/Generator/library/FFM/PhaseReconTools/._.DS_Store b/Generator/library/FFM/PhaseReconTools/._.DS_Store
deleted file mode 100755
index 3c9792a..0000000
Binary files a/Generator/library/FFM/PhaseReconTools/._.DS_Store and /dev/null differ
diff --git a/Generator/library/FFM/PhaseReconTools/._ComputeGradx.m b/Generator/library/FFM/PhaseReconTools/._ComputeGradx.m
deleted file mode 100755
index 7d21b14..0000000
Binary files a/Generator/library/FFM/PhaseReconTools/._ComputeGradx.m and /dev/null differ
diff --git a/Generator/library/FFM/PhaseReconTools/._ComputeGrady.m b/Generator/library/FFM/PhaseReconTools/._ComputeGrady.m
deleted file mode 100755
index 7d21b14..0000000
Binary files a/Generator/library/FFM/PhaseReconTools/._ComputeGrady.m and /dev/null differ
diff --git a/Generator/library/FFM/PhaseReconTools/._GradxMatrix.m b/Generator/library/FFM/PhaseReconTools/._GradxMatrix.m
deleted file mode 100755
index cc5062a..0000000
Binary files a/Generator/library/FFM/PhaseReconTools/._GradxMatrix.m and /dev/null differ
diff --git a/Generator/library/FFM/PhaseReconTools/._GradyMatrix.m b/Generator/library/FFM/PhaseReconTools/._GradyMatrix.m
deleted file mode 100755
index cc5062a..0000000
Binary files a/Generator/library/FFM/PhaseReconTools/._GradyMatrix.m and /dev/null differ
diff --git a/Generator/library/FFM/PhaseReconTools/._MakeMask.m b/Generator/library/FFM/PhaseReconTools/._MakeMask.m
deleted file mode 100755
index 696751e..0000000
Binary files a/Generator/library/FFM/PhaseReconTools/._MakeMask.m and /dev/null differ
diff --git a/Generator/library/FFM/PhaseReconTools/._MosaicPadding.m b/Generator/library/FFM/PhaseReconTools/._MosaicPadding.m
deleted file mode 100755
index 7d21b14..0000000
Binary files a/Generator/library/FFM/PhaseReconTools/._MosaicPadding.m and /dev/null differ
diff --git a/Generator/library/FFM/PhaseReconTools/._PhaseTranspSolve.m b/Generator/library/FFM/PhaseReconTools/._PhaseTranspSolve.m
deleted file mode 100755
index 7d21b14..0000000
Binary files a/Generator/library/FFM/PhaseReconTools/._PhaseTranspSolve.m and /dev/null differ
diff --git a/Generator/library/FFM/PhaseReconTools/._PunchOutFrames.m b/Generator/library/FFM/PhaseReconTools/._PunchOutFrames.m
deleted file mode 100755
index d5fda60..0000000
Binary files a/Generator/library/FFM/PhaseReconTools/._PunchOutFrames.m and /dev/null differ
diff --git a/Generator/library/FFM/PhaseReconTools/._inpaintn.m b/Generator/library/FFM/PhaseReconTools/._inpaintn.m
deleted file mode 100755
index 7d21b14..0000000
Binary files a/Generator/library/FFM/PhaseReconTools/._inpaintn.m and /dev/null differ
diff --git a/Generator/library/FFM/PhaseReconTools/ComputeGradx.m b/Generator/library/FFM/PhaseReconTools/ComputeGradx.m
deleted file mode 100755
index 77ec226..0000000
--- a/Generator/library/FFM/PhaseReconTools/ComputeGradx.m
+++ /dev/null
@@ -1,47 +0,0 @@
-function phase_gradx = ComputeGradx(phase, pupil_mask)
-%
-%     phase_gradx = ComputeGradx(phase, pupil_mask);
-%
-%  This function can be used to compute gradients of a phase, assuming
-%  a Fried geometry of the WFS.
-%
-%  Input:
-%    phase      - array containing phases -- could be 3D
-%
-%  Optional Input:
-%    pupil_mask - array defining pupil mask -- could be 3D.
-%                     2D array ==> pupil mask is the same for each phase
-%                     3D array ==> size(pupil_mask) = size(phase)
-%                 If this is given, then the phase is padded outside
-%                 the pupil mask using an inpainting technique.
-%
-%  Output:
-%    phase_gradx - computed gradients
-%                  array same size as phase
-%
-%
-if nargin == 1
-  pupil_mask = [];
-end
-
-[m_ap, n_ap, n_frames] = size(phase);
-if m_ap ~= n_ap
-  error('Expected input frames to be square')
-end
-
-Dx = GradxMatrix(n_ap);
-
-if ~isempty(pupil_mask)
-  if size(pupil_mask,3) ~= size(phase,3)
-    pupil_mask = pupil_mask(:,:,ones(1,n_frames));
-  end
-  for k = 1:n_frames
-    phase(:,:,k) = MosaicPadding(phase(:,:,k), pupil_mask(:,:,k));
-  end
-end
-
-phase_gradx = zeros(size(phase));
-for k = 1:n_frames
-  phase_gradx(:,:,k) = pupil_mask(:,:,k).*reshape(Dx*reshape(phase(:,:,k),n_ap*n_ap,1),n_ap,n_ap);
-end
-
diff --git a/Generator/library/FFM/PhaseReconTools/ComputeGrady.m b/Generator/library/FFM/PhaseReconTools/ComputeGrady.m
deleted file mode 100755
index f6f35ee..0000000
--- a/Generator/library/FFM/PhaseReconTools/ComputeGrady.m
+++ /dev/null
@@ -1,47 +0,0 @@
-function phase_grady = ComputeGrady(phase, pupil_mask)
-%
-%     phase_grady = ComputeGrady(phase, pupil_mask);
-%
-%  This function can be used to compute gradients of a phase, assuming
-%  a Fried geometry of the WFS.
-%
-%  Input:
-%    phase      - array containing phases -- could be 3D
-%
-%  Optional Input:
-%    pupil_mask - array defining pupil mask -- could be 3D.
-%                     2D array ==> pupil mask is the same for each phase
-%                     3D array ==> size(pupil_mask) = size(phase)
-%                 If this is given, then the phase is padded outside
-%                 the pupil mask using an inpainting technique.
-%
-%  Output:
-%    phase_gradx - computed gradients
-%                  array same size as phase
-%
-%
-if nargin == 1
-  pupil_mask = [];
-end
-
-[m_ap, n_ap, n_frames] = size(phase);
-if m_ap ~= n_ap
-  error('Expected input frames to be square')
-end
-
-Dy = GradyMatrix(n_ap);
-
-if ~isempty(pupil_mask)
-  if size(pupil_mask,3) ~= size(phase,3)
-    pupil_mask = pupil_mask(:,:,ones(1,n_frames));
-  end
-  for k = 1:n_frames
-    phase(:,:,k) = MosaicPadding(phase(:,:,k), pupil_mask(:,:,k));
-  end
-end
-
-phase_grady = zeros(size(phase));
-for k = 1:n_frames
-  phase_grady(:,:,k) = pupil_mask(:,:,k).*reshape(Dy*reshape(phase(:,:,k),n_ap*n_ap,1),n_ap,n_ap);
-end
-
diff --git a/Generator/library/FFM/PhaseReconTools/GradxMatrix.m b/Generator/library/FFM/PhaseReconTools/GradxMatrix.m
deleted file mode 100755
index 7a192ba..0000000
--- a/Generator/library/FFM/PhaseReconTools/GradxMatrix.m
+++ /dev/null
@@ -1,43 +0,0 @@
-function Dx = GradxMatrix(n, scale)
-%
-%  Dx = GradxMatrix(n, scale);
-%
-% Generates a sparse matrix that models computation of x-gradients
-% obtained by a wavefront sensor with Fried geometry.
-%
-% Important Remarks:
-%    1. The geometry is strange -- this computes what really seems like
-%       a y-gradient.  However, this code constructs a matrix that is
-%       consistent with what is found in the adaptive optics literature.
-%       See ...
-%    2. However, we do make one change with previously published papers:
-%       Our Dx is -1 times what is found in the above cited literature.  
-%    3. We are currently implementing this with a reflective boundary
-%       condition.
-%
-% Input:
-%   n  -    number of pixels across the image (assumed square)
-%
-% Optional Input:
-%   scale - allows for a normalization scale for specific geometries.
-%           Default is to use scale = 1;
-%
-% Output:
-%   Dx -    n^2 x n^2 sparse matrix
-%
-
-if nargin == 1
-  scale = [];
-end
-if isempty(scale)
-  scale = 1;
-end
-
-e = ones(n, 1);
-d1 = [e(1:n-1); 2];
-d2 = [e(1:n-1); 0];
-
-H = spdiags([-d2, e], 0:1, n, n);
-F = .5*spdiags([d1, e], 0:1, n, n);
-
-Dx = scale*kron(F, H);
diff --git a/Generator/library/FFM/PhaseReconTools/GradyMatrix.m b/Generator/library/FFM/PhaseReconTools/GradyMatrix.m
deleted file mode 100755
index 660e957..0000000
--- a/Generator/library/FFM/PhaseReconTools/GradyMatrix.m
+++ /dev/null
@@ -1,43 +0,0 @@
-function Dy = GradyMatrix(n, scale)
-%
-%  Dy = GradyMatrix(n, scale);
-%
-% Generates a sparse matrix that models computation of y-gradients
-% obtained by a wavefront sensor with Fried geometry.
-%
-% Important Remarks:
-%    1. The geometry is strange -- this computes what really seems like
-%       a x-gradient.  However, this code constructs a matrix that is
-%       consistent with what is found in the adaptive optics literature.
-%       See ...
-%    2. However, we do make one change with previously published papers:
-%       Our Dy is -1 times what is found in the above cited literature.  
-%    3. We are currently implementing this with a reflective boundary
-%       condition.
-%
-% Input:
-%   n  -    number of pixels across the image (assumed square)
-%
-% Optional Input:
-%   scale - allows for a normalization scale for specific geometries.
-%           Default is to use scale = 1;
-%
-% Output:
-%   Dy -    n^2 x n^2 sparse matrix
-%
-
-if nargin == 1
-  scale = [];
-end
-if isempty(scale)
-  scale = 1;
-end
-
-e = ones(n, 1);
-d1 = [e(1:n-1); 2];
-d2 = [e(1:n-1); 0];
-
-H = spdiags([-d2, e], 0:1, n, n);
-F = .5*spdiags([d1, e], 0:1, n, n);
-
-Dy = scale*kron(H, F);
diff --git a/Generator/library/FFM/PhaseReconTools/MakeMask.m b/Generator/library/FFM/PhaseReconTools/MakeMask.m
deleted file mode 100755
index 272941f..0000000
--- a/Generator/library/FFM/PhaseReconTools/MakeMask.m
+++ /dev/null
@@ -1,35 +0,0 @@
-function [mask] = MakeMask(n, r1, r0)
-%
-%  [mask] = MakeMask(n, r1, r0)
-%  [mask] = MakeMask(n, r1)
-%
-%  Constructs an n by n mask with outer radius r1.  If only two input
-%  arguments are given, the mask is circular.  Otherwise, it is annular
-%  with inner radius r0.  The largest circle contained in the n by n square
-%  has radius r1 = 1.
-%
-%  We assume n is an even integer. The central pixel has index
-%  (n+1)/2.
-%
-%  Inputs:
-%    n - size of mask to be constructed
-%    r1 - outer radius
-%    r0 - inner radius, if annular
-%
-%  Outputs:
-%    mask - array of 1s and 0s representing the mask
-%
-% Author: John Bardsley, Sarah Knepper
-% Date Created: 27 September 2009
-% Date Last Modified: 27 September 2009
-%
-
-h = 2/n;
-x = [-1:h:1-h]';
-onevec = ones(n,1);
-r = sqrt((x*onevec').^2 + (onevec*x').^2);
-if nargin == 2
-  mask = (r <= r1); 
-else
-  mask = (r0 <= r) & (r <= r1);
-end
diff --git a/Generator/library/FFM/PhaseReconTools/MosaicPadding.m b/Generator/library/FFM/PhaseReconTools/MosaicPadding.m
deleted file mode 100755
index 7dfebd6..0000000
--- a/Generator/library/FFM/PhaseReconTools/MosaicPadding.m
+++ /dev/null
@@ -1,25 +0,0 @@
-function image_frames = MosaicPadding(image_frames, pupil_mask)
-%
-%  When building the mosaic images from set of frames, there
-%  might be issues from boundary artifacts if the region of interest
-%  is not known throughout the whole domain.  In particular, it
-%  it is only known in a region defined by the pupil_mask.
-%  This function will use inpainting techniques to fill in the
-%  missing regions, and hopefully avoid the boundary artifacts
-%  when we use ReconMosaic.m
-%
-%  Note that if we are using this for a multi-layer FFH problem,
-%  we might build mosaics for each layer.  But we need only do
-%  this padding once.
-%
-
-[m, n, nframes] = size(image_frames);
-
-%h = waitbar(0,'Start padding ...');
-for k = 1:nframes
-  X = image_frames(:,:,k);
-  X(~pupil_mask) = NaN;
-  image_frames(:,:,k) = inpaintn(X);
-  %waitbar(k/nframes,h)
-end
-%close(h)
diff --git a/Generator/library/FFM/PhaseReconTools/PhaseTranspSolve.m b/Generator/library/FFM/PhaseReconTools/PhaseTranspSolve.m
deleted file mode 100755
index 1508325..0000000
--- a/Generator/library/FFM/PhaseReconTools/PhaseTranspSolve.m
+++ /dev/null
@@ -1,86 +0,0 @@
-function [phase_gradx, phase_grady] = PhaseTranspSolve(phase, pupil_mask, scale, alpha, method)
-%
-%    [phase_gradx, phase_grady] = ReconstructPhase_fast(phase, pupil_mask, alpha);
-%
-%  This function is needed in the MFBD codes.  In particular, we need
-%  to apply the transpose of the phase reconstructor to an array, which
-%  has dimensions the same as a phase on a single frame.
-%  We assume a Fried geometry of the wavefront sensor.
-%
-%  Input:
-%    phase       - array containing x-gradients of phases.  This can be
-%                  either a 2D or a 3D array.  In case of 3D, each 2D
-%                  slice, phase(:,:,k), can be a 
-%                  particular frame of data.
-%    pupil_mask  - pupil mask for phases.  If a 2D array, then it is
-%                  that each phase has the same pupil mask.
-%
-%  Optional Input:
-%    scale       - allows for a normalization scale for specific geometries.
-%                  Default is to use scale = 1;
-%    alpha       - Tikhonov regularization parameter. Default is
-%                  alpha = sqrt(eps).
-%    method      - character string, either 'direct' or 'lsqr'.
-%                  direct:    Tikhonov regularized least squares problems
-%                             are solved by MATLAB's backslash operator,  
-%                             exploiting sparse matrix tools.
-%                  iterative: Tikhonov regularized least squares problems
-%                             are solved using the iterative method LSQR.
-%                  Default is 'direct'.
-%
-%  Output:
-%    phase_gradx - an array in the phase x-gradient space.
-%    phase_grady - an array in the phase y-gradient space
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-%
-%  Check inputs and set default values.
-%
-narginchk(2, 5);
-switch nargin
-  case 2
-    scale = []; alpha = []; method = [];
-  case 3
-    alpha = []; method = [];
-  case 4
-    method = [];
-end
-
-if isempty(scale)
-  scale = 1;
-end
-if isempty(alpha)
-  alpha = sqrt(sqrt(eps));
-end
-if isempty(method)
-  method = 'direct';
-end
-alpha = scale*alpha;
-
-%
-%  This can help reduce some boundary artifacts ...
-%
-pad_size = 1;
-phase = padarray(phase, [pad_size, pad_size], 'both');
-pupil_mask = padarray(pupil_mask, [pad_size, pad_size], 'both');
-
-[m_ap, n_ap, n_frames] = size(phase);
-
-Dx = GradxMatrix(n_ap, scale);
-Dy = GradyMatrix(n_ap, scale);
-P = spdiags(reshape(pupil_mask,n_ap*n_ap,1), 0, n_ap*n_ap, n_ap*n_ap);
-A = Dx'*P'*P*Dx + Dy'*P'*P*Dy + alpha*alpha*speye(n_ap*n_ap);
-
-w = A\reshape(phase, n_ap*n_ap, n_frames);
-phase_gradx = reshape(P*Dx*w, n_ap, n_ap, n_frames);
-phase_grady = reshape(P*Dy*w, n_ap, n_ap, n_frames);
-
-phase_gradx = phase_gradx(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
-phase_grady = phase_grady(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
-
-
diff --git a/Generator/library/FFM/PhaseReconTools/PunchOutFrames.m b/Generator/library/FFM/PhaseReconTools/PunchOutFrames.m
deleted file mode 100755
index 4966686..0000000
--- a/Generator/library/FFM/PhaseReconTools/PunchOutFrames.m
+++ /dev/null
@@ -1,30 +0,0 @@
-function phase = PunchOutFrames(phaseC, A, W, n_frames, n_layers, n_comp, n_ap)
-%
-%  phase = PunchOutFrames(phaseC, A, W, n_frames, n_layers, n_comp, n_ap);
-%
-%  Input:
-%    phaseC   - composite information (could be phases or gradients)
-%               for each astmospheric layer
-%    A, W     - sparse matrices that model the FFM process of WFS data 
-%               collection.
-%    n_frames - number of frames of data
-%    n_layers - number of atmospheric layers
-%    n_comp   - size of composite grid
-%    n_ap     - size of aperture
-%
-%  Output
-%    phase    - punnched out versions of input on each frame
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-N = n_comp*n_comp;
-phaseC_vec = zeros(N*n_layers,1);
-for L = 1:n_layers
-  phaseC_vec((L-1)*N+1:L*N,1) = reshape(phaseC(:,:,L),n_comp*n_comp,1);
-end
-phase_vec = kron(speye(n_frames),W)*A*phaseC_vec;
-phase = reshape(phase_vec, n_ap, n_ap, n_frames);
\ No newline at end of file
diff --git a/Generator/library/FFM/PhaseReconTools/inpaintn.m b/Generator/library/FFM/PhaseReconTools/inpaintn.m
deleted file mode 100755
index 60cdf86..0000000
--- a/Generator/library/FFM/PhaseReconTools/inpaintn.m
+++ /dev/null
@@ -1,217 +0,0 @@
-function y = inpaintn(x,n,y0)
-
-% INPAINTN Inpaint over missing data in N-D array
-%   Y = INPAINTN(X) replaces the missing data in X by extra/interpolating
-%   the non-missing elements. The non finite values (NaN or Inf) in X are
-%   considered as missing data. X can be any N-D array.
-%
-%   INPAINTN (no input/output argument) runs the following 3-D example.
-%
-%   Important note:
-%   --------------
-%   INPAINTN uses an iterative process that converges toward the solution.
-%   Y = INPAINTN(X,N) uses N iterations. By default, N = 100. If you
-%   estimate that INPAINTN did not totally converge, increase N:
-%   Y = INPAINTN(X,1000);
-%
-%   Y = INPAINTN(X,N,Y0) uses Y0 as initial guess. This could be useful if
-%   you want to run the process a second time or if you have a GOOD guess
-%   of the final result. By default, INPAINTN makes a nearest neighbor
-%   interpolation (by using BWDIST) to obtain a rough guess.
-%
-%   Notes:
-%   -----
-%   <a href="matlab:web('http://www.mathworks.com/matlabcentral/fileexchange/4551')">INPAINT_NANS</a> and <a href="matlab:web('http://www.mathworks.com/matlabcentral/fileexchange/21214')">INPAINT_NANS3</a> are much faster than INPAINTN when
-%   the number of NaN elements is (relatively) small. However, because
-%   INPAINT_NANS and INPAINT_NANS3 both involve huge matrices, they can be
-%   limited with large datasets.
-%
-%   Examples
-%   --------
-%
-%     %% ---- Image ---- %%
-%     onion = imread('onion.png');
-%     I = randperm(numel(onion));
-%     onionNaN = double(onion); onionNaN(I(1:round(numel(I)*0.5))) = NaN;
-%     subplot(211), imshow(uint8(onionNaN)), title('Corrupted image - 50%')
-%     for k=1:3, onion(:,:,k) = inpaintn(onionNaN(:,:,k)); end
-%     subplot(212), imshow(uint8(onion)), title('Inpainted image')
-%
-%     %% ---- 3-D data ---- %%
-%     load wind
-%     xmin = min(x(:)); xmax = max(x(:));
-%     zmin = min(z(:)); ymax = max(y(:));
-%     %-- wind velocity
-%     vel0 = interp3(sqrt(u.^2+v.^2+w.^2),1,'cubic');
-%     x = interp3(x,1); y = interp3(y,1); z = interp3(z,1);
-%     %-- remove randomly 90% of the data
-%     I = randperm(numel(vel0));
-%     velNaN = vel0;
-%     velNaN(I(1:round(numel(I)*.9))) = NaN;
-%     %-- inpaint using INPAINTN
-%     vel = inpaintn(velNaN);
-%     %-- display the results
-%     subplot(221), imagesc(velNaN(:,:,15)), axis equal off
-%     title('Corrupt plane, z = 15')
-%     subplot(222), imagesc(vel(:,:,15)), axis equal off
-%     title('Reconstructed plane, z = 15')    
-%     subplot(223)
-%     hsurfaces = slice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);
-%     set(hsurfaces,'FaceColor','interp','EdgeColor','none')
-%     hcont = contourslice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);
-%     set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)
-%     view(3), daspect([2,2,1]), axis tight
-%     title('Original data compared with...')
-%     subplot(224)
-%     hsurfaces = slice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);
-%     set(hsurfaces,'FaceColor','interp','EdgeColor','none')
-%     hcont = contourslice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);
-%     set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)
-%     view(3), daspect([2,2,1]), axis tight
-%     title('... reconstructed data')
-%
-%     %% --- 4-D data --- %%
-%     [x1,x2,x3,x4] = ndgrid(-2:0.2:2);
-%     z0 = x2.*exp(-x1.^2-x2.^2-x3.^2-x4.^2);
-%     I = randperm(numel(z0));
-%     % remove 50% of the data
-%     zNaN = z0; zNaN(I(1:round(numel(I)*.5))) = NaN;
-%     % reconstruct the data using INPAINTN
-%     z = inpaintn(zNaN);
-%     % display the results (for x4 = 0)
-%     subplot(211)
-%     zNaN(isnan(zNaN)) = 0.5;
-%     slice(x2(:,:,:,1),x1(:,:,:,1),x3(:,:,:,1),zNaN(:,:,:,11),...
-%        [-1.2 0.8 2],2,[-2 0.2])
-%     title('Corrupt data, x4 = 0')
-%     subplot(212)
-%     slice(x2(:,:,:,1),x1(:,:,:,1),x3(:,:,:,1),z(:,:,:,11),...
-%        [-1.2 0.8 2],2,[-2 0.2])
-%     title('Reconstructed data')
-%
-%   See also GRIDDATAN, INPAINT_NANS, INPAINT_NANS3
-%
-%   -- Damien Garcia -- 2010/06
-%   website: <a
-%   href="matlab:web('http://www.biomecardio.com')">www.BiomeCardio.com</a>
-
-test4DCTNandIDCTN
-
-if nargin==0&&nargout==0, RunTheExample, return, end
-
-x = double(x);
-if nargin==1, n = 100; end
-
-sizx = size(x);
-d = ndims(x);
-Lambda = zeros(sizx);
-for i = 1:d
-    siz0 = ones(1,d);
-    siz0(i) = sizx(i);
-    Lambda = bsxfun(@plus,Lambda,...
-        cos(pi*(reshape(1:sizx(i),siz0)-1)/sizx(i)));
-end
-Lambda = -2*(d-Lambda);
-
-% Initial condition
-W = isfinite(x);
-if nargin==3
-    y = y0;
-    s0 = 0;
-else
-    if any(~W(:))
-        [y,s0] = InitialGuess(x,isfinite(x));
-    else
-        y = x;
-        return
-    end
-end
-x(~W) = 0;
-
-% Smoothness parameters: from high to negligible values
-s = logspace(s0,-3,n);
-
-RF = 2; % relaxation factor
-Lambda = Lambda.^2;
-
-%h = waitbar(0,'Inpainting...');
-for i = 1:n
-        Gamma = 1./(1+s(i)*Lambda);
-        y = RF*idct2(Gamma.*dct2(W.*(x-y)+y)) + (1-RF)*y;
-%        waitbar(i/n,h)
-end
-%close(h)
-
-y(W) = x(W);
-
-end
-
-%% Test for DCTN and IDCTN
-function test4DCTNandIDCTN
-    if ~exist('dct2','file')
-        error('MATLAB:smoothn:MissingFunction',...
-            ['DCTN and IDCTN are required. Download DCTN <a href="matlab:web(''',...
-            'http://www.biomecardio.com/matlab/dctn.html'')">here</a>.'])
-    elseif ~exist('idct2','file')
-        error('MATLAB:smoothn:MissingFunction',...
-            ['DCTN and IDCTN are required. Download IDCTN <a href="matlab:web(''',...
-            'http://www.biomecardio.com/matlab/idctn.html'')">here</a>.'])
-    end
-end
-
-%% Initial Guess
-function [z,s0] = InitialGuess(y,I)
-
-if license('test','image_toolbox')
-    %-- nearest neighbor interpolation
-    [z,L] = bwdist(I);
-    z = y;
-    z(~I) = y(L(~I));
-    s0 = 3;
-else
-    warning('MATLAB:inpaintn:InitialGuess',...
-        ['BWDIST (Image Processing Toolbox) does not exist. ',...
-        'The initial guess may not be optimal; additional',...
-        ' iterations can thus be required to ensure complete',...
-        ' convergence. Increase N value if necessary.'])
-    z = y;
-    z(~I) = mean(y(I));
-    s0 = 6;
-end
-
-end
-
-%% Example (3-D)
-function RunTheExample
-      load wind
-      xmin = min(x(:)); xmax = max(x(:));
-      zmin = min(z(:)); ymax = max(y(:));
-      %-- wind velocity
-      vel0 = interp3(sqrt(u.^2+v.^2+w.^2),1,'cubic');
-      x = interp3(x,1); y = interp3(y,1); z = interp3(z,1);
-      %-- remove randomly 90% of the data
-      I = randperm(numel(vel0));
-      velNaN = vel0;
-      velNaN(I(1:round(numel(I)*.9))) = NaN;
-      %-- inpaint using INPAINTN
-      vel = inpaintn(velNaN);
-      %-- display the results
-      subplot(221), imagesc(velNaN(:,:,15)), axis equal off
-      title('Corrupt plane, z = 15')
-      subplot(222), imagesc(vel(:,:,15)), axis equal off
-      title('Reconstructed plane, z = 15')    
-      subplot(223)
-      hsurfaces = slice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);
-      set(hsurfaces,'FaceColor','interp','EdgeColor','none')
-      hcont = contourslice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);
-      set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)
-      view(3), daspect([2,2,1]), axis tight
-      title('Original data compared with...')
-      subplot(224)
-      hsurfaces = slice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);
-      set(hsurfaces,'FaceColor','interp','EdgeColor','none')
-      hcont = contourslice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);
-      set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)
-      view(3), daspect([2,2,1]), axis tight
-      title('... reconstructed data')
-end
diff --git a/Generator/library/FFM/ReconstructGradient_Naive.m b/Generator/library/FFM/ReconstructGradient_Naive.m
deleted file mode 100755
index 393fd37..0000000
--- a/Generator/library/FFM/ReconstructGradient_Naive.m
+++ /dev/null
@@ -1,33 +0,0 @@
-function [phase_gradx, phase_grady] = ReconstructGradient_Naive(phase_gradx_meas, phase_grady_meas, n_ap, ssp)
-%
-%  [phase] = ReconstructGradient_Naive(phase_grad_measa);
-%    
-%  Use up-sampling interpolation to naively reconstruct phase gradients.
-%
-%  Input:
-%    phase_grad_meas  - 3D array containing measured (low resolution) 
-%                       x or y-gradients of phases, where (:,:,k) is the
-%                       k-th frame of data.
-%  Output:
-%    phase_gradx      - 3D array containing reconstructed (high resolution) 
-%                       x-gradients of phases where (:,:,k) is the 
-%                       k-th frame of data.
-%    phase_grady      - 3D array containing reconstructed (high resolution) 
-%                       y-gradients of phases where (:,:,k) is the 
-%                       k-th frame of data.
-%
-
-%
-%  J. Nagy
-%  January, 2014
-%
-
-nframes = size(phase_gradx_meas, 3);
-
-phase_gradx = zeros(n_ap, n_ap, nframes);
-phase_grady = zeros(n_ap, n_ap, nframes);
-for k = 1:nframes
-  phase_gradx(:,:,k) = imresize(phase_gradx_meas(:,:,k),ssp);
-  phase_grady(:,:,k) = imresize(phase_grady_meas(:,:,k),ssp);
-end
-
diff --git a/Generator/library/FFM/p_FFM.m b/Generator/library/FFM/p_FFM.m
deleted file mode 100755
index 3237edf..0000000
--- a/Generator/library/FFM/p_FFM.m
+++ /dev/null
@@ -1,214 +0,0 @@
-function [FFM_output, A, W, R] = p_FFM(FFM_input, FFM_options)
-%
-%  FFM_output = p_FFM(FFM_input, FFM_options);
-%
-%  This function is used to run the FFM stuff for DORA ...
-%
-%  The p is used to denote that this MATLAB code has been stripped of 
-%  any unnecessary computations to try to get it ready for the parallel
-%  implementation.
-%
-%  Here we reconstruct the composite gradients on each layer, but then
-%  we punch them out to get gradients on each frame.  Then we recosntruct
-%  the phase on each frame.
-%
-%  Input:
-%      FFM_input   - structure containing the following parameters:
-%
-%         Name         Type               Purpose
-%         -----------  ---------------    --------------------------------
-%         phase_gradx  3D double array    contains measured x-gradients of 
-%                                         wavefront phase on each frame 
-%                                         (low resolution)
-%         phase_grady  3D double array    contains measured y-gradients of 
-%                                         wavefront phase on each frame 
-%                                         (low resolution)
-%         wind_vecs    2D double array    specifies angle (theta) and 
-%                                         magnitude (r) of wind 
-%                                         velocity for each layer:
-%                                             wind_vecs(L,1) = r   
-%                                             wind_vecs(L,2) = theta 
-%                                         L = 1, 2, ..., n_layers.
-%         pupil_mask   2D logical array   pupil mask for aperture
-%         n_subap      Integer            number of pixels across the 
-%                                         subaperture
-%         n_ap         Integer            number of pixels across the 
-%                                         aperture
-%         ssp          Integer            subsampling parameter, which 
-%                                         should satisfy
-%                                              n_ap = ssp*n_subap
-%         n_frames     Integer            number of frames of data
-%         n_layers     Integer            number of atmospheric layers
-%
-%  Optional Input:
-%      FFM_options - structure containing the following parameters:
-%
-%         Name         Type               Purpose
-%         -----------  ---------------    --------------------------------
-%         phase_scale  Double             parameter used to scale the 
-%                                         derivative opertation when 
-%                                         reconstructing phase from the
-%                                         gradients.
-%                                         Default: 1 (i.e., no scaling)
-%         reg_par_FFM  Double             Tikhonov regularization parameter 
-%                                         for frozen flow model high res
-%                                         gradient reconstruction.
-%                                         Default: 1e-3
-%         reg_par_PR   Double             Tikhonov regularization parameter                              
-%                                         for phase reconstruction.
-%                                         Default: 1e-6
-%         rtol_FFM     Double             Relative residual stopping 
-%                                         tolerance for phase reconst.
-%                                         This is needed if method_FFM is
-%                                         lsqr.
-%                                         Default: 1e-6
-
-%
-%  Output:
-%      FFM_output - structure containing the following parameters:
-%
-%         Name         Type               Purpose
-%         -----------  ---------------    --------------------------------
-%         phaseC_gradx 3D double array    contains reconstructed composite 
-%                                         x-gradients of wavefront phase 
-%                                         on each frame (high resolution)
-%         phaseC_grady 3D double array    contains reconstructed composite 
-%                                         y-gradients of wavefront phase 
-%                                         on each frame (high resolution)
-%         A, W, R      Sparse matrices    See below -- these do the motion,
-%                                         windowing and subsampling
-%
-
-% Some remarks on notation:
-%   * In the codes, I will try to use:
-%       k - integer to denote a specific frame of data, k = 1:n_frames
-%       L - integer to denote a specific layer, L = 1:n_layers
-%       (i,j) - integers denoting a specific pixel in a frame or layer.
-%   * In the FFM gradient reconstruction codes, we use pixel shifts
-%     given by detlax and deltay.  We assume the information in wind_vecs
-%     pertains to the low resolution grid, and so
-%       deltax = r*ssp*cos(theta)
-%       deltay = r*ssp*sin(theta)
-%     where r = wind_vecs(L,1) and theta = wind_vecs(L,2).
-%     Note that
-%       deltax = number of pixels the atmosphere shifts to right/left
-%       deltay = number of pixels the atmosphere shifts up/down
-%     but this should be on the high resolution grid. So be careful here.
-%   * Generally we assume constant speed, but the FFM code does allow for
-%     non-constant speed.  Specifically:
-%             * Number of rows in deltax (and deltay) = n_layers
-%             * If there is only one colum, then it is 
-%               assumed that speed is constant.
-%             * For non-constant speed, deltax and deltay should
-%               have n_frames-1 columns, giving the number
-%               of pixels shifting in the x(y)-direction for
-%               each frame (the first frame is assumed
-%               fixed, so only need 2, 3, ..., n_frames)
-
-%
-%  J. Nagy
-%  October, 2013
-
-%
-%  These first statements just do a quick check to make sure enough
-%  input terms have been given; FFM_options is optional.
-%  Check options, and set default parameters.
-%
-% narginchk(1,2)
-if nargin == 1
-  % Use all defaults for options
-  phase_scale = [];
-  reg_par_FFM = [];
-  reg_par_PR = [];
-  rtol_FFM = [];
-else
-  if isfield(FFM_options, 'phase_scale')
-    phase_scale = FFM_options.phase_scale;
-  else
-    phase_scale = [];
-  end
-  if isfield(FFM_options, 'reg_par_FFM')
-    reg_par_FFM = FFM_options.reg_par_FFM;
-  else
-    reg_par_FFM = [];
-  end
-  if isfield(FFM_options, 'reg_par_PR')
-    reg_par_PR = FFM_options.reg_par_PR;
-  else
-    reg_par_PR = [];
-  end
-  if isfield(FFM_options, 'rtol_FFM')
-    rtol_FFM = FFM_options.rtol_FFM;
-  else
-    rtol_FFM = [];
-  end
-end
-if isempty(phase_scale), phase_scale = 1; end
-if isempty(reg_par_FFM), reg_par_FFM = 1e-3; end
-if isempty(reg_par_PR), reg_par_PR = 1e-6; end
-if isempty(rtol_FFM), rtol_FFM = 1e-6; end
-
-phase_gradx_meas = FFM_input.phase_gradx;
-phase_grady_meas = FFM_input.phase_grady;
-pupil_mask = FFM_input.pupil_mask;
-ssp = FFM_input.ssp;
-n_ap = FFM_input.n_ap;
-n_subap = FFM_input.n_subap;
-n_frames = FFM_input.n_frames;
-n_layers = FFM_input.n_layers;
-wind_vecs = FFM_input.wind_vecs;
-
-%
-%  Check to make sure the input variables have no obvious errors:
-%
-if n_ap ~= ssp*n_subap
-  error('input values should satisfy n_ap = ssp*n_subap')
-end
-if size(phase_gradx_meas) ~= size(phase_grady_meas)
-  error('input phase gradient arrays should be same size')
-end
-if n_layers ~= size(wind_vecs,1)
-  error('wind_vecs information does not match input number of layers')
-end
-if n_frames ~= size(phase_gradx_meas,3)
-  error('number of frames of input phase gradients does not match n_frames')
-end
-
-%
-%  Convert wind_vecs into pixel shif\t values:
-%
-deltax = ssp*wind_vecs(:,1) .* cos(wind_vecs(:,2));
-deltay = ssp*wind_vecs(:,1) .* sin(wind_vecs(:,2));
-%
-%  We need to find a composite grid size, and the amount of padding needed
-%  to get from n_ap to n_conmp.  
-%
-[n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay);
-
-%
-%  FFM Gradient Reconstruction
-%
-%     We first need the following matrices:
-%
-R = SubsampleMatrix(n_ap, ssp);
-W = WindowMatrix(n_ap, n_comp, pupil_mask, n_comp_pad+1, n_comp_pad+1);
-A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames);
-
-%
-%  Now reconstruct composite x-gradients of wavefront phase on each 
-%  atmospheric layer:
-%
-[phaseC_gradx, gradx_iters] = p_ReconstructGradient(A, W, R, ...
-  phase_gradx_meas, n_layers, n_comp, reg_par_FFM, rtol_FFM);
-
-%
-%  and then reconstruct composite y-gradients of wavefront phase on each
-%  atmospheric layer:
-%
-[phaseC_grady, grady_iters] = p_ReconstructGradient(A, W, R, ...
-  phase_grady_meas, n_layers, n_comp, reg_par_FFM, rtol_FFM);
-
-FFM_output.phaseC_gradx = phaseC_gradx;
-FFM_output.phaseC_grady = phaseC_grady;
-FFM_output.deltax = deltax;
-FFM_output.deltay = deltay;
\ No newline at end of file
diff --git a/Generator/library/FFM/p_ReconstructGradient.m b/Generator/library/FFM/p_ReconstructGradient.m
deleted file mode 100755
index 8e812d1..0000000
--- a/Generator/library/FFM/p_ReconstructGradient.m
+++ /dev/null
@@ -1,55 +0,0 @@
-function [phaseC_grad, iters] = p_ReconstructGradient(A, W, R, phase_grad_meas, n_layers, n_comp, alpha, rtol)
-%
-%  [phaseC_grad, iters] = ReconstructGradient(A, W, R, ...
-%         phase_grad_meas, n_layers, n_comp, alpha, method, rtol);
-%    
-%  Use the frozen flow model (FFM) to reconstruct high resolution 
-%  gradients from low resolution measurements. 
-%
-%  The p is used to denote that this MATLAB code has been stripped of 
-%  any unnecessary computations to try to get it ready for the parallel
-%  implementation.
-%
-%  Input:
-%    A, W, R          - sparse matrices that model the FFM process of
-%                       WFS data collection.
-%    phase_grad_meas  - 3D array containing measured (low resolution) 
-%                       x or y-gradients of phases, where (:,:,k) is the
-%                       k-th frame of data.
-%    n_layers         - number of atmospheric layers
-%    n_comp           - size of the composite grid
-%
-%    alpha            - Tikhonov regularization parameter. Default is
-%                       alpha = 1e-3.
-%    rtol             - residual stopping tolerance for LSQR.
-%                       Default is 1e-6.
-%
-%  Output:
-%    phaseC_grad      - 3D array containing reconstructed (high resolution) 
-%                       x or y-gradients of phases on composite grid, 
-%                       where (:,:,L) is the L-th atmospheric layer
-%
-%  Optional Output:
-%    iters            - number of LSQR iterations needed to find least
-%                       squares solution.
-%
-
-%
-%  J. Nagy
-%  October, 2013
-%
-
-alpha_scale = sqrt(max(A*ones(size(A,2),1))*max(A'*ones(size(A,1),1)));
-
-n_frames = size(phase_grad_meas, 3);
-MaxIter = 100*n_comp;
-alpha = alpha_scale*alpha;
-A = [kron(speye(n_frames),R*W)*A; alpha*speye(size(A,2))];
-b = [phase_grad_meas(:); zeros(size(A,2),1)];
-[phaseC_grad, flag, relres, iters, resvec] = lsqr(A, b, rtol, MaxIter);
-%
-%  Check this -- looks like we shouldn't need to reshape this into a
-%  3D array, because we are using it as a vector.
-%
-phaseC_grad = reshape(phaseC_grad, n_comp, n_comp, n_layers);
-
diff --git a/Generator/library/FFM/p_ReconstructPhase.m b/Generator/library/FFM/p_ReconstructPhase.m
deleted file mode 100755
index 17358d2..0000000
--- a/Generator/library/FFM/p_ReconstructPhase.m
+++ /dev/null
@@ -1,92 +0,0 @@
-function phase = p_ReconstructPhase(phase_gradx, phase_grady, pupil_mask, scale, alpha)
-%
-%    phase = p_ReconstructPhase(phase_gradx, phase_grady, pupil_mask, alpha);
-%
-%  This function reconstructs the phase from its gradient measurements.
-%  We assume a Fried geometry of the wavefront sensor.
-%
-%  The p is used to denote that this MATLAB code has been stripped of 
-%  any unnecessary computations to try to get it ready for the parallel
-%  implementation.
-%
-%  Input:
-%    phase_gradx - array containing x-gradients of phases.  This can be
-%                  either a 2D or a 3D array.  In case of 3D, each 2D
-%                  slice, phase_gradx(:,:,k), should be gradients for a 
-%                  particular frame of data.
-%    phase_grady - array containing y-gradients of phases.  This can be
-%                  either a 2D or a 3D array.  In case of 3D, each 2D
-%                  slice, phase_gradx(:,:,k), should be gradients for a 
-%                  particular frame of data.
-%    pupil_mask  - pupil mask for phases.  Must be a 2D array, so
-%                  that each phase has the same pupil mask.
-%
-%  Optional Input:
-%    scale       - allows for a normalization scale for specific geometries.
-%                  Default is to use scale = 1;
-%    alpha       - Tikhonov regularization parameter. Default is
-%                  alpha = 1e-6.
-%
-%  Output:
-%    phase       - reconstructed phases.
-%
-
-%
-%  J. Nagy
-%  November, 2013
-%
-
-%
-%  Check inputs and set default values.
-%
-switch nargin
-  case 3
-    scale = []; alpha = []; 
-  case 4
-    alpha = [];
-end
-
-if isempty(scale)
-  scale = 1;
-end
-if isempty(alpha)
-  %
-  %  Note that the default for this should be different in the C-code
-  %  because we are using a different method to solve the regularized
-  %  system.
-  %
-  alpha = 1e-6;
-end
-
-alpha = scale*alpha;
-
-%
-%  This can help reduce some boundary artifacts ...
-%
-pad_size = 1;
-phase_gradx = padarray(phase_gradx, [pad_size, pad_size], 'both');
-phase_grady = padarray(phase_grady, [pad_size, pad_size], 'both');
-pupil_mask  = padarray(pupil_mask, [pad_size, pad_size], 'both');
-
-%
-%  Get dimensions of padded versions ...
-%
-[m_ap, n_ap, n_frames] = size(phase_gradx);
-
-%
-%  Now set pu matrices and solve ...
-%
-Dx = GradxMatrix(n_ap, scale);
-Dy = GradyMatrix(n_ap, scale);
-
-P = spdiags(pupil_mask(:), 0, n_ap*n_ap, n_ap*n_ap);
-A = [P*Dx; P*Dy; alpha*speye(n_ap*n_ap)];
-b = [reshape(phase_gradx,n_ap*n_ap,n_frames); reshape(phase_grady,n_ap*n_ap, n_frames); zeros(n_ap*n_ap,n_frames)];
-phase_vecs = A\b;
-pupil_mask = pupil_mask(:,:,ones(1,n_frames));
-phase = pupil_mask .* reshape(phase_vecs, n_ap, n_ap, n_frames);
-
-%
-%  Extract phase from padded version ...
-%
-phase = phase(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
diff --git a/Generator/library/FFM_weights/.DS_Store b/Generator/library/FFM_weights/.DS_Store
deleted file mode 100755
index 8a4ef86..0000000
Binary files a/Generator/library/FFM_weights/.DS_Store and /dev/null differ
diff --git a/Generator/library/FFM_weights/._.DS_Store b/Generator/library/FFM_weights/._.DS_Store
deleted file mode 100755
index 09fa6bd..0000000
Binary files a/Generator/library/FFM_weights/._.DS_Store and /dev/null differ
diff --git a/Generator/library/FFM_weights/._GetCompositeMask_old.m b/Generator/library/FFM_weights/._GetCompositeMask_old.m
deleted file mode 100644
index 83bd810..0000000
Binary files a/Generator/library/FFM_weights/._GetCompositeMask_old.m and /dev/null differ
diff --git a/Generator/library/FFM_weights/._ReconstructPhase_Layers.m b/Generator/library/FFM_weights/._ReconstructPhase_Layers.m
deleted file mode 100644
index a258ab8..0000000
Binary files a/Generator/library/FFM_weights/._ReconstructPhase_Layers.m and /dev/null differ
diff --git a/Generator/library/FFM_weights/._ReconstructPhase_Layers_old.m b/Generator/library/FFM_weights/._ReconstructPhase_Layers_old.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/library/FFM_weights/._ReconstructPhase_Layers_old.m and /dev/null differ
diff --git a/Generator/library/FFM_weights/._TestProblem.m b/Generator/library/FFM_weights/._TestProblem.m
deleted file mode 100644
index a258ab8..0000000
Binary files a/Generator/library/FFM_weights/._TestProblem.m and /dev/null differ
diff --git a/Generator/library/FFM_weights/._p_ReconstructPhase.m b/Generator/library/FFM_weights/._p_ReconstructPhase.m
deleted file mode 100755
index 47ef751..0000000
Binary files a/Generator/library/FFM_weights/._p_ReconstructPhase.m and /dev/null differ
diff --git a/Generator/library/FFM_weights/GetCompositeMask_old.m b/Generator/library/FFM_weights/GetCompositeMask_old.m
deleted file mode 100644
index b2ef9ac..0000000
--- a/Generator/library/FFM_weights/GetCompositeMask_old.m
+++ /dev/null
@@ -1,57 +0,0 @@
-function pupil_maskC = GetCompositeMask(A, pupil_mask, n_comp, n_comp_pad, n_frames, n_layers)
-%
-%  pupil_maskC = GetCompositeMask(pupil_mask, wind_vecs, ssp, n_ap, ...
-%        n_comp, n_comp_pad, n_frames, n_layers);
-%
-%  This function comptues the mask of the composit grid.
-%
-%  Input:
-%    A           - matrix that defines the motion of the various layers
-%    pupil_mask  - pupil mask
-%    n_comp      - size of composite grid
-%    n_comp_pad  - size of padding to get from n_ap to n_comp
-%                  (see GetCompositeGridSize.m)
-%    n_frames    - number of frames of data
-%    n_layers    - number of atmospheric layers
-%
-%  Output:
-%    pupil_maskC - 3D logical array containing mask for composite
-%                  information (phases and gradients) on leach layer.
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%  Modified April, 2016 to reduce memory requirements.
-%
-
-%
-%    * Start with the pupil mask on the composite grid.
-%    * Move the pupil mask across the composite grid
-%    * BUT make sure that the pupil mask moves in the opposite 
-%      direction as the sky.  This done by adding pi to the
-%      angle of the wind vectors.
-%
-%if length(ssp) == 1
-%    ssp = [ssp, ssp];
-%end
-%deltax2 = ssp(2)*wind_vecs(:,1) .* cos(pi+wind_vecs(:,2));
-%deltay2 = ssp(1)*wind_vecs(:,1) .* sin(pi+wind_vecs(:,2));
-%A2 = MotionMatrix(deltax2, deltay2, n_comp, n_ap, n_frames);
-pupil_mask_pad = padarray(pupil_mask, [n_comp_pad,n_comp_pad],'both');
-N = n_comp*n_comp;
-v = kron(speye(n_layers),pupil_mask_pad(:));
-%v = full(A2*v);
-%
-%  Instead of creating a new matrix that does the motion in the opposite
-%  direction, let's move in the given direction, then rotate the result.
-%  This will avoid having to create another large matrix.
-%
-v = full(A*v);
-v = reshape(v, N, n_frames, n_layers);
-for k = 1:n_layers
-%   v(:,:,k) = transpose(rot90(transpose(v),2));
-   v(:,:,k) = transpose(rot90(transpose(v(:,:,k)),2));
-
-end
-pupil_maskC = reshape(squeeze(sum(v, 2) > 0),n_comp,n_comp,n_layers);
diff --git a/Generator/library/FFM_weights/GradientReconTools/AffineTransform.m b/Generator/library/FFM_weights/GradientReconTools/AffineTransform.m
deleted file mode 100755
index 0993e99..0000000
--- a/Generator/library/FFM_weights/GradientReconTools/AffineTransform.m
+++ /dev/null
@@ -1,146 +0,0 @@
-function T = AffineTransform(n_ap, n_frames, deltax, deltay)
-%
-%    T = AffineTransform(n_ap, n_frames, deltax, deltay);
-%
-%  This function generates affine tranformations from given motion data.
-%
-%  Input: 
-%   n_ap       - number of pixels across the aperture (diameter)
-%   n_frames   - number of frames
-%   deltax     - motion information of each of the layers; number of
-%                high resolution pixels shifting in x - direction.
-%   deltay     - motion information of each of the layers; number of
-%                high resolution pixels shifting in y - direction.
-%
-%  Output:
-%   T          - affine tranformations
-%
-
-%
-%  Remark: We could include rotation in this as well, but for now we
-%          only implement only shifts. If later we want to include
-%          rotations, then we will need to edit this code as follows:
-%          * include an additional input: delta_theta
-%          * uncomment the lines below that pertain to rotation
-%
-
-n_layers = size(deltax,1);
-
-if size(deltax,2) > 1
-  % The velocity is not constant, so this should be n_frames-1 in
-  % length
-  if size(deltax,2) ~= n_frames-1
-    error('incorrect deltax for nonconstant velocity')
-  end
-  deltax_vec = deltax;
-else
-  deltax_vec = deltax(:,ones(1,n_frames-1));
-end
-if size(deltay,2) > 1
-  % The velocity is not constant, so this should be n_frames-1 in
-  % length
-  if size(deltay,2) ~= n_frames-1
-    error('incorrect deltay for nonconstant velocity')
-  end
-  deltay_vec = deltay;
-else
-  deltay_vec = deltay(:,ones(1,n_frames-1));
-end
-%----------------------------------
-% ROTATION STATMENTS:
-%
-% If we edit this code to allow for rotation, uncomment the following:
-%
-%if size(delta_theta,2) > 1
-%  % The velocity is not constant, so this should be n_frames-1 in
-%  % length
-%  if size(delta_theta,2) ~= n_frames-1
-%    error('incorrect delta_theta for nonconstant velocity')
-%  end
-%  delta_theta_vec = delta_theta;
-%else
-%  delta_theta_vec = delta_theta(:,ones(1,n_frames-1));
-%end
-%
-%----------------------------------
-
-T = zeros(3, 3, n_frames, n_layers);
-
-for L = 1:n_layers
-  %
-  %  The first frame is the reference frame, so the affine transformation
-  %  should be the identity.
-  %
-  T(:,:,1,L) = eye(3);
-  
-  for k = 2:n_frames
-    dx = sum(deltax_vec(L,1:k-1)); % the shifting = integral of velocity * delta_time
-    dy = sum(deltay_vec(L,1:k-1));
-    %----------------------------------
-    % ROTATION CODES: If we want to use rotations, uncomment this line:
-    %
-    % theta = sum(delta_theta_vec(L,1:k-1));
-    %
-    %----------------------------------
-        
-    %
-    % Get spatial coordinates of center points of pixels:
-    %   Note: If we assume the image is defined on a standard Euclidean
-    %         coordinate system:
-    %
-    %              y ^
-    %                |
-    %                |
-    %                |-------->
-    %                         x
-    %
-    %          then an affine
-        
-    %
-    % Now shift the coordinate system:
-    % Create affine transformation to do the shifting of coordinates:
-    % Note: According to our coordinate system, dx > 0 means move right,
-    %       and dy > 0 means moves up.
-    %
-    % The affine transformation for this is:
-    %
-    T_shift = [1 0 0; 0 1 0; -dx -dy 1];
-
-    %----------------------------------
-    % ROTATION CODES: If we want to include rotation, uncomment these lines
-    %
-    % % Now consider a rotation about the center of the image.
-    % %  Rotation is clockwise by an angle theta.
-    % %  and that the center of rotation is the point ((n+1)/2, (m+1)/2)
-    % %  where the image is m-by-n pixels.
-    % %
-    % %  Note that standard rotation is about (0,0).  So we first need
-    % %  to shift the center of the image to the coordinate (0,0), then
-    % %  rotate, then shift back.
-    % %
-    % %  Shfit to (0,0):
-    % %
-    % SL = [1 0 0;0 1 0;-(n-1)/2 -(n_ap-1)/2 1];
-    % %  Rotate by angle theta.
-    % TR = [cos(theta), sin(theta), 0;-sin(theta), cos(theta), 0; 0, 0, 1];
-    % %  Now shift back.
-    % SR = [1 0 0;0 1 0; (n-1)/2,  (m-1)/2, 1];
-    % % The combined transformation is:
-    % T_rot_center = SL*TR*SR;
-    %
-    %----------------------------------
-    %
-    % ROTATION CODES: If we want to includ rotation, comment out this
-    %                 next line:
-    %
-    T_rot_center = eye(3);
-    %
-    %----------------------------------
-    %
-    %  Finally, the combined tranformation that shifts and rotates about
-    %  center is:
-    %
-    T(:,:,k,L) = T_shift * T_rot_center;
-    %   
-  end
-end
diff --git a/Generator/library/FFM_weights/GradientReconTools/BuildInterpMatrix.m b/Generator/library/FFM_weights/GradientReconTools/BuildInterpMatrix.m
deleted file mode 100755
index ba2111a..0000000
--- a/Generator/library/FFM_weights/GradientReconTools/BuildInterpMatrix.m
+++ /dev/null
@@ -1,77 +0,0 @@
-function S = BuildInterpMatrix(I, J, m, n)
-%
-%  Given pixel coordinates, (I,J) = (row, col), which
-%  are not necessarily integers, this function computes
-%  an interpolation matrix S so that y = S*x interpolates
-%  pixel values in the image x to give pixel values in
-%  the image y.
-%
-%  Here we use linear interpolation.
-%
-%  Input:
-%    I and J are arrays of size m-by-n (same as image dimensions).
-%       These contain coordinates of an image transformation.
-%    m, n is the size of the image.
-%
-%  Output:
-%    S is a sparse matrix
-%
-
-% First find integer coordinates that surround each
-% (I(i,j),J(i,j))
-% These will be the bilinear interpolation coordinates.
-%
-i0 = floor(I(:));
-i1 = ceil(I(:));
-j0 = floor(J(:));
-j1 = ceil(J(:));
-
-i1 = i0+1;
-j1 = j0+1;
-
-%
-% To avoid playing games with indices, we are very sloppy
-% around the border.  Interpolation is only done if ALL of the
-% points that surround (I(i,j),J(i,j)) are within the image
-% boarders.  This makes it easier to compute the interpolation
-% weights without having to use special conditions near
-% the borders.  If we assume black areas near the border,
-% then this should not cause any problems.
-%
-% The first step, then, is to find the rows that will contain
-% weights.
-%
-row_idx = find(1<=i0 & i1<=m & 1<=j0 & j1<=n);
-i = [row_idx; row_idx; row_idx; row_idx];
-
-% Since we only consider interior pixel values, then each
-% row will have exactly four weights.  So next we find the
-% four column indices where these weights should be put.
-% We are assuming column ordering of the image.
-%
-i0 = i0(row_idx);, i1 = i1(row_idx);, j0 = j0(row_idx);, j1 = j1(row_idx);
-
-col_idx1 = i0 + m*(j0-1);
-col_idx2 = i1 + m*(j0-1);
-col_idx3 = i0 + m*(j1-1);
-col_idx4 = i1 + m*(j1-1);
-j = [col_idx1; col_idx2; col_idx3; col_idx4];
-
-%
-% Now we compute the weights that go into the matrix.
-%
-deltai = I(row_idx) - i0;
-deltaj = J(row_idx) - j0;
-w1 = (1 - deltai).*(1 - deltaj);
-w2 = (1 - deltaj).*deltai;
-w3 = (1 - deltai).*deltaj;
-w4 = deltai.*deltaj;
-s = [w1; w2; w3; w4];
-
-
-%
-% Now let's put the weights in the sparse matrix.
-%
-S = sparse(i, j, s, m*n, m*n);
-
-
diff --git a/Generator/library/FFM_weights/GradientReconTools/GetCompositeGridSize.m b/Generator/library/FFM_weights/GradientReconTools/GetCompositeGridSize.m
deleted file mode 100755
index 6b38a8d..0000000
--- a/Generator/library/FFM_weights/GradientReconTools/GetCompositeGridSize.m
+++ /dev/null
@@ -1,30 +0,0 @@
-function [n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay)
-%
-%  [n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay);
-%  
-% This function computes the grid size needed to store the composite
-% high resolution gradients and phases.
-%
-% Input:
-%   n_ap       - number of pixels across the aperture (diameter)
-%   n_frames   - number of frames
-%   deltax     - motion information of each of the layers; number of
-%                high resolution pixels shifting in x - direction.
-%   deltay     - motion information of each of the layers; number of
-%                high resolution pixels shifting in y - direction.
-%
-% Output:
-%   n_comp     - composit grid size
-%   n_comp_pad - amount the aperture needs to be padded to get to the
-%                composite grid size
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-n_comp_pad = max( max( ceil( abs([deltax, deltay])*n_frames ) ) );
-n_comp = n_ap + 2*n_comp_pad;
-
-
diff --git a/Generator/library/FFM_weights/GradientReconTools/GetCompositeGridSizes.m b/Generator/library/FFM_weights/GradientReconTools/GetCompositeGridSizes.m
deleted file mode 100644
index 87e6a0d..0000000
--- a/Generator/library/FFM_weights/GradientReconTools/GetCompositeGridSizes.m
+++ /dev/null
@@ -1,58 +0,0 @@
-function [n_comp, n_comp_pad] = GetCompositeGridSizes(n_ap, n_WFS_frames, wind_vecs, ssp)
-%
-%  n_comp = GetCompositeGridSizes(n_ap, n_WFS_frames, wind_vecs);
-%  
-% This function computes the grid sizes needed to store the composite
-% high resolution gradients and phases for a set of FFM frames.
-%
-% Input:
-%   n_ap         - number of pixels across the aperture (diameter)
-%   n_WFS_frames - vector containing the number of frames used for each
-%                  FFM reconstruction
-%   wind_vecs    - 2D double array that specifies angle (theta) and 
-%                  magnitude (r) of wind velocity for each layer:
-%                      wind_vecs(L,1) = r   
-%                      wind_vecs(L,2) = theta 
-%                  L = 1, 2, ..., n_layers.
-%       ssp      - subsample parameter
-%                          Modified November, 2015, to allow non square 
-%                          subapertures. (J. Nagy) So now, ssp can
-%                          be a scalar (equal diameters in both directions)
-%                          or a 1-by-2 array, [ssp_rows, ssp_cols]
-%
-% Output:
-%   n_comp     - vector containing composite grid sizes
-%   n_comp_pad - amount the aperture needs to be padded to get to the
-%                composite grid sizes
-%
-
-%
-%  J. Nagy
-%  October, 2013
-%
-
-%
-%  Convert wind_vecs into pixel shif\t values:
-%
-%
-%  Modified November, 2015, to allow non square subapertures.
-%  J. Nagy
-%
-%
-%  Modified November, 2015, to allow non square subapertures.
-%  J. Nagy
-%
-if length(ssp) == 1
-    ssp = [ssp, ssp];
-end
-deltax = ssp(2)*wind_vecs(:,1) .* cos(wind_vecs(:,2));
-deltay = ssp(1)*wind_vecs(:,1) .* sin(wind_vecs(:,2));
-nframes = length(n_WFS_frames);
-n_comp = zeros(nframes,1);
-for k = 1:nframes
-  %
-  %  We need to find a composite grid size, and the amount of padding needed
-  %  to get from n_ap to n_conmp.  
-  %
-  [n_comp(k), n_comp_pad] = GetCompositeGridSize(n_ap, n_WFS_frames(k), deltax, deltay);
-end
\ No newline at end of file
diff --git a/Generator/library/FFM_weights/GradientReconTools/GetCompositeMask.m b/Generator/library/FFM_weights/GradientReconTools/GetCompositeMask.m
deleted file mode 100644
index b2ef9ac..0000000
--- a/Generator/library/FFM_weights/GradientReconTools/GetCompositeMask.m
+++ /dev/null
@@ -1,57 +0,0 @@
-function pupil_maskC = GetCompositeMask(A, pupil_mask, n_comp, n_comp_pad, n_frames, n_layers)
-%
-%  pupil_maskC = GetCompositeMask(pupil_mask, wind_vecs, ssp, n_ap, ...
-%        n_comp, n_comp_pad, n_frames, n_layers);
-%
-%  This function comptues the mask of the composit grid.
-%
-%  Input:
-%    A           - matrix that defines the motion of the various layers
-%    pupil_mask  - pupil mask
-%    n_comp      - size of composite grid
-%    n_comp_pad  - size of padding to get from n_ap to n_comp
-%                  (see GetCompositeGridSize.m)
-%    n_frames    - number of frames of data
-%    n_layers    - number of atmospheric layers
-%
-%  Output:
-%    pupil_maskC - 3D logical array containing mask for composite
-%                  information (phases and gradients) on leach layer.
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%  Modified April, 2016 to reduce memory requirements.
-%
-
-%
-%    * Start with the pupil mask on the composite grid.
-%    * Move the pupil mask across the composite grid
-%    * BUT make sure that the pupil mask moves in the opposite 
-%      direction as the sky.  This done by adding pi to the
-%      angle of the wind vectors.
-%
-%if length(ssp) == 1
-%    ssp = [ssp, ssp];
-%end
-%deltax2 = ssp(2)*wind_vecs(:,1) .* cos(pi+wind_vecs(:,2));
-%deltay2 = ssp(1)*wind_vecs(:,1) .* sin(pi+wind_vecs(:,2));
-%A2 = MotionMatrix(deltax2, deltay2, n_comp, n_ap, n_frames);
-pupil_mask_pad = padarray(pupil_mask, [n_comp_pad,n_comp_pad],'both');
-N = n_comp*n_comp;
-v = kron(speye(n_layers),pupil_mask_pad(:));
-%v = full(A2*v);
-%
-%  Instead of creating a new matrix that does the motion in the opposite
-%  direction, let's move in the given direction, then rotate the result.
-%  This will avoid having to create another large matrix.
-%
-v = full(A*v);
-v = reshape(v, N, n_frames, n_layers);
-for k = 1:n_layers
-%   v(:,:,k) = transpose(rot90(transpose(v),2));
-   v(:,:,k) = transpose(rot90(transpose(v(:,:,k)),2));
-
-end
-pupil_maskC = reshape(squeeze(sum(v, 2) > 0),n_comp,n_comp,n_layers);
diff --git a/Generator/library/FFM_weights/GradientReconTools/GetPixelCenters2D.m b/Generator/library/FFM_weights/GradientReconTools/GetPixelCenters2D.m
deleted file mode 100755
index 959b55d..0000000
--- a/Generator/library/FFM_weights/GradientReconTools/GetPixelCenters2D.m
+++ /dev/null
@@ -1,23 +0,0 @@
-function [X, Y] = GetPixelCenters2D(m,n)
-%
-%           [X, Y] = GetPixelCenters(m,n);
-%
-%  Find the (x,y) coordinates of the centers of pixels of an image.
-%  NOTE:  Here it is assumed that the image boundaries are defined by the
-%         standard Euclidean coordinate system:
-%              y ^
-%                |
-%                |
-%                |-------->
-%                         x
-%         and the centers of the pixels are given at (x,y), where
-%         x = 0, 1, 2, ..., n-1, 
-%         y = 0, 1, 2, ..., m-1
-%
-%  Input:  m, n = dimension of the image
-%
-%  Output: X = x-coordinates of centers of the pixels
-%          Y = y-coordinates of centers of the pixels
-%
-
-[X, Y] = meshgrid(0:n-1, m-1:-1:0);
\ No newline at end of file
diff --git a/Generator/library/FFM_weights/GradientReconTools/MotionMatrix.m b/Generator/library/FFM_weights/GradientReconTools/MotionMatrix.m
deleted file mode 100755
index 3d78343..0000000
--- a/Generator/library/FFM_weights/GradientReconTools/MotionMatrix.m
+++ /dev/null
@@ -1,66 +0,0 @@
-function A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames)
-%
-%     A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames);
-%
-%  Use the motion information, as given by deltax and deltay,
-%  to create a sparse matrix that, when multiplied to the large 
-%  global wavefront (or gradient fields) will move them to get the
-%  wavefronts (or gradient fields) in the position corresponding to
-%  each frame.
-%
-%  Input:
-%   deltax     - motion information of each of the layers; number of
-%                high resolution pixels shifting in x - direction.
-%   deltay     - motion information of each of the layers; number of
-%                high resolution pixels shifting in y - direction.
-%   n_comp     - composit grid size
-%   n_ap       - number of pixels across the aperture (diameter)
-%   n_frames   - number of frames
-%
-%  Output:
-%   A          - sparse matrix
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-n_layers = size(deltax,1);
-
-%
-%  Get affine transformations for the motion:
-%
-T = AffineTransform(n_ap, n_frames, deltax, deltay);
-
-A = [];
-for L = 1:n_layers 
-  %
-  % Get pixel centers of composite image.
-  %
-  [X, Y] = GetPixelCenters2D(n_comp, n_comp);
-
-  AA = [];
-  %h = waitbar(0, sprintf('Building motion matrices for layer %d', L));
-  for k = 1:n_frames
-    %
-    %  Use affine transfromation to transfrom coordinates:
-    %
-    [Xnew, Ynew] = TransformCoordinates2D(T(:,:,k,L), X, Y);
- 
-    %
-    %  Get MATLAB indices corresponding to these new coordinates:
-    %
-    [I, J] = SpaceToMidx2D(Xnew, Ynew);
-  
-    %
-    % Now build the sparse matrix that does the geometric
-    % transformation on the image.
-    %
-    S = BuildInterpMatrix(I, J, n_comp, n_comp);
-    AA = [AA; S];
-    
-    %waitbar(k/n_frames)
-  end
-  %close(h)
-  A = [A, AA];
-end
diff --git a/Generator/library/FFM_weights/GradientReconTools/ScaleXY.m b/Generator/library/FFM_weights/GradientReconTools/ScaleXY.m
deleted file mode 100755
index 01bb606..0000000
--- a/Generator/library/FFM_weights/GradientReconTools/ScaleXY.m
+++ /dev/null
@@ -1,33 +0,0 @@
-function [Xr, Yr] = ScaleXY(X, Y, s1, s2)
-%
-%              [Xr, Yr] = ScaleXY(X, Y, s1, s2);
-%
-%  Scale a given set of (x,y) points by values s1, s2.
-%  It is assumed that the points lie in the unit square [0,1]X[0,1]
-%
-%  Input:  X     = array containing x coordinates of original points
-%          Y     = array containing y coordinates of original points
-%          s1    = scaling of x-coordinates
-%          s2    = scaling of y-coordinates
-%
-%  Output: Xr = array containing scaled x coordinates
-%          Yr = array containing scaled y coordinates
-%
-
-%
-%  Create affine transformation to do the rotation of coordinates:
-%
-T = [s1, 0, 0;0, s2, 0; 0, 0, 1];
-
-%
-%  Note that we need to shift the center from (0.5,0.5) to (0,0)
-%  before scaling, then shift back.
-%
-SL = [1 0 0;0 1 0; -0.5,  -0.5, 1];
-SR = [1 0 0;0 1 0; 0.5,  0.5, 1];
-
-Z = (([X(:), Y(:), ones(length(X(:)), 1)] * SL) * T ) * SR;
-
-Xr = reshape(Z(:,1), size(X));
-Yr = reshape(Z(:,2), size(Y));
-
diff --git a/Generator/library/FFM_weights/GradientReconTools/SpaceToMidx2D.m b/Generator/library/FFM_weights/GradientReconTools/SpaceToMidx2D.m
deleted file mode 100755
index 94a4f18..0000000
--- a/Generator/library/FFM_weights/GradientReconTools/SpaceToMidx2D.m
+++ /dev/null
@@ -1,20 +0,0 @@
-function [I, J] = SpaceToMidx2D(X, Y, m, n)
-%
-%  Convert the Euclidean spatial coordinates given by (X,Y) to
-%  MATLAB indices.  That is, assume the image array is situated
-%  on the Eucldean axes:
-%
-%              y ^
-%                |
-%                |
-%                |-------->
-%                         x
-%
-if nargin < 3
-  m = size(Y,1);
-  n = size(X,2);
-elseif nargin < 2
-  n = m;
-end
-I = m - Y;
-J = X + 1;
diff --git a/Generator/library/FFM_weights/GradientReconTools/SubsampleMatrix.m b/Generator/library/FFM_weights/GradientReconTools/SubsampleMatrix.m
deleted file mode 100644
index 7459075..0000000
--- a/Generator/library/FFM_weights/GradientReconTools/SubsampleMatrix.m
+++ /dev/null
@@ -1,195 +0,0 @@
-function R = SubsampleMatrix(n, ssp, sinc_reg)
-%
-%   R = SubsampleMatrix(n, ssp);
-%   
-% This function constructs a sparse matrix that implements subsampling
-% on an image vector. 
-%
-% Input:
-%   n   - dimension of high resolution grid (that is
-%         the high resolution grid is n-by-n pixels)
-%         If n is a scalar, it is assumed the high res image is n-by-n
-%         If n is a 1-by-2 vector, then it is assumed that the high res
-%         image is n(1)-by-n(2)
-%   ssp - subsampling parameter
-%         If ssp is a scalar, then it is assumed that the subsampling
-%         is the same in both x and y directions.
-%         If ssp is a 1-by-2 vector, then it is assumed that
-%          ssp(1) = subsampling in y-direction (down rows of image)
-%          ssp(2) = subsampling in x-direction (across cols of image)
-%
-% Output: 
-%   R   - sparse matrix 
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-%  Modified November, 2015 by J. Nagy
-%  This now allows non-integer ssp, and the ssp can be different in
-%  the x and y directions.
-%
-
-%
-%
-
-if nargin == 2
-    sinc_reg = 0.2;
-end
-if length(n) == 1
-    nrows = n; ncols = n;
-else
-    nrows = n(1); ncols = n(2);
-end
-if length(ssp) == 1
-    ssp_row = ssp; ssp_col = ssp;
-else
-    ssp_row = ssp(1); ssp_col = ssp(2);
-end
-
-nrows_low = round(nrows/ssp_row); % should be an integer, but round just to be sure
-ncols_low = round(ncols/ssp_col); % should be an integer, but round just to be sure
-
-%
-%  We create a matrices that will do the subsampling of the high res image
-%  to obtain the low res images.  
-%  First we create the subsampling in the y-direction (subsampling of rows)
-%
-Drow = sparse(nrows_low, nrows);
-idx = round(linspace(1, nrows, nrows_low));
-Drow(:,idx) = speye(nrows_low);
-%
-% The below commented out code is another way to do the subsampling.
-%
-%mid = round(nrows/2);
-%idx1 = round(linspace(1,mid,fix(nrows_low/2)));
-%h = min(diff(idx1));
-%idx2 = round(linspace(idx1(end)+h,nrows,round(nrows_low/2)));
-%Drow(:,[idx1,idx2]) = speye(nrows_low);
-
-%
-%  Now create the subsampling in the x-direction (subsampling of cols)
-%
-Dcol = sparse(ncols_low, ncols);
-idx = round(linspace(1, ncols, ncols_low));
-Dcol(:,idx) = speye(ncols_low);
-%
-% The below commented out code is another way to do the subsampling.
-%
-%mid = round(ncols/2);
-%idx1 = round(linspace(1,mid,fix(ncols_low/2)));
-%h = min(diff(idx1));
-%idx2 = round(linspace(idx1(end)+h,ncols,round(ncols_low/2)));
-%Dcol(:,[idx1,idx2]) = speye(ncols_low);
- 
-%
-%  Before subsampling the high res image, we first apply a low-pass
-%  (smoothing) filter over the image.  The next two lines of code
-%  create windowed sinc filters.
-%
-% original is below
-% [hrow, ~] = SincKernel(nrows, nrows, 0.1, max(1/ssp_row,0.25));
-% [hcol, ~] = SincKernel(ncols, ncols, 0.1, max(1/ssp_col,0.25));
-
-% Changed by Doug to limit the amount of smoothing
-% on Apr 8 when working with SOR Ceiling fan data - used 5 for independent
-% phases
-% [hrow, ~] = SincKernel(nrows, nrows, 5, max(1/ssp_row,0.25));
-% [hcol, ~] = SincKernel(ncols, ncols, 5, max(1/ssp_col,0.25));
-
-%      [hrow, ~] = SincKernel(nrows, nrows, 1, max(1/ssp_row,0.25));
-%      [hcol, ~] = SincKernel(ncols, ncols, 1, max(1/ssp_col,0.25));
-% 
-
-%
-%  The SincKernel requires a couple of parameters that change the
-%  shape of the kernel.  I'm not sure precisely how these should be 
-%  chosen.  Below are some experiments I did, but it seems that
-%  the amount of filtering should depend on the subsampling.  If
-%  ssp = 1, the high res and low res images should be the same.
-%  
-[hrow, Hrow] = SincKernel(nrows, nrows, sinc_reg, max(1/ssp_row,0.25));
-[hcol, Hcol] = SincKernel(ncols, ncols, sinc_reg, max(1/ssp_col,0.25));
-%
-%[hrow, Hrow] = SincKernel(nrows, nrows, 0.1, 0.3);
-%[hcol, Hcol] = SincKernel(ncols, ncols, 0.1, 0.3);
-%
-%[hrow, Hrow] = SincKernel(nrows, nrows, 1, 2);
-%[hcol, Hcol] = SincKernel(ncols, ncols, 1, 2);
-%
-%  The second output of SincKernel implements the filtering with zero
-%  boundary conditions.  This seemed to cause slight artifacts on the 
-%  boundaries, so we now implement refelctive boundary conditions.
-%  The next lines of code do this:
-%
-crow = (length(hrow)+1)/2;
-ccol = (length(hcol)+1)/2;
-hrow = [hrow; zeros(nrows-length(hrow),1)];
-hcol = [hcol; zeros(nrows-length(hcol),1)];
-Arow = sparse(buildToep(hrow, crow) + buildHank(hrow, crow));
-Acol = sparse(buildToep(hcol, ccol) + buildHank(hcol, ccol));
-
-%
-%  Now that we have the filters and subsampling, we can create one big
-%  sparse matrix that performs the transformation from high res image to
-%  low res. (The commented out line uses zero boundary conditions.)
-%
-%R = kron(Dcol*Hcol,Drow*Hrow);
-R = kron(Dcol*Acol,Drow*Arow);
-
-%
-%--------------------------------------------------
-%  This version needs a few subfunctions.
-%
-function [h, H] = SincKernel(nrows, ncols, fc, b)
-%
-%  This constructs a windowed sinc filter.  This implementation is 
-%  modled after a python code at http://tomroelandts.com
-%  
-N = ceil(4 / b);
-if N/2 == fix(N/2)
-    N = N + 1;      
-end
-n = (0:N-1)';
-% Compute sinc filter.
-h = p_Sinc(2 * fc * (n - (N - 1) / 2));
-% Compute Blackman window.
-w = 0.42 - 0.5 * cos(2 * pi * n / (N - 1)) + 0.08 * cos(4 * pi * n / (N - 1));
-% Multiply sinc filter with window.
-h = h .* w;
-% Normalize to get unity gain.
-h = h / sum(h);
-B = repmat(h.', [min(nrows,ncols),1]);
-d = -(N-1)/2:(N-1)/2;
-H = spdiags(B, d, nrows, ncols);
-
-%
-%-------------------------------------------
-%
-function T = buildToep(c, k)
-%
-%  Build a banded Toeplitz matrix from a central column and an index
-%  denoting the central column.
-%
-n = length(c);
-col = zeros(n,1);
-row = col';
-col(1:n-k+1,1) = c(k:n);
-row(1,1:k) = c(k:-1:1)';
-T = toeplitz(col, row);
-
-%
-%-------------------------------------------
-%
-function H = buildHank(c, k)
-%
-%  Build a Hankel matrix for separable PSF and reflective boundary
-%  conditions.
-%
-n = length(c);
-col = zeros(n,1);
-col(1:n-k) = c(k+1:n);
-row = zeros(n,1);
-row(n-k+2:n) = c(1:k-1);
-H = hankel(col, row);
\ No newline at end of file
diff --git a/Generator/library/FFM_weights/GradientReconTools/TransformCoordinates2D.m b/Generator/library/FFM_weights/GradientReconTools/TransformCoordinates2D.m
deleted file mode 100755
index 143ce9a..0000000
--- a/Generator/library/FFM_weights/GradientReconTools/TransformCoordinates2D.m
+++ /dev/null
@@ -1,11 +0,0 @@
-function [Xnew, Ynew] = TransformCoordinates2D(T, X, Y)
-%
-%  Transform (x,y) coordinates given by X and Y using the
-%  affine transformation given by T.  That is,
-%     [xnew, ynew] = [x, y, 1]*T
-%
-
-W = [X(:), Y(:), ones(length(X(:)), 1)] * T;
-
-Xnew = reshape(W(:,1), size(X));
-Ynew = reshape(W(:,2), size(Y));
diff --git a/Generator/library/FFM_weights/GradientReconTools/WindowMatrix.m b/Generator/library/FFM_weights/GradientReconTools/WindowMatrix.m
deleted file mode 100755
index 186dd2c..0000000
--- a/Generator/library/FFM_weights/GradientReconTools/WindowMatrix.m
+++ /dev/null
@@ -1,32 +0,0 @@
-function W = WindowMatrix(n_ap, n_comp, pupil_mask, row_start, col_start)
-%
-%  W = WindowMatrix(n_ap, n_comp, pupil_mask, row_start, col_start);
-%
-%  This function constructs a sparse matrix that operates as a mask 
-%  to grab a certain region from an image array.
-%
-%  Input:
-%    n_ap       - size of high resolution image domain at telescope 
-%                       (e.g., 128-by-128)
-%    n_comp     - size of large (global, or composite) image
-%    pupil_mask - pupil mask of telescope
-%    row_start  -  These tell were the rectangular winow, which contains
-%    col_start  /  the pupil mask, should begin in the composite grid.
-%
-%  Output:
-%    W          - sparse matrix
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-jw1 = kron((0:n_ap-1)',n_comp*ones(n_ap,1));
-%jw2 = kron(ones(n_ap,1),(1:n_ap)');
-t1 = n_comp*(col_start-1)+row_start;
-jw2 = kron(ones(n_ap,1),(t1:t1+n_ap-1)');
-jw = jw1+jw2;
-iw = (1:n_ap*n_ap)';
-W = sparse(iw, jw, pupil_mask(:), n_ap*n_ap, n_comp*n_comp);
-%Wh = sparse(iw, jw, ones(n_ap*n_ap,1), n_ap*n_ap, n_comp*n_comp);
diff --git a/Generator/library/FFM_weights/PhaseReconTools/ComputeGradx.m b/Generator/library/FFM_weights/PhaseReconTools/ComputeGradx.m
deleted file mode 100755
index 77ec226..0000000
--- a/Generator/library/FFM_weights/PhaseReconTools/ComputeGradx.m
+++ /dev/null
@@ -1,47 +0,0 @@
-function phase_gradx = ComputeGradx(phase, pupil_mask)
-%
-%     phase_gradx = ComputeGradx(phase, pupil_mask);
-%
-%  This function can be used to compute gradients of a phase, assuming
-%  a Fried geometry of the WFS.
-%
-%  Input:
-%    phase      - array containing phases -- could be 3D
-%
-%  Optional Input:
-%    pupil_mask - array defining pupil mask -- could be 3D.
-%                     2D array ==> pupil mask is the same for each phase
-%                     3D array ==> size(pupil_mask) = size(phase)
-%                 If this is given, then the phase is padded outside
-%                 the pupil mask using an inpainting technique.
-%
-%  Output:
-%    phase_gradx - computed gradients
-%                  array same size as phase
-%
-%
-if nargin == 1
-  pupil_mask = [];
-end
-
-[m_ap, n_ap, n_frames] = size(phase);
-if m_ap ~= n_ap
-  error('Expected input frames to be square')
-end
-
-Dx = GradxMatrix(n_ap);
-
-if ~isempty(pupil_mask)
-  if size(pupil_mask,3) ~= size(phase,3)
-    pupil_mask = pupil_mask(:,:,ones(1,n_frames));
-  end
-  for k = 1:n_frames
-    phase(:,:,k) = MosaicPadding(phase(:,:,k), pupil_mask(:,:,k));
-  end
-end
-
-phase_gradx = zeros(size(phase));
-for k = 1:n_frames
-  phase_gradx(:,:,k) = pupil_mask(:,:,k).*reshape(Dx*reshape(phase(:,:,k),n_ap*n_ap,1),n_ap,n_ap);
-end
-
diff --git a/Generator/library/FFM_weights/PhaseReconTools/ComputeGrady.m b/Generator/library/FFM_weights/PhaseReconTools/ComputeGrady.m
deleted file mode 100755
index f6f35ee..0000000
--- a/Generator/library/FFM_weights/PhaseReconTools/ComputeGrady.m
+++ /dev/null
@@ -1,47 +0,0 @@
-function phase_grady = ComputeGrady(phase, pupil_mask)
-%
-%     phase_grady = ComputeGrady(phase, pupil_mask);
-%
-%  This function can be used to compute gradients of a phase, assuming
-%  a Fried geometry of the WFS.
-%
-%  Input:
-%    phase      - array containing phases -- could be 3D
-%
-%  Optional Input:
-%    pupil_mask - array defining pupil mask -- could be 3D.
-%                     2D array ==> pupil mask is the same for each phase
-%                     3D array ==> size(pupil_mask) = size(phase)
-%                 If this is given, then the phase is padded outside
-%                 the pupil mask using an inpainting technique.
-%
-%  Output:
-%    phase_gradx - computed gradients
-%                  array same size as phase
-%
-%
-if nargin == 1
-  pupil_mask = [];
-end
-
-[m_ap, n_ap, n_frames] = size(phase);
-if m_ap ~= n_ap
-  error('Expected input frames to be square')
-end
-
-Dy = GradyMatrix(n_ap);
-
-if ~isempty(pupil_mask)
-  if size(pupil_mask,3) ~= size(phase,3)
-    pupil_mask = pupil_mask(:,:,ones(1,n_frames));
-  end
-  for k = 1:n_frames
-    phase(:,:,k) = MosaicPadding(phase(:,:,k), pupil_mask(:,:,k));
-  end
-end
-
-phase_grady = zeros(size(phase));
-for k = 1:n_frames
-  phase_grady(:,:,k) = pupil_mask(:,:,k).*reshape(Dy*reshape(phase(:,:,k),n_ap*n_ap,1),n_ap,n_ap);
-end
-
diff --git a/Generator/library/FFM_weights/PhaseReconTools/GradxMatrix.m b/Generator/library/FFM_weights/PhaseReconTools/GradxMatrix.m
deleted file mode 100755
index 7a192ba..0000000
--- a/Generator/library/FFM_weights/PhaseReconTools/GradxMatrix.m
+++ /dev/null
@@ -1,43 +0,0 @@
-function Dx = GradxMatrix(n, scale)
-%
-%  Dx = GradxMatrix(n, scale);
-%
-% Generates a sparse matrix that models computation of x-gradients
-% obtained by a wavefront sensor with Fried geometry.
-%
-% Important Remarks:
-%    1. The geometry is strange -- this computes what really seems like
-%       a y-gradient.  However, this code constructs a matrix that is
-%       consistent with what is found in the adaptive optics literature.
-%       See ...
-%    2. However, we do make one change with previously published papers:
-%       Our Dx is -1 times what is found in the above cited literature.  
-%    3. We are currently implementing this with a reflective boundary
-%       condition.
-%
-% Input:
-%   n  -    number of pixels across the image (assumed square)
-%
-% Optional Input:
-%   scale - allows for a normalization scale for specific geometries.
-%           Default is to use scale = 1;
-%
-% Output:
-%   Dx -    n^2 x n^2 sparse matrix
-%
-
-if nargin == 1
-  scale = [];
-end
-if isempty(scale)
-  scale = 1;
-end
-
-e = ones(n, 1);
-d1 = [e(1:n-1); 2];
-d2 = [e(1:n-1); 0];
-
-H = spdiags([-d2, e], 0:1, n, n);
-F = .5*spdiags([d1, e], 0:1, n, n);
-
-Dx = scale*kron(F, H);
diff --git a/Generator/library/FFM_weights/PhaseReconTools/GradyMatrix.m b/Generator/library/FFM_weights/PhaseReconTools/GradyMatrix.m
deleted file mode 100755
index 660e957..0000000
--- a/Generator/library/FFM_weights/PhaseReconTools/GradyMatrix.m
+++ /dev/null
@@ -1,43 +0,0 @@
-function Dy = GradyMatrix(n, scale)
-%
-%  Dy = GradyMatrix(n, scale);
-%
-% Generates a sparse matrix that models computation of y-gradients
-% obtained by a wavefront sensor with Fried geometry.
-%
-% Important Remarks:
-%    1. The geometry is strange -- this computes what really seems like
-%       a x-gradient.  However, this code constructs a matrix that is
-%       consistent with what is found in the adaptive optics literature.
-%       See ...
-%    2. However, we do make one change with previously published papers:
-%       Our Dy is -1 times what is found in the above cited literature.  
-%    3. We are currently implementing this with a reflective boundary
-%       condition.
-%
-% Input:
-%   n  -    number of pixels across the image (assumed square)
-%
-% Optional Input:
-%   scale - allows for a normalization scale for specific geometries.
-%           Default is to use scale = 1;
-%
-% Output:
-%   Dy -    n^2 x n^2 sparse matrix
-%
-
-if nargin == 1
-  scale = [];
-end
-if isempty(scale)
-  scale = 1;
-end
-
-e = ones(n, 1);
-d1 = [e(1:n-1); 2];
-d2 = [e(1:n-1); 0];
-
-H = spdiags([-d2, e], 0:1, n, n);
-F = .5*spdiags([d1, e], 0:1, n, n);
-
-Dy = scale*kron(H, F);
diff --git a/Generator/library/FFM_weights/PhaseReconTools/MakeMask.m b/Generator/library/FFM_weights/PhaseReconTools/MakeMask.m
deleted file mode 100755
index 272941f..0000000
--- a/Generator/library/FFM_weights/PhaseReconTools/MakeMask.m
+++ /dev/null
@@ -1,35 +0,0 @@
-function [mask] = MakeMask(n, r1, r0)
-%
-%  [mask] = MakeMask(n, r1, r0)
-%  [mask] = MakeMask(n, r1)
-%
-%  Constructs an n by n mask with outer radius r1.  If only two input
-%  arguments are given, the mask is circular.  Otherwise, it is annular
-%  with inner radius r0.  The largest circle contained in the n by n square
-%  has radius r1 = 1.
-%
-%  We assume n is an even integer. The central pixel has index
-%  (n+1)/2.
-%
-%  Inputs:
-%    n - size of mask to be constructed
-%    r1 - outer radius
-%    r0 - inner radius, if annular
-%
-%  Outputs:
-%    mask - array of 1s and 0s representing the mask
-%
-% Author: John Bardsley, Sarah Knepper
-% Date Created: 27 September 2009
-% Date Last Modified: 27 September 2009
-%
-
-h = 2/n;
-x = [-1:h:1-h]';
-onevec = ones(n,1);
-r = sqrt((x*onevec').^2 + (onevec*x').^2);
-if nargin == 2
-  mask = (r <= r1); 
-else
-  mask = (r0 <= r) & (r <= r1);
-end
diff --git a/Generator/library/FFM_weights/PhaseReconTools/MosaicPadding.m b/Generator/library/FFM_weights/PhaseReconTools/MosaicPadding.m
deleted file mode 100755
index 7dfebd6..0000000
--- a/Generator/library/FFM_weights/PhaseReconTools/MosaicPadding.m
+++ /dev/null
@@ -1,25 +0,0 @@
-function image_frames = MosaicPadding(image_frames, pupil_mask)
-%
-%  When building the mosaic images from set of frames, there
-%  might be issues from boundary artifacts if the region of interest
-%  is not known throughout the whole domain.  In particular, it
-%  it is only known in a region defined by the pupil_mask.
-%  This function will use inpainting techniques to fill in the
-%  missing regions, and hopefully avoid the boundary artifacts
-%  when we use ReconMosaic.m
-%
-%  Note that if we are using this for a multi-layer FFH problem,
-%  we might build mosaics for each layer.  But we need only do
-%  this padding once.
-%
-
-[m, n, nframes] = size(image_frames);
-
-%h = waitbar(0,'Start padding ...');
-for k = 1:nframes
-  X = image_frames(:,:,k);
-  X(~pupil_mask) = NaN;
-  image_frames(:,:,k) = inpaintn(X);
-  %waitbar(k/nframes,h)
-end
-%close(h)
diff --git a/Generator/library/FFM_weights/PhaseReconTools/PhaseTranspSolve.m b/Generator/library/FFM_weights/PhaseReconTools/PhaseTranspSolve.m
deleted file mode 100755
index e408271..0000000
--- a/Generator/library/FFM_weights/PhaseReconTools/PhaseTranspSolve.m
+++ /dev/null
@@ -1,89 +0,0 @@
-function [phase_gradx, phase_grady] = PhaseTranspSolve(phase, pupil_mask, scale, alpha, method)
-%
-%    [phase_gradx, phase_grady] = ReconstructPhase_fast(phase, pupil_mask, alpha);
-%
-%  This function is needed in the MFBD codes.  In particular, we need
-%  to apply the transpose of the phase reconstructor to an array, which
-%  has dimensions the same as a phase on a single frame.
-%  We assume a Fried geometry of the wavefront sensor.
-%
-%  Input:
-%    phase       - array containing x-gradients of phases.  This can be
-%                  either a 2D or a 3D array.  In case of 3D, each 2D
-%                  slice, phase(:,:,k), can be a 
-%                  particular frame of data.
-%    pupil_mask  - pupil mask for phases.  If a 2D array, then it is
-%                  that each phase has the same pupil mask.
-%
-%  Optional Input:
-%    scale       - allows for a normalization scale for specific geometries.
-%                  Default is to use scale = 1;
-%    alpha       - Tikhonov regularization parameter. Default is
-%                  alpha = sqrt(eps).
-%    method      - character string, either 'direct' or 'lsqr'.
-%                  direct:    Tikhonov regularized least squares problems
-%                             are solved by MATLAB's backslash operator,  
-%                             exploiting sparse matrix tools.
-%                  iterative: Tikhonov regularized least squares problems
-%                             are solved using the iterative method LSQR.
-%                  Default is 'direct'.
-%
-%  Output:
-%    phase_gradx - an array in the phase x-gradient space.
-%    phase_grady - an array in the phase y-gradient space
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-%
-%  Check inputs and set default values.
-%
-narginchk(2, 5);
-switch nargin
-  case 2
-    scale = []; alpha = []; method = [];
-  case 3
-    alpha = []; method = [];
-  case 4
-    method = [];
-end
-
-if isempty(scale)
-  scale = 1;
-end
-if isempty(alpha)
-  alpha = sqrt(sqrt(eps));
-end
-if isempty(method)
-  method = 'direct';
-end
-alpha = scale*alpha;
-
-%
-%  This can help reduce some boundary artifacts ...
-%
-pad_size = 1;
-phase  = padarray(padarray(phase, [pad_size, pad_size], 'pre'),[pad_size pad_size],'post');
-pupil_mask  = padarray(padarray(pupil_mask, [pad_size, pad_size], 'pre'),[pad_size pad_size],'post');
-
-% phase = padarray(phase, [pad_size, pad_size], 'both');
-% pupil_mask = padarray(pupil_mask, [pad_size, pad_size], 'both');
-
-[m_ap, n_ap, n_frames] = size(phase);
-
-Dx = GradxMatrix(n_ap, scale);
-Dy = GradyMatrix(n_ap, scale);
-P = spdiags(reshape(pupil_mask,n_ap*n_ap,1), 0, n_ap*n_ap, n_ap*n_ap);
-A = Dx'*P'*P*Dx + Dy'*P'*P*Dy + alpha*alpha*speye(n_ap*n_ap);
-
-w = A\reshape(phase, n_ap*n_ap, n_frames);
-phase_gradx = reshape(P*Dx*w, n_ap, n_ap, n_frames);
-phase_grady = reshape(P*Dy*w, n_ap, n_ap, n_frames);
-
-phase_gradx = phase_gradx(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
-phase_grady = phase_grady(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
-
-
diff --git a/Generator/library/FFM_weights/PhaseReconTools/PhaseTranspSolve_fast.m b/Generator/library/FFM_weights/PhaseReconTools/PhaseTranspSolve_fast.m
deleted file mode 100755
index 5a5a362..0000000
--- a/Generator/library/FFM_weights/PhaseReconTools/PhaseTranspSolve_fast.m
+++ /dev/null
@@ -1,86 +0,0 @@
-function [phase_gradx, phase_grady] = PhaseTranspSolve_fast(phase, pupil_mask, scale, alpha, method)
-%
-%    [phase_gradx, phase_grady] = ReconstructPhase_fast(phase, pupil_mask, alpha);
-%
-%  This function is needed in the MFBD codes.  In particular, we need
-%  to apply the transpose of the phase reconstructor to an array, which
-%  has dimensions the same as a phase on a single frame.
-%  We assume a Fried geometry of the wavefront sensor.
-%
-%  Input:
-%    phase       - array containing x-gradients of phases.  This can be
-%                  either a 2D or a 3D array.  In case of 3D, each 2D
-%                  slice, phase(:,:,k), can be a 
-%                  particular frame of data.
-%    pupil_mask  - pupil mask for phases.  If a 2D array, then it is
-%                  that each phase has the same pupil mask.
-%
-%  Optional Input:
-%    scale       - allows for a normalization scale for specific geometries.
-%                  Default is to use scale = 1;
-%    alpha       - Tikhonov regularization parameter. Default is
-%                  alpha = sqrt(eps).
-%    method      - character string, either 'direct' or 'lsqr'.
-%                  direct:    Tikhonov regularized least squares problems
-%                             are solved by MATLAB's backslash operator,  
-%                             exploiting sparse matrix tools.
-%                  iterative: Tikhonov regularized least squares problems
-%                             are solved using the iterative method LSQR.
-%                  Default is 'direct'.
-%
-%  Output:
-%    phase_gradx - an array in the phase x-gradient space.
-%    phase_grady - an array in the phase y-gradient space
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-%
-%  Check inputs and set default values.
-%
-narginchk(2, 5);
-switch nargin
-  case 2
-    scale = []; alpha = []; method = [];
-  case 3
-    alpha = []; method = [];
-  case 4
-    method = [];
-end
-
-if isempty(scale)
-  scale = 1;
-end
-if isempty(alpha)
-  alpha = sqrt(sqrt(eps));
-end
-if isempty(method)
-  method = 'direct';
-end
-alpha = scale*alpha;
-
-%
-%  This can help reduce some boundary artifacts ...
-%
-pad_size = 1;
-phase = padarray(phase, [pad_size, pad_size], 'both');
-pupil_mask = padarray(pupil_mask, [pad_size, pad_size], 'both');
-
-[m_ap, n_ap, n_frames] = size(phase);
-
-Dx = GradxMatrix(n_ap, scale);
-Dy = GradyMatrix(n_ap, scale);
-P = spdiags(reshape(pupil_mask,n_ap*n_ap,1), 0, n_ap*n_ap, n_ap*n_ap);
-A = Dx'*P'*P*Dx + Dy'*P'*P*Dy + alpha*alpha*speye(n_ap*n_ap);
-
-w = A\reshape(phase, n_ap*n_ap, n_frames);
-phase_gradx = reshape(P*Dx*w, n_ap, n_ap, n_frames);
-phase_grady = reshape(P*Dy*w, n_ap, n_ap, n_frames);
-
-phase_gradx = phase_gradx(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
-phase_grady = phase_grady(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
-
-
diff --git a/Generator/library/FFM_weights/PhaseReconTools/PunchOutFrames.m b/Generator/library/FFM_weights/PhaseReconTools/PunchOutFrames.m
deleted file mode 100755
index 0a98a84..0000000
--- a/Generator/library/FFM_weights/PhaseReconTools/PunchOutFrames.m
+++ /dev/null
@@ -1,35 +0,0 @@
-function phase = PunchOutFrames(phaseC, A, W, n_frames, n_layers, n_comp, n_ap, WA)
-%
-%  phase = PunchOutFrames(phaseC, A, W, n_frames, n_layers, n_comp, n_ap);
-%
-%  Input:
-%    phaseC   - composite information (could be phases or gradients)
-%               for each astmospheric layer
-%    A, W     - sparse matrices that model the FFM process of WFS data 
-%               collection.
-%    n_frames - number of frames of data
-%    n_layers - number of atmospheric layers
-%    n_comp   - size of composite grid
-%    n_ap     - size of aperture
-%
-%  Output
-%    phase    - punnched out versions of input on each frame
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-% modified to precompute the matirx product AW - D.Hope 11/13/2017
-%
-N = n_comp*n_comp;
-phaseC_vec = zeros(N*n_layers,1);
-for L = 1:n_layers
-  phaseC_vec((L-1)*N+1:L*N,1) = reshape(phaseC(:,:,L),n_comp*n_comp,1);
-end
-if nargin == 7
-     phase_vec = kron(speye(n_frames),W)*A*phaseC_vec; 
-else
-    phase_vec = WA*phaseC_vec;
-end
-phase = reshape(phase_vec, n_ap, n_ap, n_frames);
\ No newline at end of file
diff --git a/Generator/library/FFM_weights/PhaseReconTools/inpaintn.m b/Generator/library/FFM_weights/PhaseReconTools/inpaintn.m
deleted file mode 100755
index 60cdf86..0000000
--- a/Generator/library/FFM_weights/PhaseReconTools/inpaintn.m
+++ /dev/null
@@ -1,217 +0,0 @@
-function y = inpaintn(x,n,y0)
-
-% INPAINTN Inpaint over missing data in N-D array
-%   Y = INPAINTN(X) replaces the missing data in X by extra/interpolating
-%   the non-missing elements. The non finite values (NaN or Inf) in X are
-%   considered as missing data. X can be any N-D array.
-%
-%   INPAINTN (no input/output argument) runs the following 3-D example.
-%
-%   Important note:
-%   --------------
-%   INPAINTN uses an iterative process that converges toward the solution.
-%   Y = INPAINTN(X,N) uses N iterations. By default, N = 100. If you
-%   estimate that INPAINTN did not totally converge, increase N:
-%   Y = INPAINTN(X,1000);
-%
-%   Y = INPAINTN(X,N,Y0) uses Y0 as initial guess. This could be useful if
-%   you want to run the process a second time or if you have a GOOD guess
-%   of the final result. By default, INPAINTN makes a nearest neighbor
-%   interpolation (by using BWDIST) to obtain a rough guess.
-%
-%   Notes:
-%   -----
-%   <a href="matlab:web('http://www.mathworks.com/matlabcentral/fileexchange/4551')">INPAINT_NANS</a> and <a href="matlab:web('http://www.mathworks.com/matlabcentral/fileexchange/21214')">INPAINT_NANS3</a> are much faster than INPAINTN when
-%   the number of NaN elements is (relatively) small. However, because
-%   INPAINT_NANS and INPAINT_NANS3 both involve huge matrices, they can be
-%   limited with large datasets.
-%
-%   Examples
-%   --------
-%
-%     %% ---- Image ---- %%
-%     onion = imread('onion.png');
-%     I = randperm(numel(onion));
-%     onionNaN = double(onion); onionNaN(I(1:round(numel(I)*0.5))) = NaN;
-%     subplot(211), imshow(uint8(onionNaN)), title('Corrupted image - 50%')
-%     for k=1:3, onion(:,:,k) = inpaintn(onionNaN(:,:,k)); end
-%     subplot(212), imshow(uint8(onion)), title('Inpainted image')
-%
-%     %% ---- 3-D data ---- %%
-%     load wind
-%     xmin = min(x(:)); xmax = max(x(:));
-%     zmin = min(z(:)); ymax = max(y(:));
-%     %-- wind velocity
-%     vel0 = interp3(sqrt(u.^2+v.^2+w.^2),1,'cubic');
-%     x = interp3(x,1); y = interp3(y,1); z = interp3(z,1);
-%     %-- remove randomly 90% of the data
-%     I = randperm(numel(vel0));
-%     velNaN = vel0;
-%     velNaN(I(1:round(numel(I)*.9))) = NaN;
-%     %-- inpaint using INPAINTN
-%     vel = inpaintn(velNaN);
-%     %-- display the results
-%     subplot(221), imagesc(velNaN(:,:,15)), axis equal off
-%     title('Corrupt plane, z = 15')
-%     subplot(222), imagesc(vel(:,:,15)), axis equal off
-%     title('Reconstructed plane, z = 15')    
-%     subplot(223)
-%     hsurfaces = slice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);
-%     set(hsurfaces,'FaceColor','interp','EdgeColor','none')
-%     hcont = contourslice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);
-%     set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)
-%     view(3), daspect([2,2,1]), axis tight
-%     title('Original data compared with...')
-%     subplot(224)
-%     hsurfaces = slice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);
-%     set(hsurfaces,'FaceColor','interp','EdgeColor','none')
-%     hcont = contourslice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);
-%     set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)
-%     view(3), daspect([2,2,1]), axis tight
-%     title('... reconstructed data')
-%
-%     %% --- 4-D data --- %%
-%     [x1,x2,x3,x4] = ndgrid(-2:0.2:2);
-%     z0 = x2.*exp(-x1.^2-x2.^2-x3.^2-x4.^2);
-%     I = randperm(numel(z0));
-%     % remove 50% of the data
-%     zNaN = z0; zNaN(I(1:round(numel(I)*.5))) = NaN;
-%     % reconstruct the data using INPAINTN
-%     z = inpaintn(zNaN);
-%     % display the results (for x4 = 0)
-%     subplot(211)
-%     zNaN(isnan(zNaN)) = 0.5;
-%     slice(x2(:,:,:,1),x1(:,:,:,1),x3(:,:,:,1),zNaN(:,:,:,11),...
-%        [-1.2 0.8 2],2,[-2 0.2])
-%     title('Corrupt data, x4 = 0')
-%     subplot(212)
-%     slice(x2(:,:,:,1),x1(:,:,:,1),x3(:,:,:,1),z(:,:,:,11),...
-%        [-1.2 0.8 2],2,[-2 0.2])
-%     title('Reconstructed data')
-%
-%   See also GRIDDATAN, INPAINT_NANS, INPAINT_NANS3
-%
-%   -- Damien Garcia -- 2010/06
-%   website: <a
-%   href="matlab:web('http://www.biomecardio.com')">www.BiomeCardio.com</a>
-
-test4DCTNandIDCTN
-
-if nargin==0&&nargout==0, RunTheExample, return, end
-
-x = double(x);
-if nargin==1, n = 100; end
-
-sizx = size(x);
-d = ndims(x);
-Lambda = zeros(sizx);
-for i = 1:d
-    siz0 = ones(1,d);
-    siz0(i) = sizx(i);
-    Lambda = bsxfun(@plus,Lambda,...
-        cos(pi*(reshape(1:sizx(i),siz0)-1)/sizx(i)));
-end
-Lambda = -2*(d-Lambda);
-
-% Initial condition
-W = isfinite(x);
-if nargin==3
-    y = y0;
-    s0 = 0;
-else
-    if any(~W(:))
-        [y,s0] = InitialGuess(x,isfinite(x));
-    else
-        y = x;
-        return
-    end
-end
-x(~W) = 0;
-
-% Smoothness parameters: from high to negligible values
-s = logspace(s0,-3,n);
-
-RF = 2; % relaxation factor
-Lambda = Lambda.^2;
-
-%h = waitbar(0,'Inpainting...');
-for i = 1:n
-        Gamma = 1./(1+s(i)*Lambda);
-        y = RF*idct2(Gamma.*dct2(W.*(x-y)+y)) + (1-RF)*y;
-%        waitbar(i/n,h)
-end
-%close(h)
-
-y(W) = x(W);
-
-end
-
-%% Test for DCTN and IDCTN
-function test4DCTNandIDCTN
-    if ~exist('dct2','file')
-        error('MATLAB:smoothn:MissingFunction',...
-            ['DCTN and IDCTN are required. Download DCTN <a href="matlab:web(''',...
-            'http://www.biomecardio.com/matlab/dctn.html'')">here</a>.'])
-    elseif ~exist('idct2','file')
-        error('MATLAB:smoothn:MissingFunction',...
-            ['DCTN and IDCTN are required. Download IDCTN <a href="matlab:web(''',...
-            'http://www.biomecardio.com/matlab/idctn.html'')">here</a>.'])
-    end
-end
-
-%% Initial Guess
-function [z,s0] = InitialGuess(y,I)
-
-if license('test','image_toolbox')
-    %-- nearest neighbor interpolation
-    [z,L] = bwdist(I);
-    z = y;
-    z(~I) = y(L(~I));
-    s0 = 3;
-else
-    warning('MATLAB:inpaintn:InitialGuess',...
-        ['BWDIST (Image Processing Toolbox) does not exist. ',...
-        'The initial guess may not be optimal; additional',...
-        ' iterations can thus be required to ensure complete',...
-        ' convergence. Increase N value if necessary.'])
-    z = y;
-    z(~I) = mean(y(I));
-    s0 = 6;
-end
-
-end
-
-%% Example (3-D)
-function RunTheExample
-      load wind
-      xmin = min(x(:)); xmax = max(x(:));
-      zmin = min(z(:)); ymax = max(y(:));
-      %-- wind velocity
-      vel0 = interp3(sqrt(u.^2+v.^2+w.^2),1,'cubic');
-      x = interp3(x,1); y = interp3(y,1); z = interp3(z,1);
-      %-- remove randomly 90% of the data
-      I = randperm(numel(vel0));
-      velNaN = vel0;
-      velNaN(I(1:round(numel(I)*.9))) = NaN;
-      %-- inpaint using INPAINTN
-      vel = inpaintn(velNaN);
-      %-- display the results
-      subplot(221), imagesc(velNaN(:,:,15)), axis equal off
-      title('Corrupt plane, z = 15')
-      subplot(222), imagesc(vel(:,:,15)), axis equal off
-      title('Reconstructed plane, z = 15')    
-      subplot(223)
-      hsurfaces = slice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);
-      set(hsurfaces,'FaceColor','interp','EdgeColor','none')
-      hcont = contourslice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);
-      set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)
-      view(3), daspect([2,2,1]), axis tight
-      title('Original data compared with...')
-      subplot(224)
-      hsurfaces = slice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);
-      set(hsurfaces,'FaceColor','interp','EdgeColor','none')
-      hcont = contourslice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);
-      set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)
-      view(3), daspect([2,2,1]), axis tight
-      title('... reconstructed data')
-end
diff --git a/Generator/library/FFM_weights/ReconstructGradient_Naive.m b/Generator/library/FFM_weights/ReconstructGradient_Naive.m
deleted file mode 100755
index 393fd37..0000000
--- a/Generator/library/FFM_weights/ReconstructGradient_Naive.m
+++ /dev/null
@@ -1,33 +0,0 @@
-function [phase_gradx, phase_grady] = ReconstructGradient_Naive(phase_gradx_meas, phase_grady_meas, n_ap, ssp)
-%
-%  [phase] = ReconstructGradient_Naive(phase_grad_measa);
-%    
-%  Use up-sampling interpolation to naively reconstruct phase gradients.
-%
-%  Input:
-%    phase_grad_meas  - 3D array containing measured (low resolution) 
-%                       x or y-gradients of phases, where (:,:,k) is the
-%                       k-th frame of data.
-%  Output:
-%    phase_gradx      - 3D array containing reconstructed (high resolution) 
-%                       x-gradients of phases where (:,:,k) is the 
-%                       k-th frame of data.
-%    phase_grady      - 3D array containing reconstructed (high resolution) 
-%                       y-gradients of phases where (:,:,k) is the 
-%                       k-th frame of data.
-%
-
-%
-%  J. Nagy
-%  January, 2014
-%
-
-nframes = size(phase_gradx_meas, 3);
-
-phase_gradx = zeros(n_ap, n_ap, nframes);
-phase_grady = zeros(n_ap, n_ap, nframes);
-for k = 1:nframes
-  phase_gradx(:,:,k) = imresize(phase_gradx_meas(:,:,k),ssp);
-  phase_grady(:,:,k) = imresize(phase_grady_meas(:,:,k),ssp);
-end
-
diff --git a/Generator/library/FFM_weights/ReconstructPhase_Layers.m b/Generator/library/FFM_weights/ReconstructPhase_Layers.m
deleted file mode 100644
index 25ae187..0000000
--- a/Generator/library/FFM_weights/ReconstructPhase_Layers.m
+++ /dev/null
@@ -1,139 +0,0 @@
-function phase_layers = ReconstructPhase_Layers(A, W, FFM_input, FFM_output, FFM_options)
-%
-%    phase_layers = ReconstructPhaseC(FFM_input, FFM_output, FFM_options);
-%
-%  This function reconstructs the COMPOSITE phases on each layer from 
-%  the composite x and y-gradients on each layer. 
-%  We assume a Fried geometry of the wavefront sensor.
-%
-%  Input:
-%    FFM_input    - structure that defines input parameters and data 
-%                   for the FFM codes
-%    FFM_output   - structure that results from running the FFM codes.
-%                   In particular, this contains the reconstructed 
-%                   composite (sausage region) gradients on each layer.
-%
-%  Optional Input:
-%      FFM_options - structure containing some optional input paramteters.
-%                    See FFM.m for more information.
-%
-%  Output:
-%    phase_layers - reconstructed phases on each layer.  This is a 4-D
-%                   array, where
-%                       phase_layers(:,:,k,L)
-%                   contains the phase on layer L for frame k.
-%
-
-%
-%  J. Nagy
-%  December, 2012
-%  Modified, July 2015
-%  The previous version did not guarantee the frozen flow held on
-%  the reconstructed phases for each layer.  This version should
-%  fix this problem.
-%
-%  Modified November, 2015, to allow non square subapertures. (J. Nagy) 
-%  So now, ssp can be a scalar (equal diameters in both directions)
-%  or a 1-by-2 array, [ssp_rows, ssp_cols]
-%
-%  Modified April, 2016 to reduce memory requirements.  There are now
-%  two new inputs (A and W) which are needed in other parts of the code.
-%  So it makes no sense to rebuild them here.
-
-%
-%  These first statements just do a quick check to make sure enough
-%  input terms have been given; FFM_options is optional.
-%  Check options, and set default parameters.
-%
-%narginchk(2,3)
-if nargin == 4
-  % Use all defaults for options
-  phase_scale = [];
-  reg_par_PR = [];
-  method_PR = [];
-else
-  if isfield(FFM_options, 'phase_scale')
-    phase_scale = FFM_options.phase_scale;
-  else
-    phase_scale = [];
-  end
-  if isfield(FFM_options, 'reg_par_PR')
-    reg_par_PR = FFM_options.reg_par_PR;
-  else
-    reg_par_PR = [];
-  end
-  if isfield(FFM_options, 'method_PR')
-    method_PR = FFM_options.method_PR;
-  else
-    method_PR = [];
-  end
-end
-if isempty(phase_scale), phase_scale = 1; end
-if isempty(reg_par_PR), reg_par_PR = 1e-6; end
-if isempty(method_PR), method_PR = 'direct'; end
-
-n_ap = FFM_input.n_ap;
-n_frames = FFM_input.n_frames;
-n_layers = FFM_input.n_layers;
-phaseC_gradx = FFM_output.phaseC_gradx;
-phaseC_grady = FFM_output.phaseC_grady;
-pupil_mask = FFM_input.pupil_mask;
-wind_vecs = FFM_input.wind_vecs;
-ssp = FFM_input.ssp;
-%
-%  Modified November, 2015, to allow non square subapertures.
-%  J. Nagy
-%
-if length(ssp) == 1
-    ssp = [ssp, ssp];
-end
-%
-%  Convert wind_vecs into pixel shift values:
-%
-deltax = ssp(2)*wind_vecs(:,1) .* cos(wind_vecs(:,2));
-deltay = ssp(1)*wind_vecs(:,1) .* sin(wind_vecs(:,2));
-
-%
-%  We need to find a composite grid size, and the amount of padding needed
-%  to get from n_ap to n_conmp.  
-%
-[n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay);
-
-%
-%  We need the following matrices to punch out the phases from the
-%  composite grid.
-%
-%  April 2016 modification: These matrices are created in the FFM code,
-%  so instead of rebuilding them, pass them in as input.
-%
-W = WindowMatrix(n_ap, n_comp, pupil_mask, n_comp_pad+1, n_comp_pad+1);
-A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames);
-
-%
-%  In this version, we reconstruct the phase on the composite grid:
-%
-%pupil_maskC = GetCompositeMask(pupil_mask, wind_vecs, ssp, n_ap, n_comp, n_comp_pad, n_frames, n_layers);
-%
-%  April 2016 modification: Changed GetCompositeMask.m so that it does not
-%  build another big matrix.  Instead it uses the given motion matrix.
-%
-pupil_maskC = GetCompositeMask(A, pupil_mask, n_comp, n_comp_pad, n_frames, n_layers);
-
-phaseC_layers = zeros(size(phaseC_gradx));
-for k = 1:n_layers
-    phaseC_layers(:,:,k) = p_ReconstructPhase(phaseC_gradx(:,:,k), phaseC_grady(:,:,k), pupil_maskC(:,:,k), phase_scale, reg_par_PR);
-end
-
-
-
-%
-%  To punch out, I zero out all other layers, so that the punch out
-%  steps adds zeros.  There might be a better way to do this, but it
-%  will require a significant rewrite of the code.
-%
-phase_layers = zeros(n_ap, n_ap, n_frames, n_layers);
-for k = 1:n_layers
-  phaseC_layers1 = zeros(size(phaseC_layers));
-  phaseC_layers1(:,:,k) = phaseC_layers(:,:,k);
-  phase_layers(:,:,:,k) = PunchOutFrames(phaseC_layers1, A, W, n_frames, n_layers, n_comp, n_ap);
-end
diff --git a/Generator/library/FFM_weights/ReconstructPhase_Layers_old.m b/Generator/library/FFM_weights/ReconstructPhase_Layers_old.m
deleted file mode 100644
index cbe69e5..0000000
--- a/Generator/library/FFM_weights/ReconstructPhase_Layers_old.m
+++ /dev/null
@@ -1,127 +0,0 @@
-function phase_layers = ReconstructPhase_Layers(FFM_input, FFM_output, FFM_options)
-%
-%    phase_layers = ReconstructPhaseC(FFM_input, FFM_output, FFM_options);
-%
-%  This function reconstructs the COMPOSITE phases on each layer from 
-%  the composite x and y-gradients on each layer. 
-%  We assume a Fried geometry of the wavefront sensor.
-%
-%  Input:
-%    FFM_input    - structure that defines input parameters and data 
-%                   for the FFM codes
-%    FFM_output   - structure that results from running the FFM codes.
-%                   In particular, this contains the reconstructed 
-%                   composite (sausage region) gradients on each layer.
-%
-%  Optional Input:
-%      FFM_options - structure containing some optional input paramteters.
-%                    See FFM.m for more information.
-%
-%  Output:
-%    phase_layers - reconstructed phases on each layer.  This is a 4-D
-%                   array, where
-%                       phase_layers(:,:,k,L)
-%                   contains the phase on layer L for frame k.
-%
-
-%
-%  J. Nagy
-%  December, 2012
-%  Modified, July 2015
-%  The previous version did not guarantee the frozen flow held on
-%  the reconstructed phases for each layer.  This version should
-%  fix this problem.
-%
-%  Modified November, 2015, to allow non square subapertures. (J. Nagy) 
-%  So now, ssp can be a scalar (equal diameters in both directions)
-%  or a 1-by-2 array, [ssp_rows, ssp_cols]
-
-%
-%  These first statements just do a quick check to make sure enough
-%  input terms have been given; FFM_options is optional.
-%  Check options, and set default parameters.
-%
-%narginchk(2,3)
-if nargin == 2
-  % Use all defaults for options
-  phase_scale = [];
-  reg_par_PR = [];
-  method_PR = [];
-else
-  if isfield(FFM_options, 'phase_scale')
-    phase_scale = FFM_options.phase_scale;
-  else
-    phase_scale = [];
-  end
-  if isfield(FFM_options, 'reg_par_PR')
-    reg_par_PR = FFM_options.reg_par_PR;
-  else
-    reg_par_PR = [];
-  end
-  if isfield(FFM_options, 'method_PR')
-    method_PR = FFM_options.method_PR;
-  else
-    method_PR = [];
-  end
-end
-if isempty(phase_scale), phase_scale = 1; end
-if isempty(reg_par_PR), reg_par_PR = 1e-6; end
-if isempty(method_PR), method_PR = 'direct'; end
-
-n_ap = FFM_input.n_ap;
-n_frames = FFM_input.n_frames;
-n_layers = FFM_input.n_layers;
-phaseC_gradx = FFM_output.phaseC_gradx;
-phaseC_grady = FFM_output.phaseC_grady;
-pupil_mask = FFM_input.pupil_mask;
-wind_vecs = FFM_input.wind_vecs;
-ssp = FFM_input.ssp;
-%
-%  Modified November, 2015, to allow non square subapertures.
-%  J. Nagy
-%
-if length(ssp) == 1
-    ssp = [ssp, ssp];
-end
-%
-%  Convert wind_vecs into pixel shift values:
-%
-deltax = ssp(2)*wind_vecs(:,1) .* cos(wind_vecs(:,2));
-deltay = ssp(1)*wind_vecs(:,1) .* sin(wind_vecs(:,2));
-
-%
-%  We need to find a composite grid size, and the amount of padding needed
-%  to get from n_ap to n_conmp.  
-%
-[n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay);
-
-
-
-
-%
-%  We need the following matrices to punch out the phases from the
-%  composite grid.
-%
-W = WindowMatrix(n_ap, n_comp, pupil_mask, n_comp_pad+1, n_comp_pad+1);
-A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames);
-
-%
-%  In this version, we reconstruct the phase on the composite grid:
-%
-pupil_maskC = GetCompositeMask_old(A,pupil_mask, wind_vecs, ssp, n_ap, n_comp, n_comp_pad, n_frames, n_layers);
-phaseC_layers = zeros(size(phaseC_gradx));
-for k = 1:n_layers
-    phaseC_layers(:,:,k) = p_ReconstructPhase(phaseC_gradx(:,:,k), phaseC_grady(:,:,k), pupil_maskC(:,:,k), phase_scale, reg_par_PR);
-end
-
-%
-%  To punch out, I zero out all other layers, so that the punch out
-%  steps adds zeros.  There might be a better way to do this, but it
-%  will require a significant rewrite of the code.
-%
-phase_layers = zeros(n_ap, n_ap, n_frames, n_layers);
-for k = 1:n_layers
-  phaseC_layers1 = zeros(size(phaseC_layers));
-  phaseC_layers1(:,:,k) = phaseC_layers(:,:,k);
-  phase_layers(:,:,:,k) = PunchOutFrames(phaseC_layers1, A, W, n_frames, n_layers, n_comp, n_ap);
-end
diff --git a/Generator/library/FFM_weights/SVD_Matrix_Inverse.m b/Generator/library/FFM_weights/SVD_Matrix_Inverse.m
deleted file mode 100644
index 7b839cc..0000000
--- a/Generator/library/FFM_weights/SVD_Matrix_Inverse.m
+++ /dev/null
@@ -1,37 +0,0 @@
-function invM = SVD_Matrix_Inverse(M, conditionNumber)
-%
-%    invM = SVD_Matrix_Inverse(M, conditionNumber);
-%
-%  This function inverts the input matrix using SVD with the specified
-%  condition number (ratio of highest tolowest singular values retained).
-%
-%  Input:
-%    M - 2D matrix to be inverted
-%
-%  Optional Input:
-%    conditionNumber - ratio of highest tolowest singular values retained
-%                      (default: 100.0)
-%
-%  Output:
-%    invM - SVD inverse of input matrix M
-%
-%  M. Milton - March 30, 2018
-
-%
-%  Check inputs and set default values.
-%
-if nargin < 2
-    conditionNumber = 1.0e2;
-end
-
-% Compute inverse of M using SVD
-[U, S, Vtranspose] = svd(M);
-[Srows, Scols] = size(S);
-Sdiag = diag(S);
-Sdiag((Sdiag(1)./Sdiag)>conditionNumber)=0;
-Sdiag=1./Sdiag;
-Sdiag(isinf(Sdiag))=0;
-Sdiag(isnan(Sdiag))=0;
-Sinv = zeros(Scols, Srows);
-Sinv(1:Scols,1:Scols)=diag(Sdiag);
-invM = Vtranspose * Sinv * transpose(U);
diff --git a/Generator/library/FFM_weights/SubsampleMatrix_2012.m b/Generator/library/FFM_weights/SubsampleMatrix_2012.m
deleted file mode 100755
index 0de7468..0000000
--- a/Generator/library/FFM_weights/SubsampleMatrix_2012.m
+++ /dev/null
@@ -1,28 +0,0 @@
-function R = SubsampleMatrix(n, ssp)
-%
-%   R = SubsampleMatrix(n, ssp);
-%   
-% This function constructs a sparse matrix that implements subsampling
-% on an image vector. 
-%
-% Input:
-%   n   - dimension of high resolution grid, assumed square (that is
-%         the high resolution grid is n-by-n pixels)
-%   ssp - subsampling parameter, which must divide n with no remainder
-%
-% Output: 
-%   R   - sparse matrix 
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-if rem(n,ssp)~=0
-  error('n must divide subsampling');
-end 
-
-D = kron(speye(n/ssp(1)),ones(1,ssp(1)));
-R = kron(D,D)/ssp(1)^2;
-
diff --git a/Generator/library/FFM_weights/TestPhaseRecon.m b/Generator/library/FFM_weights/TestPhaseRecon.m
deleted file mode 100644
index 5e1b677..0000000
--- a/Generator/library/FFM_weights/TestPhaseRecon.m
+++ /dev/null
@@ -1,48 +0,0 @@
-function  [phase_recon, phase_recon2, phaseC_recon] = TestPhaseRecon(FFM_truth, FFM_input, FFM_options)
-
-pupil_mask = FFM_input.pupil_mask;
-n_ap = FFM_input.n_ap;
-n_subap = FFM_input.n_subap;
-ssp = FFM_input.ssp;
-n_frames = FFM_input.n_frames;
-n_layers = FFM_input.n_layers;
-wind_vecs = FFM_input.wind_vecs;
-
-%
-%  Convert wind_vecs into pixel shift values:
-%
-deltax = ssp*wind_vecs(:,1) .* cos(wind_vecs(:,2));
-deltay = ssp*wind_vecs(:,1) .* sin(wind_vecs(:,2));
-
-%
-%  We need to find a composite grid size, and the amount of padding needed
-%  to get from n_ap to n_conmp.  
-%
-[n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay);
-
-%
-%  First reconstruct phase for each frame:
-%
-phase_recon = PhaseRecon(FFM_truth.phase_gradx, FFM_truth.phase_grady, FFM_input.pupil_mask);
-
-%
-%  Now reconstruct phase on each layer:
-%
-%phaseC_recon = PhaseRecon(FFM_truth.pupil_maskC.*FFM_truth.phaseC_gradx, ...
-%  FFM_truth.pupil_maskC.*FFM_truth.phaseC_grady, FFM_truth.pupil_maskC);
-phaseC_recon = PhaseRecon(FFM_truth.phaseC_gradx, FFM_truth.phaseC_grady, FFM_truth.pupil_maskC);
-
-%
-%  We want to punch these out, and add to get another version of the
-%  reconstructed phase for each frame:
-%
-W = WindowMatrix(n_ap, n_comp, pupil_mask, n_comp_pad+1, n_comp_pad+1);
-A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames);
-
-N = n_comp*n_comp;
-phaseC_recon2_vec = zeros(N*n_layers,1);
-for L = 1:n_layers
-  phaseC_recon2_vec((L-1)*N+1:L*N,1) = reshape(phaseC_recon(:,:,L),n_comp*n_comp,1);
-end
-phase_recon2_vec = kron(speye(n_frames),W)*A*phaseC_recon2_vec;
-phase_recon2 = reshape(phase_recon2_vec, n_ap, n_ap, n_frames);
diff --git a/Generator/library/FFM_weights/TestProblem.m b/Generator/library/FFM_weights/TestProblem.m
deleted file mode 100644
index 0146190..0000000
--- a/Generator/library/FFM_weights/TestProblem.m
+++ /dev/null
@@ -1,320 +0,0 @@
-function [FFM_input, FFM_truth, FFM_options, A, W, R] = TestProblem(n_frames, wind_vecs, noise_level)
-%
-%  This function will generate some data for a test problem for DORA.
-%
-%  Optional Input:
-%      n_frames     - number of frames used for the simulation.
-%                     Default is n_frames = 20
-%      wind_vecs    - specifies angle (theta) and magnitude (r) of wind 
-%                     velocity for each layer,
-%                         wind_vecs(L,1) = r     (L = 1, 2, ..., n_layers)
-%                         wind_vecs(L,2) = theta (L = 1, 2, ..., n_layers)
-%                     Default is
-%                         wind_vecs = [0.05 pi; 0.25 pi/2; 0.15 3*pi/4];
-%                     Note that the simulation currently works of at
-%                     most three layers.
-%      noise_level  - scalar, 0 <= noise_level < 1, which is used to 
-%                     determine the percentage of Gaussian white noise
-%                     added to the simulated measured data.
-%                     Default is noise_level = 0.01 (i.e., 1% noise)
-%
-%  Output:
-%      DORA__ffm_input   - structure containing the following parameters:
-%
-%         Name         Type               Purpose
-%         -----------  ---------------    --------------------------------
-%         phase_gradx  3D double array    contains measured x-gradients of 
-%                                         wavefront phase on each frame 
-%                                         (low resolution)
-%         phase_grady  3D double array    contains measured y-gradients of 
-%                                         wavefront phase on each frame 
-%                                         (low resolution)
-%         wind_vecs    2D double array    specifies angle (theta) and 
-%                                         magnitude (r) of wind 
-%                                         velocity for each layer:
-%                                             wind_vecs(L,1) = r   
-%                                             wind_vecs(L,2) = theta 
-%                                         L = 1, 2, ..., n_layers.
-%         pupil_mask   2D logical array   pupil mask for aperture
-%         n_subap      Integer            number of pixels across the 
-%                                         subaperture
-%         n_ap         Integer            number of pixels across the 
-%                                         aperture
-%         ssp          Integer            subsampling parameter, which 
-%                                         should satisfy
-%                                              n_ap = ssp*n_subap
-%         n_frames     Integer            number of frames of data
-%         n_layers     Integer            number of atmospheric layers
-%       
-%      FFM_truth   - structure containing the following parameters:
-%
-%         Name         Type               Purpose
-%         -----------  ---------------    --------------------------------
-%         phase        3D double array    contains true wavefront phases
-%                                         for each frame
-%         phaseC       3D double array    contains true composite 
-%                                         wavefront phases on each 
-%                                         atmospheric layer
-%         phase_gradx  3D double array    contains true x-gradients of 
-%                                         wavefront phase on each frame 
-%                                         (high resolution)
-%         phase_grady  3D double array    contains true y-gradients of 
-%                                         wavefront phase on each frame 
-%                                         (high resolution)
-%         phaseC_gradx 3D double array    contains true composite 
-%                                         x-gradients of wavefront phase 
-%                                         on each frame (high resolution)
-%         phaseC_grady 3D double array    contains true composite 
-%                                         y-gradients of wavefront phase 
-%                                         on each frame (high resolution)
-%         pupil_maskC  3D logical array   contains pupil mask for
-%                                         composite information (phases
-%                                         and gradients) on leach layer
-%          
-%      FFM_options - structure containing the following parameters:
-%
-%         Name         Type               Purpose
-%         -----------  ---------------    --------------------------------
-%         phase_scale  Double             parameter used to scale the 
-%                                         derivative opertation when 
-%                                         reconstructing phase from the
-%                                         gradients.
-%                                         Default: 1 (i.e., no scaling)
-%         reg_par_FFM  Double             Tikhonov regularization parameter 
-%                                         for frozen flow model high res
-%                                         gradient reconstruction.
-%                                         Default: 1e-3
-%         reg_par_PR   Double             Tikhonov regularization parameter                              
-%                                         for phase reconstruction.
-%                                         Default: sqrt(eps)
-%         method_FFM   String             Method used to solve the Tikhonov
-%                                         regularized least squares problem
-%                                         for the FFM gradient
-%                                         reconstruction.
-%                                         Currently we have only one
-%                                         method, 'lsqr', but we might want
-%                                         to put in other methods later.
-%                                         Default: 'lsqr'
-%         method_PR    String             Method used to solve the Tikhonov
-%                                         regularized least squares problem
-%                                         for the phase reconstruction
-%                                         reconstruction. Here we can use
-%                                         either 
-%                                          'direct': MATLAB's backslash
-%                                                    operator, which uses
-%                                                    efficient sparse 
-%                                                    factorization methods.
-%                                          'lsqr'  : iterative LSQR method.
-%                                         Default: 'direct'
-%         rtol_FFM     Double             Relative residual stopping 
-%                                         tolerance for phase reconst.
-%                                         This is needed if method_FFM is
-%                                         lsqr.
-%                                         Default: 1e-6
-%         rtol_PR      Double             Relative residual stopping 
-%                                         tolerance for phase reconst.
-%                                         This is needed if method_PR is
-%                                         lsqr.
-%                                         Default: 1e-6
-%
-
-% Some remarks on notation:
-%   * In the codes, I will try to use:
-%       k - integer to denote a specific frame of data, k = 1:n_frames
-%       L - integer to denote a specific layer, L = 1:n_layers
-%       (i,j) - integers denoting a specific pixel in a frame or layer.
-%   * In the FFM gradient reconstruction codes, we use pixel shifts
-%     given by detlax and deltay.  We assume the information in wind_vecs
-%     pertains to the low resolution grid, and so
-%       deltax = r*ssp*cos(theta)
-%       deltay = r*ssp*sin(theta)
-%     where r = wind_vecs(L,1) and theta = wind_vecs(L,2).
-%     Note that
-%       deltax = number of pixels the atmosphere shifts to the right
-%       deltay = number of pixels the atmosphere shifts to the left
-%     but this should be on the high resolution grid. So be careful here.
-%   * Generally we assume constant speed, but the FFM code does allow for
-%     non-constant speed.  Specifically:
-%             * Number of rows in deltax (and deltay) = n_layers
-%             * If there is only one colum, then it is 
-%               assumed that speed is constant.
-%             * For non-constant speed, deltax and deltay should
-%               have n_frames-1 columns, giving the number
-%               of pixels shifting in the x(y)-direction for
-%               each frame (the first frame is assumed
-%               fixed, so only need 2, 3, ..., n_frames)
-
-
-switch nargin
-  case 0
-    n_frames = []; wind_vecs = []; noise_level = [];
-  case 1
-    wind_vecs = []; noise_level = [];
-  case 2
-    noise_level = [];
-  case 3
-    [];
-  otherwise
-    error('Too many input arguments.')
-end
-
-if isempty(n_frames)
-  n_frames = 20;
-end
-if isempty(wind_vecs)
-  wind_vecs = [0.25 pi; 0.5 pi/2; 0.65 3*pi/4];
-end
-if isempty(noise_level)
-  noise_level = 0.01;
-end
-
-n_layers = size(wind_vecs,1);
-  
-load phi_comp_true
-phaseC_true = phi_comp_true(:,:,1:n_layers)./2;
-
-%
-%  We'll assume 32 pixels across subaperture, and ssp = 4
-%  (i.e., 128 pixels across aperture), and we'll pick a number of frames:
-%
-% ssp = 4;
-% n_subap = 32;
-
-
-ssp = 6;
-n_subap = 40;
-
-n_ap = ssp*n_subap;
-
-%
-%  Convert wind_vecs into pixel shift values:
-%
-deltax = ssp*wind_vecs(:,1) .* cos(wind_vecs(:,2));
-deltay = ssp*wind_vecs(:,1) .* sin(wind_vecs(:,2));
-
-%
-%  We need to find a composite grid size, and the amount of padding needed
-%  to get from n_ap to n_conmp.  We can then cut down the loaded true
-%  composite phases to the largest size that we need for this simulation.
-%
-[n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay);
-phaseC_true = phaseC_true(1:n_comp, 1:n_comp, :);
-
-%
-%  With these, we can create pupil masks.  I'm not sure the correct way
-%  to do this, but here's what I think:
-%    Generally, the pupil mask is an annulus, where the ratio of the 
-%    diameters (or radii) of the circles to be 0.25.
-%  Our "MakeMask" function uses radius of 1 to generate a circle to the
-%  outer edge of the array.  So to geneate the pupil masks, we use:
-%
-pupil_mask_subap = MakeMask(n_subap, 1, 0.25);
-pupil_mask = MakeMask(n_ap, 1, 0.25);
-% pupil_mask = ones(n_ap);
-%
-% Note, for example, if n_ap = 128 (this is the diameter of the outer
-% circle in the pupil mask), then the diameter of the inner circle is
-% then 0.25*128 = 32 pixels.
-% Similarly, if n_subap = 32, then the diameter of the inner circle  is
-% then 0.25*32 = 8 pixels.
-%
-% For another example, in the case of the AEOS data, we used 
-% ssp = 6, n_subap = 32, and n_ap = ssp*n_subap = 192.  So in this case,
-% the diameter of the inner circle for the pupil mask is 
-% 0.25*192 = 48 pixels. 
-%
-
-%
-%  We need the following matrices:
-%
-R = SubsampleMatrix(n_ap, ssp);
-W = WindowMatrix(n_ap, n_comp, pupil_mask, n_comp_pad+1, n_comp_pad+1);
-A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames);
-
-%
-%  Get punched out versions of the wavefront on each frame
-%
-N = n_comp*n_comp;
-phase_true_comp_vec = zeros(N*n_layers,1);
-for L = 1:n_layers
-  phase_true_comp_vec((L-1)*N+1:L*N,1) = reshape(phaseC_true(:,:,L),n_comp*n_comp,1);
-end
-
-phase_true_vec = kron(speye(n_frames),W)*A*phase_true_comp_vec;
-phase_true = reshape(phase_true_vec, n_ap, n_ap, n_frames);
-%
-% The next step in the simulation is to construct gradients.
-%
-Dx = GradxMatrix(n_comp);
-Dy = GradyMatrix(n_comp);
- 
-phaseC_gradx_true = zeros(size(phaseC_true));
-phaseC_grady_true = zeros(size(phaseC_true));
-for L = 1:n_layers
-  phaseC_gradx_true(:,:,L) = reshape(Dx*reshape(phaseC_true(:,:,L),n_comp*n_comp,1),n_comp,n_comp);
-  phaseC_grady_true(:,:,L) = reshape(Dy*reshape(phaseC_true(:,:,L),n_comp*n_comp,1),n_comp,n_comp);
-end
-
-%
-% Get punched out versions of these gradients, and the corresponding low
-% resolution versions:
-%
-N = n_comp*n_comp;
-phaseC_gradx_true_vec = zeros(N*n_layers,1);
-phaseC_grady_true_vec = zeros(N*n_layers,1);
-for L = 1:n_layers
-  phaseC_gradx_true_vec((L-1)*N+1:L*N,1) = reshape(phaseC_gradx_true(:,:,L),n_comp*n_comp,1);
-  phaseC_grady_true_vec((L-1)*N+1:L*N,1) = reshape(phaseC_grady_true(:,:,L),n_comp*n_comp,1);
-end
-phase_gradx_true_vec = kron(speye(n_frames),W)*A*phaseC_gradx_true_vec;
-phase_grady_true_vec = kron(speye(n_frames),W)*A*phaseC_grady_true_vec;
-phase_gradx_meas_vec = kron(speye(n_frames),R)*phase_gradx_true_vec;
-phase_grady_meas_vec = kron(speye(n_frames),R)*phase_grady_true_vec;
-
-phase_gradx_true = reshape(phase_gradx_true_vec, n_ap, n_ap, n_frames);
-phase_grady_true = reshape(phase_grady_true_vec, n_ap, n_ap, n_frames);
-phase_gradx_meas = reshape(phase_gradx_meas_vec, n_subap, n_subap, n_frames);
-phase_grady_meas = reshape(phase_grady_meas_vec, n_subap, n_subap, n_frames);
-
-%
-%  Now add noise to the measured gradients -- using the same noise level,
-%  but a different realization for each frame.
-%
-for k = 1:n_frames
-  phase_gradx_meas(:,:,k) = phase_gradx_meas(:,:,k) + ...
-    WhiteNoise(phase_gradx_meas(:,:,k), noise_level, k);
-  phase_grady_meas(:,:,k) = phase_grady_meas(:,:,k) + ...
-    WhiteNoise(phase_grady_meas(:,:,k), noise_level, n_frames+k);
-end
-%(A, pupil_mask, n_comp, n_comp_pad, n_frames, n_layers)
-pupil_maskC = GetCompositeMask(A,pupil_mask, n_comp, n_comp_pad, n_frames, n_layers);
-
-FFM_input.phase_gradx = phase_gradx_meas;
-FFM_input.phase_grady = phase_grady_meas;
-FFM_input.pupil_mask = pupil_mask;
-FFM_input.wind_vecs = wind_vecs;
-FFM_input.ssp = ssp;
-FFM_input.n_ap = n_ap;
-FFM_input.n_subap = n_subap;
-FFM_input.n_frames = n_frames;
-FFM_input.n_layers = n_layers;
-FFM_input.subap_mask = pupil_mask_subap;
-
-FFM_truth.phase = phase_true;
-FFM_truth.phaseC = phaseC_true;
-FFM_truth.phase_gradx = phase_gradx_true;
-FFM_truth.phase_grady = phase_grady_true;
-FFM_truth.phaseC_gradx = phaseC_gradx_true;
-FFM_truth.phaseC_grady = phaseC_grady_true;
-FFM_truth.pupil_maskC = pupil_maskC;
-
-FFM_options.phase_scale = 1;
-FFM_options.reg_par_FFM = 1e-3;
-FFM_options.reg_par_PR = sqrt(eps);
-FFM_options.method_FFM = 'lsqr';
-FFM_options.method_PR = 'direct';
-FFM_options.rtol_FFM = 1e-6;
-FFM_options.rtol_PR = [];
-
-
-
diff --git a/Generator/library/FFM_weights/WhiteNoise.m b/Generator/library/FFM_weights/WhiteNoise.m
deleted file mode 100755
index 6c3c7c1..0000000
--- a/Generator/library/FFM_weights/WhiteNoise.m
+++ /dev/null
@@ -1,31 +0,0 @@
-function N = WhiteNoise(b, level, seed)
-%
-%      N = WhiteNoise(b, level, seed);
-%
-%  This function generates Gaussian white noise for the 
-%  data b. 
-%
-%  Input:  b - array containing data
-%      level - scalar in [0, 1] specifiying level (percentage) of
-%              noise.  For example, level = 0.01 implies
-%                  norm(N)/norm(b) = 0.01, or 1% noise
-%              Default is level = 0.01.
-%       seed - Used to set the random number generator.
-%              Default is seed = 0.
-%
-%  Output: N - array same dimension as b, containing pseudo-random
-%              values drawn from a normal distribution with mean zero
-%              and standard deviation one, and scaled as described above.
-%
-
-% Check inputs and set default values.
-if nargin == 1, level = [];, seed = [];, end
-if nargin == 2, seed = [];, end
-if isempty(level), level = 0.01;, end
-if isempty(seed), seed = 0;, end
-
-% Generate noise.
-randn('seed', seed);
-N = randn(size(b));
-N = N / norm(N(:));
-N = level*norm(b(:))*N;
diff --git a/Generator/library/FFM_weights/p_FFM.m b/Generator/library/FFM_weights/p_FFM.m
deleted file mode 100755
index 938febb..0000000
--- a/Generator/library/FFM_weights/p_FFM.m
+++ /dev/null
@@ -1,259 +0,0 @@
-function [FFM_output, A, W, R] = p_FFM(FFM_input, FFM_options, A,W,R)
-%
-%  FFM_output = p_FFM(FFM_input, FFM_options);
-%
-%  This function is used to run the FFM stuff for DORA ...
-%
-%  The p is used to denote that this MATLAB code has been stripped of 
-%  any unnecessary computations to try to get it ready for the parallel
-%  implementation.
-%
-%  Here we reconstruct the composite gradients on each layer, but then
-%  we punch them out to get gradients on each frame.  Then we recosntruct
-%  the phase on each frame.
-%
-%  Input:
-%      FFM_input   - structure containing the following parameters:
-%
-%         Name         Type               Purpose
-%         -----------  ---------------    --------------------------------
-%         phase_gradx  3D double array    contains measured x-gradients of 
-%                                         wavefront phase on each frame 
-%                                         (low resolution)
-%         phase_grady  3D double array    contains measured y-gradients of 
-%                                         wavefront phase on each frame 
-%                                         (low resolution)
-%         wind_vecs    2D double array    specifies angle (theta) and 
-%                                         magnitude (r) of wind 
-%                                         velocity for each layer:
-%                                             wind_vecs(L,1) = r   
-%                                             wind_vecs(L,2) = theta 
-%                                         L = 1, 2, ..., n_layers.
-%         pupil_mask   2D logical array   pupil mask for aperture
-%         n_subap      Integer            number of pixels across the 
-%                                         subaperture
-%                          Modified November, 2015, to allow non square 
-%                          subapertures. (J. Nagy) So now, n_subap can
-%                          be a scalar (equal diameters in both directions)
-%                          or a 1-by-2 array, [nrows, ncols]
-%         n_ap         Integer            number of pixels across the 
-%                                         aperture
-%         ssp          Integer            subsampling parameter, which 
-%                                         should satisfy
-%                                              n_ap = ssp*n_subap
-%                          Modified November, 2015, to allow non square 
-%                          subapertures. (J. Nagy) So now, ssp can
-%                          be a scalar (equal diameters in both directions)
-%                          or a 1-by-2 array, [ssp_rows, ssp_cols]
-%         n_frames     Integer            number of frames of data
-%         n_layers     Integer            number of atmospheric layers
-%
-%  Optional Input:
-%      FFM_options - structure containing the following parameters:
-%
-%         Name         Type               Purpose
-%         -----------  ---------------    --------------------------------
-%         phase_scale  Double             parameter used to scale the 
-%                                         derivative opertation when 
-%                                         reconstructing phase from the
-%                                         gradients.
-%                                         Default: 1 (i.e., no scaling)
-%         reg_par_FFM  Double             Tikhonov regularization parameter 
-%                                         for frozen flow model high res
-%                                         gradient reconstruction.
-%                                         Default: 1e-3
-%         reg_par_PR   Double             Tikhonov regularization parameter                              
-%                                         for phase reconstruction.
-%                                         Default: 1e-6
-%         rtol_FFM     Double             Relative residual stopping 
-%                                         tolerance for phase reconst.
-%                                         This is needed if method_FFM is
-%                                         lsqr.
-%                                         Default: 1e-6
-
-%
-%  Output:
-%      FFM_output - structure containing the following parameters:
-%
-%         Name         Type               Purpose
-%         -----------  ---------------    --------------------------------
-%         phaseC_gradx 3D double array    contains reconstructed composite 
-%                                         x-gradients of wavefront phase 
-%                                         on each frame (high resolution)
-%         phaseC_grady 3D double array    contains reconstructed composite 
-%                                         y-gradients of wavefront phase 
-%                                         on each frame (high resolution)
-%         A, W, R      Sparse matrices    See below -- these do the motion,
-%                                         windowing and subsampling
-%
-
-% Some remarks on notation:
-%   * In the codes, I will try to use:
-%       k - integer to denote a specific frame of data, k = 1:n_frames
-%       L - integer to denote a specific layer, L = 1:n_layers
-%       (i,j) - integers denoting a specific pixel in a frame or layer.
-%   * In the FFM gradient reconstruction codes, we use pixel shifts
-%     given by detlax and deltay.  We assume the information in wind_vecs
-%     pertains to the low resolution grid, and so
-%       deltax = r*ssp*cos(theta)
-%       deltay = r*ssp*sin(theta)
-%     where r = wind_vecs(L,1) and theta = wind_vecs(L,2).
-%     Note that
-%       deltax = number of pixels the atmosphere shifts to right/left
-%       deltay = number of pixels the atmosphere shifts up/down
-%     but this should be on the high resolution grid. So be careful here.
-%   * Generally we assume constant speed, but the FFM code does allow for
-%     non-constant speed.  Specifically:
-%             * Number of rows in deltax (and deltay) = n_layers
-%             * If there is only one colum, then it is 
-%               assumed that speed is constant.
-%             * For non-constant speed, deltax and deltay should
-%               have n_frames-1 columns, giving the number
-%               of pixels shifting in the x(y)-direction for
-%               each frame (the first frame is assumed
-%               fixed, so only need 2, 3, ..., n_frames)
-
-%
-%  J. Nagy
-%  October, 2013
-
-%
-%  These first statements just do a quick check to make sure enough
-%  input terms have been given; FFM_options is optional.
-%  Check options, and set default parameters.
-%
-% narginchk(1,2)
-if nargin == 1
-  % Use all defaults for options
-  phase_scale = [];
-  reg_par_FFM = [];
-  reg_par_PR = [];
-  rtol_FFM = [];
-else
-  if isfield(FFM_options, 'phase_scale')
-    phase_scale = FFM_options.phase_scale;
-  else
-    phase_scale = [];
-  end
-  if isfield(FFM_options, 'reg_par_FFM')
-    reg_par_FFM = FFM_options.reg_par_FFM;
-  else
-    reg_par_FFM = [];
-  end
-  if isfield(FFM_options, 'reg_par_PR')
-    reg_par_PR = FFM_options.reg_par_PR;
-  else
-    reg_par_PR = [];
-  end
-  if isfield(FFM_options, 'rtol_FFM')
-    rtol_FFM = FFM_options.rtol_FFM;
-  else
-    rtol_FFM = [];
-  end
-end
-if isempty(phase_scale), phase_scale = 1; end
-if isempty(reg_par_FFM), reg_par_FFM = 1e-3; end
-if isempty(reg_par_PR), reg_par_PR = 1e-6; end
-if isempty(rtol_FFM), rtol_FFM = 1e-6; end
-
-phase_gradx_meas = FFM_input.phase_gradx;
-phase_grady_meas = FFM_input.phase_grady;
-pupil_mask = FFM_input.pupil_mask;
-ssp = FFM_input.ssp;
-%
-%  Modified November, 2015, to allow non square subapertures.
-%  J. Nagy
-%
-if length(ssp) == 1
-    ssp = [ssp, ssp];
-end
-n_ap = FFM_input.n_ap;
-n_subap = FFM_input.n_subap;
-%
-%  Modified November, 2015, to allow non square subapertures.
-%  J. Nagy
-%
-if length(n_subap) == 1
-    n_subap = [n_subap, n_subap];
-end
-n_frames     = FFM_input.n_frames;
-n_layers     = FFM_input.n_layers;
-wind_vecs    = FFM_input.wind_vecs;
-if isfield(FFM_input,'weights')
-    weights      = FFM_input.weights;
-else
-    weights=[];
-end
-%
-%  Check to make sure the input variables have no obvious errors:
-%
-%  Modified November, 2015, to allow non square subapertures.
-%  J. Nagy
-%
-if n_ap ~= ssp(1)*n_subap(1) || n_ap ~= ssp(2)*n_subap(2)
-  error('input values should satisfy n_ap = ssp*n_subap')
-end
-if size(phase_gradx_meas) ~= size(phase_grady_meas)
-  error('input phase gradient arrays should be same size')
-end
-if n_layers ~= size(wind_vecs,1)
-  error('wind_vecs information does not match input number of layers')
-end
-if n_frames ~= size(phase_gradx_meas,3)
-  error('number of frames of input phase gradients does not match n_frames')
-end
-
-%
-%  Convert wind_vecs into pixel shif\t values:
-%
-%  Modified November, 2015, to allow non square subapertures.
-% 
-deltax = ssp(2)*wind_vecs(:,1) .* cos(wind_vecs(:,2));
-deltay = ssp(1)*wind_vecs(:,1) .* sin(wind_vecs(:,2));
-%
-%  We need to find a composite grid size, and the amount of padding needed
-%  to get from n_ap to n_conmp.  
-%
-[n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay);
-
-%
-%  FFM Gradient Reconstruction
-%
-%     We first need the following matrices:
-%
-if nargin == 2
-    if isfield(FFM_options,'sinc_reg')
-         R = SubsampleMatrix(n_ap, ssp, FFM_options.sinc_reg);
-    else
-        R = SubsampleMatrix(n_ap, ssp);
-    end
-    W = WindowMatrix(n_ap, n_comp, pupil_mask, n_comp_pad+1, n_comp_pad+1);
-    A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames);
-end
-%
-%  Now reconstruct composite x-gradients of wavefront phase on each 
-%  atmospheric layer:
-%
-[phaseC_gradx, gradx_iters, x_relres, x_resvec ] = p_ReconstructGradient(A, W, R, ...
-  phase_gradx_meas, n_layers, n_comp, reg_par_FFM, rtol_FFM, weights );
-
-%
-%  and then reconstruct composite y-gradients of wavefront phase on each
-%  atmospheric layer:
-%
-[phaseC_grady, grady_iters, y_relres, y_resvec ] = p_ReconstructGradient(A, W, R, ...
-  phase_grady_meas, n_layers, n_comp, reg_par_FFM, rtol_FFM, weights );
-
-FFM_output.phaseC_gradx = phaseC_gradx;
-FFM_output.phaseC_grady = phaseC_grady;
-FFM_output.x_relres = x_relres;
-FFM_output.y_relres = y_relres;
-FFM_output.y_resvec = y_resvec;
-FFM_output.x_resvec = x_resvec;
-FFM_output.y_iters  = grady_iters;
-FFM_output.x_iters  = gradx_iters;
-
-
-
-
-
diff --git a/Generator/library/FFM_weights/p_ReconstructGradient.m b/Generator/library/FFM_weights/p_ReconstructGradient.m
deleted file mode 100755
index e28698c..0000000
--- a/Generator/library/FFM_weights/p_ReconstructGradient.m
+++ /dev/null
@@ -1,95 +0,0 @@
-function [phaseC_grad, iters, relres, resvec ] = p_ReconstructGradient(A, W, R, phase_grad_meas, n_layers, n_comp, alpha, rtol, Weights)
-%
-%  [phaseC_grad, iters] = ReconstructGradient(A, W, R, ...
-%         phase_grad_meas, n_layers, n_comp, alpha, method, rtol);
-%    
-%  Use the frozen flow model (FFM) to reconstruct high resolution 
-%  gradients from low resolution measurements. 
-%
-%  The p is used to denote that this MATLAB code has been stripped of 
-%  any unnecessary computations to try to get it ready for the parallel
-%  implementation.
-%
-%  Input:
-%    A, W, R          - sparse matrices that model the FFM process of
-%                       WFS data collection.
-%    phase_grad_meas  - 3D array containing measured (low resolution) 
-%                       x or y-gradients of phases, where (:,:,k) is the
-%                       k-th frame of data.
-%    n_layers         - number of atmospheric layers
-%    n_comp           - size of the composite grid
-%
-%    alpha            - Tikhonov regularization parameter. Default is
-%                       alpha = 1e-3.
-%    rtol             - residual stopping tolerance for LSQR.
-%                       Default is 1e-6.
-%
-%  Output:
-%    phaseC_grad      - 3D array containing reconstructed (high resolution) 
-%                       x or y-gradients of phases on composite grid, 
-%                       where (:,:,L) is the L-th atmospheric layer
-%
-%  Optional Output:
-%    iters            - number of LSQR iterations needed to find least
-%                       squares solution.
-%
-
-%
-%  J. Nagy
-%  October, 2013
-%
-
-alpha_scale = sqrt(max(A*ones(size(A,2),1))*max(A'*ones(size(A,1),1)));
-
-n_frames = size(phase_grad_meas, 3);
-MaxIter = 100*n_comp;
-
-% per Jim's advice to limit the number of iterationss
-% MaxIter = 10*(n_frames-1)+1;
-
-alpha = alpha_scale*alpha;
-
-% Weights to mask out bad sub-apertures
-if ~isempty(Weights)
-    
-    % dynamic sub-aperture masking (new version Aug 5, 2018)
-    if size(Weights,3)>1
-        v_ww = Weights(:,:,1);   WeightMatrix = spdiags(v_ww(:),0,numel(v_ww(:)),numel(v_ww(:)));
-        WW = reshape(Weights,[ size(Weights,1)*size(Weights,2) size(Weights,3) ]);
-        radv=size(R,1);cadv = size((WeightMatrix*R)*W,2);
-        r=1;c=1;
-        for j=1:size(Weights,3)
-            WW_j = spdiags(WW(:,j),0,numel(WW(:,j)),numel(WW(:,j)));
-            Wq(r:r+(radv-1),c:c+(cadv-1)) = (WW_j*R)*W;
-            r=r+radv;c=c+cadv;
-        end
-        A = [ Wq*A  ; alpha*speye(size(A,2)) ]; %= [kron(speye(n_frames),(WeightMatrix*R)*W)*A; alpha*speye(size(A,2))];
-        b = [kron(speye(n_frames),WeightMatrix)*phase_grad_meas(:); zeros(size(A,2),1)];
-%         r=1;c=1;
-%         for j=1:size(Weights,3)
-%             WW_j = spdiags(WW(:,j),0,numel(WW(:,j)),numel(WW(:,j)));
-%             meas_j = phase_
-%             Wq(r:r+(radv-1),c:c+(cadv-1)) = (WW_j*R)*W;
-%             r=r+radv;c=c+cadv;
-%         end        
-    else
-        % FFM subap-mask static for entire FFM - Aug 4, 2018
-        WeightMatrix = spdiags(Weights(:),0,numel(Weights(:)),numel(Weights(:)));
-        A = [kron(speye(n_frames),(WeightMatrix*R)*W)*A; alpha*speye(size(A,2))];
-        b = [kron(speye(n_frames),WeightMatrix)*phase_grad_meas(:); zeros(size(A,2),1)];
-    end    
-% Original FFM     
-%      b = [kron(speye(n_frames),WeightMatrix))*phase_grad_meas(:); zeros(size(A,2),1)];
-%     b = [WeightMatrix*phase_grad_meas(:); zeros(size(A,2),1)];
-else
-    A = [kron(speye(n_frames),R*W)*A; alpha*speye(size(A,2))];
-    b = [phase_grad_meas(:); zeros(size(A,2),1)];
-end
-[phaseC_grad, flag, relres, iters, resvec] = lsqr(A, b, rtol, MaxIter);  
-
-%
-%  Check this -- looks like we shouldn't need to reshape this into a
-%  3D array, because we are using it as a vector.
-%
-phaseC_grad = reshape(phaseC_grad, n_comp, n_comp, n_layers);
-
diff --git a/Generator/library/FFM_weights/p_ReconstructPhase.m b/Generator/library/FFM_weights/p_ReconstructPhase.m
deleted file mode 100755
index 0523efa..0000000
--- a/Generator/library/FFM_weights/p_ReconstructPhase.m
+++ /dev/null
@@ -1,92 +0,0 @@
-function phase = p_ReconstructPhase(phase_gradx, phase_grady, pupil_mask, scale, alpha)
-%
-%    phase = p_ReconstructPhase(phase_gradx, phase_grady, pupil_mask, alpha);
-%
-%  This function reconstructs the phase from its gradient measurements.
-%  We assume a Fried geometry of the wavefront sensor.
-%
-%  The p is used to denote that this MATLAB code has been stripped of 
-%  any unnecessary computations to try to get it ready for the parallel
-%  implementation.
-%
-%  Input:
-%    phase_gradx - array containing x-gradients of phases.  This can be
-%                  either a 2D or a 3D array.  In case of 3D, each 2D
-%                  slice, phase_gradx(:,:,k), should be gradients for a 
-%                  particular frame of data.
-%    phase_grady - array containing y-gradients of phases.  This can be
-%                  either a 2D or a 3D array.  In case of 3D, each 2D
-%                  slice, phase_gradx(:,:,k), should be gradients for a 
-%                  particular frame of data.
-%    pupil_mask  - pupil mask for phases.  Must be a 2D array, so
-%                  that each phase has the same pupil mask.
-%
-%  Optional Input:
-%    scale       - allows for a normalization scale for specific geometries.
-%                  Default is to use scale = 1;
-%    alpha       - Tikhonov regularization parameter. Default is
-%                  alpha = 1e-6.
-%
-%  Output:
-%    phase       - reconstructed phases.
-%
-
-%
-%  J. Nagy
-%  November, 2013
-%
-
-%
-%  Check inputs and set default values.
-%
-switch nargin
-  case 3
-    scale = []; alpha = []; 
-  case 4
-    alpha = [];
-end
-
-if isempty(scale)
-  scale = 1;
-end
-if isempty(alpha)
-  %
-  %  Note that the default for this should be different in the C-code
-  %  because we are using a different method to solve the regularized
-  %  system.
-  %
-  alpha = 1e-6;
-end
-
-alpha = scale*alpha;
-
-%
-%  This can help reduce some boundary artifacts ...
-%
-pad_size = 1;
-phase_gradx = padarray(phase_gradx, [pad_size, pad_size], 'both');
-phase_grady = padarray(phase_grady, [pad_size, pad_size], 'both');
-pupil_mask = padarray(pupil_mask, [pad_size, pad_size], 'both');
-
-%
-%  Get dimensions of padded versions ...
-%
-[m_ap, n_ap, n_frames] = size(phase_gradx);
-
-%
-%  Now set pu matrices and solve ...
-%
-Dx = GradxMatrix(n_ap, scale);
-Dy = GradyMatrix(n_ap, scale);
-
-P = spdiags(pupil_mask(:), 0, n_ap*n_ap, n_ap*n_ap);
-A = [P*Dx; P*Dy; alpha*speye(n_ap*n_ap)];
-b = [reshape(phase_gradx,n_ap*n_ap,n_frames); reshape(phase_grady,n_ap*n_ap, n_frames); zeros(n_ap*n_ap,n_frames)];
-phase_vecs = A\b;
-pupil_mask = pupil_mask(:,:,ones(1,n_frames));
-phase = pupil_mask .* reshape(phase_vecs, n_ap, n_ap, n_frames);
-
-%
-%  Extract phase from padded version ...
-%
-phase = phase(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
diff --git a/Generator/library/FFM_weights/p_ReconstructPhase_reg.m b/Generator/library/FFM_weights/p_ReconstructPhase_reg.m
deleted file mode 100644
index 8f95bbd..0000000
--- a/Generator/library/FFM_weights/p_ReconstructPhase_reg.m
+++ /dev/null
@@ -1,115 +0,0 @@
-function phase = p_ReconstructPhase(phase_gradx, phase_grady, pupil_mask, scale, alpha)
-%
-%    phase = p_ReconstructPhase(phase_gradx, phase_grady, pupil_mask, alpha);
-%
-%  This function reconstructs the phase from its gradient measurements.
-%  We assume a Fried geometry of the wavefront sensor.
-%
-%  The p is used to denote that this MATLAB code has been stripped of 
-%  any unnecessary computations to try to get it ready for the parallel
-%  implementation.
-%
-%  Input:
-%    phase_gradx - array containing x-gradients of phases.  This can be
-%                  either a 2D or a 3D array.  In case of 3D, each 2D
-%                  slice, phase_gradx(:,:,k), should be gradients for a 
-%                  particular frame of data.
-%    phase_grady - array containing y-gradients of phases.  This can be
-%                  either a 2D or a 3D array.  In case of 3D, each 2D
-%                  slice, phase_gradx(:,:,k), should be gradients for a 
-%                  particular frame of data.
-%    pupil_mask  - pupil mask for phases.  Must be a 2D array, so
-%                  that each phase has the same pupil mask.
-%
-%  Optional Input:
-%    scale       - allows for a normalization scale for specific geometries.
-%                  Default is to use scale = 1;
-%    alpha       - Tikhonov regularization parameter. Default is
-%                  alpha = 1e-6.
-%
-%  Output:
-%    phase       - reconstructed phases.
-%
-
-%
-%  J. Nagy
-%  November, 2013
-%
-
-%
-%  Check inputs and set default values.
-%
-switch nargin
-  case 3
-    scale = []; alpha = []; 
-  case 4
-    alpha = [];
-end
-
-if isempty(scale)
-  scale = 1;
-end
-if isempty(alpha)
-  %
-  %  Note that the default for this should be different in the C-code
-  %  because we are using a different method to solve the regularized
-  %  system.
-  %
-  alpha = 1e-6;
-end
-
-alpha = scale*alpha;
-
-%
-%  This can help reduce some boundary artifacts ...
-%
-pad_size = 1;
-phase_gradx = padarray(phase_gradx, [pad_size, pad_size], 'both');
-phase_grady = padarray(phase_grady, [pad_size, pad_size], 'both');
-pupil_mask = padarray(pupil_mask, [pad_size, pad_size], 'both');
-
-%
-%  Get dimensions of padded versions ...
-%
-[m_ap, n_ap, n_frames] = size(phase_gradx);
-
-%
-%  Now set pu matrices and solve ...
-%
-Dx = GradxMatrix(n_ap, scale);
-Dy = GradyMatrix(n_ap, scale);
-
-P = spdiags(pupil_mask(:), 0, n_ap*n_ap, n_ap*n_ap);
-
-%  JN: Changes, Sept. 2016.
-%      In previous implementation we used a standard Tikhonov identity
-%      matrix for regularization.  We now change this to a Laplacian
-%      defined by the Hudgin geometry.  According to papers by Bardsley
-%      and Gilles, this should be a good choice.  See also papers by
-%      Dekaney.
-%
-%RegMatrix = speye(n_ap*n_ap);
-RegMatrix = HudginRegularizer(n_ap);
-
-A = [P*Dx; P*Dy; alpha*RegMatrix];
-b = [reshape(phase_gradx,n_ap*n_ap,n_frames); reshape(phase_grady,n_ap*n_ap, n_frames); zeros(size(RegMatrix,1),n_frames)];
-
-warning('off');
-phase_vecs = A\b;
-warning('on');
-pupil_mask = pupil_mask(:,:,ones(1,n_frames));
-phase = pupil_mask .* reshape(phase_vecs, n_ap, n_ap, n_frames);
-
-%
-%  Extract phase from padded version ...
-%
-phase = phase(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
-
-function RegMatrix = HudginRegularizer(n_ap)
-%
-%
-e = ones(n_ap, 1);
-d2 = [e(1:n_ap-1); 0];
-H = spdiags([-d2, e], 0:1, n_ap-1, n_ap);
-I = speye(n_ap);
-RegMatrix = [kron(I,H);kron(H,I)];
\ No newline at end of file
diff --git a/Generator/library/FourierShift2D.m b/Generator/library/FourierShift2D.m
deleted file mode 100644
index 000ccce..0000000
--- a/Generator/library/FourierShift2D.m
+++ /dev/null
@@ -1,44 +0,0 @@
-function y = FourierShift2D(x, delta)
-%
-% y = FourierShift(x, [delta_x delta_y])
-%
-% Shifts x by delta cyclically. Uses the fourier shift theorem.
-%
-% Real inputs should give real outputs.
-%
-% By Tim Hutt, 26/03/2009
-% Small fix thanks to Brian Krause, 11/02/2010
-
-% The size of the matrix.
-[N, M] = size(x);
-
-% FFT of our possibly padded input signal.
-X = fft2(x);
-
-% The mathsy bit. The floors take care of odd-length signals.
-x_shift = exp(-i * 2 * pi * delta(1) * [0:floor(N/2)-1 floor(-N/2):-1]' / N);
-y_shift = exp(-i * 2 * pi * delta(2) * [0:floor(M/2)-1 floor(-M/2):-1] / M);
-
-
-% Force conjugate symmetry. Otherwise this frequency component has no
-% corresponding negative frequency to cancel out its imaginary part.
-if mod(N, 2) == 0
-	x_shift(N/2+1) = real(x_shift(N/2+1));
-end 
-if mod(M, 2) == 0
-	y_shift(M/2+1) = real(y_shift(M/2+1));
-end
-
-
-Y = X .* (x_shift * y_shift);
-
-% Invert the FFT.
-y = ifft2(Y);
-
-% There should be no imaginary component (for real input
-% signals) but due to numerical effects some remnants remain.
-if isreal(x)
-    y = real(y);
-end
-
-end
\ No newline at end of file
diff --git a/Generator/library/FrameSelectionTools/FindCorner.m b/Generator/library/FrameSelectionTools/FindCorner.m
deleted file mode 100755
index 5de1317..0000000
--- a/Generator/library/FrameSelectionTools/FindCorner.m
+++ /dev/null
@@ -1,59 +0,0 @@
-function [x_c, y_c, y] = FindCorner(x, y)
-%
-%  Find the first point of maximum curvature of a set of data.
-%
-
-x = x(:);
-y = y(:);
-
-% First performa a local smoothing of y-data
-y = smooth_moving(y,4);
-%y = smooth(y,4);
-
-%
-% Now fit a order 4 spline to the smoothed data
-%
-n = length(x);
-pp = spline(x,y);
-
-%
-%  Extract abscissa and ordinate splines and differentiat them.
-%  Compute the function values as default in spleval.
-P     = spleval(pp);  dpp   = fnder_spline(pp);
-D     = spleval(dpp); ddpp  = fnder_spline(pp,2);
-DD    = spleval(ddpp);
-ppx   = P(1,:);       ppy   = P(2,:);
-dppx  = D(1,:);       dppy  = D(2,:);
-ddppx = DD(1,:);      ddppy = DD(2,:);
-
-% Compute the corner of the discretized .spline curve via max. curvature.
-% Define curvature = 0 where both dppx and dppy are zero.
-k1    = dppx.*ddppy - ddppx.*dppy;
-k2    = (dppx.^2 + dppy.^2).^(1.5);
-I_nz  = find(k2 ~= 0);
-kappa = zeros(1,length(dppx));
-kappa(I_nz) = -k1(I_nz)./k2(I_nz);
-[kmax,ikmax] = max(kappa);
-x_corner = ppx(ikmax); 
-y_corner = ppy(ikmax);
-
-% Locate the point on the discrete L-curve which is closest to the
-% corner of the spline curve. If the curvature is negative everywhere,
-% then define the leftmost point of the L-curve as the corner.
-if (kmax < 0)
-  x_c = x(n); y_c = y(n);
-else
-  index = find(x < x_corner & y < y_corner);
-  if (length(index) > 0)
-    [dummy,rpi] = min((x(index)-x_corner).^2 + (y(index)-y_corner).^2);
-    rpi = index(rpi);
-  else
-    [dummy,rpi] = min((x-x_corner).^2 + (y-y_corner).^2);
-  end
-  x_c = x(rpi); y_c = y(rpi);
-end
-% 
-% figure(1), clf
-% plot(x, y, 'LineWidth', 2)
-% hold on
-% plot(x_c, y_c, 'ro', 'LineWidth', 2)
\ No newline at end of file
diff --git a/Generator/library/FrameSelectionTools/SelectFrames.m b/Generator/library/FrameSelectionTools/SelectFrames.m
deleted file mode 100755
index a459d4b..0000000
--- a/Generator/library/FrameSelectionTools/SelectFrames.m
+++ /dev/null
@@ -1,124 +0,0 @@
-function [selected_idx, g_sorted_all, g_selected, g_power, g_SNR_mask] = SelectFrames(g, p)
-%
-%  This function will sort a set of image data frames in order of 
-%  highest fill in the Fourier plane. The cumulative fill factor of the 
-%  Fourier plane is shown against each frame in the ordered list. The 
-%  user can decide on the trade off between fill factor and number of 
-%  frames.
-%
-% Input:   g - stack of image frames, stored in a 3D array
-%
-% Optional Input:
-%          p - scalar, 0 <= p <= 1, specifies percent of fill
-%              in Fourier plane. Default value is p = 1.
-%
-% Output:  selected_idx - index of selected frames
-%          g_selected   - these are the selected frames, in the order
-%                         given by frame_idx.  That is, 
-%                            g_selected = g(frame_idx)
-%
-% Optional Output:
-%          g_sorted_all - ordered stack of all input image frames
-%          g_power      - power spectrum of g, scaled by noise level
-%          g_SNR_mask   - mask used to determine Fourier plane
-%
-%
-
-% Set default input values, and get some parameters
-if nargin == 1
-  p = 1;
-end
-n_frames = size(g,3);
-n_row = size(g,1);
-
-%
-%  First compute the power spectrum, and fftshift.  Before doing this,
-%  though, scale so that the max pixel value of each frame is 1.
-%
-g_power = zeros(size(g));
-for k = 1:n_frames
-  tt = g(:,:,k)/max(max(g(:,:,k)));
-  g_power(:,:,k) = fftshift(abs(fft2(tt)).^2);
-end
-
-%
-%  Now we need to estimate the noise level, and get the SNR of each 
-%  pixel in each image frame.
-%
-%  To get an estimate of the noise, use the corners of the image
-%  frames.  To get the corners, we use a circular mask and then find
-%  the mean of pixels outside the circular mask.
-%
-%  Then divide each frame by these mean values -- this gives us an
-%  SNR for each pixel in each frame.
-%
-n_row = size(g_power,1);
-
-Corner_Mask = MakeMask(n_row, 1);
-Corner_Mask = Corner_Mask(:,:,ones(1,n_frames));
-g_power_Masked = ~Corner_Mask.*g_power;
-g_SNR = zeros(size(g));
-for k = 1:n_frames
-  g_power_Masked_k = g_power_Masked(:,:,k);
-  NoiseEst_frame_k = mean(g_power_Masked_k(g_power_Masked_k~=0));
-  nn(k,1) = NoiseEst_frame_k;
-  g_SNR(:,:,k) = g_power(:,:,k)/NoiseEst_frame_k;
-end
-%
-%  Now find mask for the object.  
-%
-%  For this part, first sum all data frames to get a "mean" SNR image
-%  (dividing by the number of image isn't necessary to get a true mean)
-%
-g_SNR = Corner_Mask.*g_SNR;
-g_SNR_sum = sum(g_SNR, 3);
-%
-%  Next we need to find a threshold for the mask.  We do this by
-%  sorting pixels in the mean SNR image, and determine where these
-%  values flatten out.  That is, we try to find a point of maximum
-%  curvature.  To find this "corner" point, we use a technique very
-%  similar to what is done for L-curve regularization (see the m-file
-%  FindCorner.m for more information).
-%
-v = sort(g_SNR_sum(:),'descend');
-[x_c, y_c] = FindCorner(1:length(v), log(v+1));
-
-%threshold = exp(y_c-1);
-threshold = exp(y_c)-1;
-g_SNR_mask = g_SNR_sum;
-g_SNR_mask(g_SNR_sum<=threshold) = 0;
-g_SNR_mask(g_SNR_mask>0) = 1;
-g_SNR_mask_all = g_SNR_mask(:,:,ones(1,n_frames));
-
-g_SNR = g_SNR_mask_all.*g_SNR;
-
-Sort_Mask = zeros(size(g_SNR));
-
-max_SNR = max(g_SNR,[],3);
-for k = 1:n_frames
-  Sort_Mask(:,:,k) = max_SNR == g_SNR(:,:,k);
-end
-Sort_Mask = g_SNR_mask_all.*Sort_Mask;
-
-nonzeros = zeros(n_frames,1);
-for k = 1:n_frames
-  nonzeros(k,1) = sum(sum(Sort_Mask(:,:,k)));
-end
-
-%
-% Sort by number of nonzeros in Sort_Mask
-%
-[s, sidx] = sort(nonzeros,'descend');
-g_sorted_all = g(:,:,sidx);
-Sort_Mask = Sort_Mask(:,:,sidx);
-
-num_pixels = sum(g_SNR_mask(:));
-sum_pixels = 0;
-for k = 1:n_frames
-  sum_pixels = sum_pixels + sum(sum(Sort_Mask(:,:,k)));
-  if sum_pixels >= p*num_pixels;
-    break
-  end
-end
-g_selected = g_sorted_all(:,:,1:k);
-selected_idx = sidx(1:k);
\ No newline at end of file
diff --git a/Generator/library/FrameSelectionTools/fnder_spline.m b/Generator/library/FrameSelectionTools/fnder_spline.m
deleted file mode 100755
index 1d1ff56..0000000
--- a/Generator/library/FrameSelectionTools/fnder_spline.m
+++ /dev/null
@@ -1,35 +0,0 @@
-function dpp = fnder_spline(pp, d)
-%
-%  Find the d'th derivative of a cubic spline.
-%  If d is not specified, find the first derivative.
-%
-
-if nargin == 1
-  d = 1;
-end
-
-if d < 0
-  error('d must be >= 0')
-end
-switch d
-  case 0
-    dpp = pp
-  case 1
-    [xb, pp_coef] = unmkpp(pp);
-    dpp_coef = [3*pp_coef(:,1), 2*pp_coef(:,2), pp_coef(:,3)];
-    dpp = mkpp(xb, dpp_coef);
-  case 2
-    [xb, pp_coef] = unmkpp(pp);
-    dpp_coef = [6*pp_coef(:,1), 2*pp_coef(:,2)];
-    dpp = mkpp(xb, dpp_coef);
-  case 3
-    [xb, pp_coef] = unmkpp(pp);
-    dpp_coef = 6*pp_coef(:,1);
-    dpp = mkpp(xb, dpp_coef);
-  otherwise
-    [xb, pp_coef] = unmkpp(pp);
-    dpp_coef = zeros(size(pp_coef,1));
-    dpp = mkpp(xb, dpp_coef);
-end
-
-
diff --git a/Generator/library/FrameSelectionTools/smooth_moving.m b/Generator/library/FrameSelectionTools/smooth_moving.m
deleted file mode 100755
index fd31a51..0000000
--- a/Generator/library/FrameSelectionTools/smooth_moving.m
+++ /dev/null
@@ -1,22 +0,0 @@
-function y=smooth_moving(x,m) 
-
-% y = smooth_moving(x,m)
-%       x 	is the input vector (or matrix) to be smoothed. 
-%       m 	is number of points to average over (best odd, but even works)
-%       y 	is output vector of same length as x
-%
-% directly replaces the smooth.m from the Curvefitting toolbox
-%
-
-f=zeros(m,1)+1/m;
-n=size(x,1);
-isodd=bitand(m,1);
-m2=floor(m/2);
-
-y=filter(f,1,x);
-y=y([zeros(1,m2-1+isodd)+m,m:n,zeros(1,m2)+n]);
-
-for k=1:m2
-   y(k) = mean(x(1:k*2-1));
-   y(end-k+1) = mean(x(end-k*2+2:end));
-end
\ No newline at end of file
diff --git a/Generator/library/FrameSelectionTools/spleval.m b/Generator/library/FrameSelectionTools/spleval.m
deleted file mode 100755
index 1dabcdb..0000000
--- a/Generator/library/FrameSelectionTools/spleval.m
+++ /dev/null
@@ -1,19 +0,0 @@
-function points = spleval(f) 
-%SPLEVAL Evaluation of a spline or spline curve. 
-% 
-% points = spleval(f) 
-% 
-% Computes points on the given spline or spline curve f between 
-% its extreme breaks. 
- 
-% Original routine fnplt by C. de Boor / latest change: Oct. 25, 1997 
-% Simplified by Per Christian Hansen, IMM, 04/16/98. 
- 
-% Set default number of points. 
-npoints = 300; 
-  
-[breaks,coefs,l,k,d] = unmkpp(f);
-x = breaks(1) + [0:npoints]*((breaks(l+1)-breaks(1))/npoints); 
-v=ppval(f,x); 
- 
-if (d==1), points=[x;v]; else, points = v; end 
diff --git a/Generator/library/GetCompositeMask.m b/Generator/library/GetCompositeMask.m
deleted file mode 100644
index b2ef9ac..0000000
--- a/Generator/library/GetCompositeMask.m
+++ /dev/null
@@ -1,57 +0,0 @@
-function pupil_maskC = GetCompositeMask(A, pupil_mask, n_comp, n_comp_pad, n_frames, n_layers)
-%
-%  pupil_maskC = GetCompositeMask(pupil_mask, wind_vecs, ssp, n_ap, ...
-%        n_comp, n_comp_pad, n_frames, n_layers);
-%
-%  This function comptues the mask of the composit grid.
-%
-%  Input:
-%    A           - matrix that defines the motion of the various layers
-%    pupil_mask  - pupil mask
-%    n_comp      - size of composite grid
-%    n_comp_pad  - size of padding to get from n_ap to n_comp
-%                  (see GetCompositeGridSize.m)
-%    n_frames    - number of frames of data
-%    n_layers    - number of atmospheric layers
-%
-%  Output:
-%    pupil_maskC - 3D logical array containing mask for composite
-%                  information (phases and gradients) on leach layer.
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%  Modified April, 2016 to reduce memory requirements.
-%
-
-%
-%    * Start with the pupil mask on the composite grid.
-%    * Move the pupil mask across the composite grid
-%    * BUT make sure that the pupil mask moves in the opposite 
-%      direction as the sky.  This done by adding pi to the
-%      angle of the wind vectors.
-%
-%if length(ssp) == 1
-%    ssp = [ssp, ssp];
-%end
-%deltax2 = ssp(2)*wind_vecs(:,1) .* cos(pi+wind_vecs(:,2));
-%deltay2 = ssp(1)*wind_vecs(:,1) .* sin(pi+wind_vecs(:,2));
-%A2 = MotionMatrix(deltax2, deltay2, n_comp, n_ap, n_frames);
-pupil_mask_pad = padarray(pupil_mask, [n_comp_pad,n_comp_pad],'both');
-N = n_comp*n_comp;
-v = kron(speye(n_layers),pupil_mask_pad(:));
-%v = full(A2*v);
-%
-%  Instead of creating a new matrix that does the motion in the opposite
-%  direction, let's move in the given direction, then rotate the result.
-%  This will avoid having to create another large matrix.
-%
-v = full(A*v);
-v = reshape(v, N, n_frames, n_layers);
-for k = 1:n_layers
-%   v(:,:,k) = transpose(rot90(transpose(v),2));
-   v(:,:,k) = transpose(rot90(transpose(v(:,:,k)),2));
-
-end
-pupil_maskC = reshape(squeeze(sum(v, 2) > 0),n_comp,n_comp,n_layers);
diff --git a/Generator/library/GetPupilDiams.m b/Generator/library/GetPupilDiams.m
deleted file mode 100644
index 79a9c05..0000000
--- a/Generator/library/GetPupilDiams.m
+++ /dev/null
@@ -1,62 +0,0 @@
-function pupild = GetPupilDiams(lambda0, dlambda, pupil0, nColors)
-%
-%  lambda0 = starting wavelength of observation in microns (wavelength of phvars)
-%            Default: 0.750
-%  dlambda = optical bandwidth
-%            Default: 0.3
-%  pupil0  = diameter of pupil at wavelength lambda0
-%            Default: 192
-%  nColors = number of wavelengths.
-%            Default: 13
-%
-
-%
-% Check input parameters, and set default values if necessary:
-%
-if nargin == 0, lambda0=[]; dlambda=[]; pupil0=[]; nColors=[]; end
-if nargin == 1, dlambda=[]; pupil0=[]; nColors=[]; end
-if nargin == 2, pupil0=[]; nColors=[]; end
-if nargin == 3, nColors=[]; end
-if isempty(lambda0), lambda0 = 0.75; end
-if isempty(dlambda), dlambda = 0.3; end
-if isempty(pupil0), pupil0 = 192; end
-if isempty(nColors), nColors = 13; end
-
-pupil_max = (1+dlambda/(2*lambda0))*pupil0;
-
-
-if mod(pupil0,2)==0
-    pupil_max = 2*round(pupil_max/2);
-else
-    pupil_max = 2*round(pupil_max/2)+1;
-end
-
-pupil_min = (1 - dlambda/(2*lambda0))*pupil0;
-if mod(pupil0,2)==0
-    pupil_min = 2*round(pupil_min/2);
-else
-    pupil_min = 2*round(pupil_min/2)+1;
-end
-% 
-% 
-% pupil_max = 2*round(pupil_max/2);
-% 
-% pupil_min = (1-dlambda/(2*lambda0))*pupil0;
-% pupil_min = 2*round(pupil_min/2);
-
-pupild = pupil_min:2:pupil_max;
-
-idx0 = find(pupild == pupil0);
-% pupild = 125;
-return
-
-idx = round(linspace(1, length(pupild), nColors));
-if ~any(idx(:) == idx0)
-%  warning('pupil diameter spacing strange -- trying to fix')
-  idx(round(length(idx)/2)) = idx0;
-end
-pupild = pupild(idx);
-
-
-
-
diff --git a/Generator/library/GradientReconTools/._AffineTransform.m b/Generator/library/GradientReconTools/._AffineTransform.m
deleted file mode 100755
index 115074d..0000000
Binary files a/Generator/library/GradientReconTools/._AffineTransform.m and /dev/null differ
diff --git a/Generator/library/GradientReconTools/._BuildInterpMatrix.m b/Generator/library/GradientReconTools/._BuildInterpMatrix.m
deleted file mode 100755
index 6a569c9..0000000
Binary files a/Generator/library/GradientReconTools/._BuildInterpMatrix.m and /dev/null differ
diff --git a/Generator/library/GradientReconTools/._GetCompositeGridSize.m b/Generator/library/GradientReconTools/._GetCompositeGridSize.m
deleted file mode 100755
index bd90d5f..0000000
Binary files a/Generator/library/GradientReconTools/._GetCompositeGridSize.m and /dev/null differ
diff --git a/Generator/library/GradientReconTools/._GetCompositeGridSizes.m b/Generator/library/GradientReconTools/._GetCompositeGridSizes.m
deleted file mode 100644
index bd90d5f..0000000
Binary files a/Generator/library/GradientReconTools/._GetCompositeGridSizes.m and /dev/null differ
diff --git a/Generator/library/GradientReconTools/._GetCompositeMask.m b/Generator/library/GradientReconTools/._GetCompositeMask.m
deleted file mode 100644
index 2373067..0000000
Binary files a/Generator/library/GradientReconTools/._GetCompositeMask.m and /dev/null differ
diff --git a/Generator/library/GradientReconTools/._GetPixelCenters2D.m b/Generator/library/GradientReconTools/._GetPixelCenters2D.m
deleted file mode 100755
index 6a569c9..0000000
Binary files a/Generator/library/GradientReconTools/._GetPixelCenters2D.m and /dev/null differ
diff --git a/Generator/library/GradientReconTools/._MotionMatrix.m b/Generator/library/GradientReconTools/._MotionMatrix.m
deleted file mode 100755
index 115074d..0000000
Binary files a/Generator/library/GradientReconTools/._MotionMatrix.m and /dev/null differ
diff --git a/Generator/library/GradientReconTools/._ScaleXY.m b/Generator/library/GradientReconTools/._ScaleXY.m
deleted file mode 100755
index 23f6476..0000000
Binary files a/Generator/library/GradientReconTools/._ScaleXY.m and /dev/null differ
diff --git a/Generator/library/GradientReconTools/._SpaceToMidx2D.m b/Generator/library/GradientReconTools/._SpaceToMidx2D.m
deleted file mode 100755
index 6a569c9..0000000
Binary files a/Generator/library/GradientReconTools/._SpaceToMidx2D.m and /dev/null differ
diff --git a/Generator/library/GradientReconTools/._SubsampleMatrix.m b/Generator/library/GradientReconTools/._SubsampleMatrix.m
deleted file mode 100755
index 115074d..0000000
Binary files a/Generator/library/GradientReconTools/._SubsampleMatrix.m and /dev/null differ
diff --git a/Generator/library/GradientReconTools/._TransformCoordinates2D.m b/Generator/library/GradientReconTools/._TransformCoordinates2D.m
deleted file mode 100755
index 6a569c9..0000000
Binary files a/Generator/library/GradientReconTools/._TransformCoordinates2D.m and /dev/null differ
diff --git a/Generator/library/GradientReconTools/._WindowMatrix.m b/Generator/library/GradientReconTools/._WindowMatrix.m
deleted file mode 100755
index 115074d..0000000
Binary files a/Generator/library/GradientReconTools/._WindowMatrix.m and /dev/null differ
diff --git a/Generator/library/GradientReconTools/AffineTransform.m b/Generator/library/GradientReconTools/AffineTransform.m
deleted file mode 100755
index 0993e99..0000000
--- a/Generator/library/GradientReconTools/AffineTransform.m
+++ /dev/null
@@ -1,146 +0,0 @@
-function T = AffineTransform(n_ap, n_frames, deltax, deltay)
-%
-%    T = AffineTransform(n_ap, n_frames, deltax, deltay);
-%
-%  This function generates affine tranformations from given motion data.
-%
-%  Input: 
-%   n_ap       - number of pixels across the aperture (diameter)
-%   n_frames   - number of frames
-%   deltax     - motion information of each of the layers; number of
-%                high resolution pixels shifting in x - direction.
-%   deltay     - motion information of each of the layers; number of
-%                high resolution pixels shifting in y - direction.
-%
-%  Output:
-%   T          - affine tranformations
-%
-
-%
-%  Remark: We could include rotation in this as well, but for now we
-%          only implement only shifts. If later we want to include
-%          rotations, then we will need to edit this code as follows:
-%          * include an additional input: delta_theta
-%          * uncomment the lines below that pertain to rotation
-%
-
-n_layers = size(deltax,1);
-
-if size(deltax,2) > 1
-  % The velocity is not constant, so this should be n_frames-1 in
-  % length
-  if size(deltax,2) ~= n_frames-1
-    error('incorrect deltax for nonconstant velocity')
-  end
-  deltax_vec = deltax;
-else
-  deltax_vec = deltax(:,ones(1,n_frames-1));
-end
-if size(deltay,2) > 1
-  % The velocity is not constant, so this should be n_frames-1 in
-  % length
-  if size(deltay,2) ~= n_frames-1
-    error('incorrect deltay for nonconstant velocity')
-  end
-  deltay_vec = deltay;
-else
-  deltay_vec = deltay(:,ones(1,n_frames-1));
-end
-%----------------------------------
-% ROTATION STATMENTS:
-%
-% If we edit this code to allow for rotation, uncomment the following:
-%
-%if size(delta_theta,2) > 1
-%  % The velocity is not constant, so this should be n_frames-1 in
-%  % length
-%  if size(delta_theta,2) ~= n_frames-1
-%    error('incorrect delta_theta for nonconstant velocity')
-%  end
-%  delta_theta_vec = delta_theta;
-%else
-%  delta_theta_vec = delta_theta(:,ones(1,n_frames-1));
-%end
-%
-%----------------------------------
-
-T = zeros(3, 3, n_frames, n_layers);
-
-for L = 1:n_layers
-  %
-  %  The first frame is the reference frame, so the affine transformation
-  %  should be the identity.
-  %
-  T(:,:,1,L) = eye(3);
-  
-  for k = 2:n_frames
-    dx = sum(deltax_vec(L,1:k-1)); % the shifting = integral of velocity * delta_time
-    dy = sum(deltay_vec(L,1:k-1));
-    %----------------------------------
-    % ROTATION CODES: If we want to use rotations, uncomment this line:
-    %
-    % theta = sum(delta_theta_vec(L,1:k-1));
-    %
-    %----------------------------------
-        
-    %
-    % Get spatial coordinates of center points of pixels:
-    %   Note: If we assume the image is defined on a standard Euclidean
-    %         coordinate system:
-    %
-    %              y ^
-    %                |
-    %                |
-    %                |-------->
-    %                         x
-    %
-    %          then an affine
-        
-    %
-    % Now shift the coordinate system:
-    % Create affine transformation to do the shifting of coordinates:
-    % Note: According to our coordinate system, dx > 0 means move right,
-    %       and dy > 0 means moves up.
-    %
-    % The affine transformation for this is:
-    %
-    T_shift = [1 0 0; 0 1 0; -dx -dy 1];
-
-    %----------------------------------
-    % ROTATION CODES: If we want to include rotation, uncomment these lines
-    %
-    % % Now consider a rotation about the center of the image.
-    % %  Rotation is clockwise by an angle theta.
-    % %  and that the center of rotation is the point ((n+1)/2, (m+1)/2)
-    % %  where the image is m-by-n pixels.
-    % %
-    % %  Note that standard rotation is about (0,0).  So we first need
-    % %  to shift the center of the image to the coordinate (0,0), then
-    % %  rotate, then shift back.
-    % %
-    % %  Shfit to (0,0):
-    % %
-    % SL = [1 0 0;0 1 0;-(n-1)/2 -(n_ap-1)/2 1];
-    % %  Rotate by angle theta.
-    % TR = [cos(theta), sin(theta), 0;-sin(theta), cos(theta), 0; 0, 0, 1];
-    % %  Now shift back.
-    % SR = [1 0 0;0 1 0; (n-1)/2,  (m-1)/2, 1];
-    % % The combined transformation is:
-    % T_rot_center = SL*TR*SR;
-    %
-    %----------------------------------
-    %
-    % ROTATION CODES: If we want to includ rotation, comment out this
-    %                 next line:
-    %
-    T_rot_center = eye(3);
-    %
-    %----------------------------------
-    %
-    %  Finally, the combined tranformation that shifts and rotates about
-    %  center is:
-    %
-    T(:,:,k,L) = T_shift * T_rot_center;
-    %   
-  end
-end
diff --git a/Generator/library/GradientReconTools/BuildInterpMatrix.m b/Generator/library/GradientReconTools/BuildInterpMatrix.m
deleted file mode 100755
index ba2111a..0000000
--- a/Generator/library/GradientReconTools/BuildInterpMatrix.m
+++ /dev/null
@@ -1,77 +0,0 @@
-function S = BuildInterpMatrix(I, J, m, n)
-%
-%  Given pixel coordinates, (I,J) = (row, col), which
-%  are not necessarily integers, this function computes
-%  an interpolation matrix S so that y = S*x interpolates
-%  pixel values in the image x to give pixel values in
-%  the image y.
-%
-%  Here we use linear interpolation.
-%
-%  Input:
-%    I and J are arrays of size m-by-n (same as image dimensions).
-%       These contain coordinates of an image transformation.
-%    m, n is the size of the image.
-%
-%  Output:
-%    S is a sparse matrix
-%
-
-% First find integer coordinates that surround each
-% (I(i,j),J(i,j))
-% These will be the bilinear interpolation coordinates.
-%
-i0 = floor(I(:));
-i1 = ceil(I(:));
-j0 = floor(J(:));
-j1 = ceil(J(:));
-
-i1 = i0+1;
-j1 = j0+1;
-
-%
-% To avoid playing games with indices, we are very sloppy
-% around the border.  Interpolation is only done if ALL of the
-% points that surround (I(i,j),J(i,j)) are within the image
-% boarders.  This makes it easier to compute the interpolation
-% weights without having to use special conditions near
-% the borders.  If we assume black areas near the border,
-% then this should not cause any problems.
-%
-% The first step, then, is to find the rows that will contain
-% weights.
-%
-row_idx = find(1<=i0 & i1<=m & 1<=j0 & j1<=n);
-i = [row_idx; row_idx; row_idx; row_idx];
-
-% Since we only consider interior pixel values, then each
-% row will have exactly four weights.  So next we find the
-% four column indices where these weights should be put.
-% We are assuming column ordering of the image.
-%
-i0 = i0(row_idx);, i1 = i1(row_idx);, j0 = j0(row_idx);, j1 = j1(row_idx);
-
-col_idx1 = i0 + m*(j0-1);
-col_idx2 = i1 + m*(j0-1);
-col_idx3 = i0 + m*(j1-1);
-col_idx4 = i1 + m*(j1-1);
-j = [col_idx1; col_idx2; col_idx3; col_idx4];
-
-%
-% Now we compute the weights that go into the matrix.
-%
-deltai = I(row_idx) - i0;
-deltaj = J(row_idx) - j0;
-w1 = (1 - deltai).*(1 - deltaj);
-w2 = (1 - deltaj).*deltai;
-w3 = (1 - deltai).*deltaj;
-w4 = deltai.*deltaj;
-s = [w1; w2; w3; w4];
-
-
-%
-% Now let's put the weights in the sparse matrix.
-%
-S = sparse(i, j, s, m*n, m*n);
-
-
diff --git a/Generator/library/GradientReconTools/GetCompositeGridSize.m b/Generator/library/GradientReconTools/GetCompositeGridSize.m
deleted file mode 100755
index 6b38a8d..0000000
--- a/Generator/library/GradientReconTools/GetCompositeGridSize.m
+++ /dev/null
@@ -1,30 +0,0 @@
-function [n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay)
-%
-%  [n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay);
-%  
-% This function computes the grid size needed to store the composite
-% high resolution gradients and phases.
-%
-% Input:
-%   n_ap       - number of pixels across the aperture (diameter)
-%   n_frames   - number of frames
-%   deltax     - motion information of each of the layers; number of
-%                high resolution pixels shifting in x - direction.
-%   deltay     - motion information of each of the layers; number of
-%                high resolution pixels shifting in y - direction.
-%
-% Output:
-%   n_comp     - composit grid size
-%   n_comp_pad - amount the aperture needs to be padded to get to the
-%                composite grid size
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-n_comp_pad = max( max( ceil( abs([deltax, deltay])*n_frames ) ) );
-n_comp = n_ap + 2*n_comp_pad;
-
-
diff --git a/Generator/library/GradientReconTools/GetCompositeGridSizes.m b/Generator/library/GradientReconTools/GetCompositeGridSizes.m
deleted file mode 100644
index 87e6a0d..0000000
--- a/Generator/library/GradientReconTools/GetCompositeGridSizes.m
+++ /dev/null
@@ -1,58 +0,0 @@
-function [n_comp, n_comp_pad] = GetCompositeGridSizes(n_ap, n_WFS_frames, wind_vecs, ssp)
-%
-%  n_comp = GetCompositeGridSizes(n_ap, n_WFS_frames, wind_vecs);
-%  
-% This function computes the grid sizes needed to store the composite
-% high resolution gradients and phases for a set of FFM frames.
-%
-% Input:
-%   n_ap         - number of pixels across the aperture (diameter)
-%   n_WFS_frames - vector containing the number of frames used for each
-%                  FFM reconstruction
-%   wind_vecs    - 2D double array that specifies angle (theta) and 
-%                  magnitude (r) of wind velocity for each layer:
-%                      wind_vecs(L,1) = r   
-%                      wind_vecs(L,2) = theta 
-%                  L = 1, 2, ..., n_layers.
-%       ssp      - subsample parameter
-%                          Modified November, 2015, to allow non square 
-%                          subapertures. (J. Nagy) So now, ssp can
-%                          be a scalar (equal diameters in both directions)
-%                          or a 1-by-2 array, [ssp_rows, ssp_cols]
-%
-% Output:
-%   n_comp     - vector containing composite grid sizes
-%   n_comp_pad - amount the aperture needs to be padded to get to the
-%                composite grid sizes
-%
-
-%
-%  J. Nagy
-%  October, 2013
-%
-
-%
-%  Convert wind_vecs into pixel shif\t values:
-%
-%
-%  Modified November, 2015, to allow non square subapertures.
-%  J. Nagy
-%
-%
-%  Modified November, 2015, to allow non square subapertures.
-%  J. Nagy
-%
-if length(ssp) == 1
-    ssp = [ssp, ssp];
-end
-deltax = ssp(2)*wind_vecs(:,1) .* cos(wind_vecs(:,2));
-deltay = ssp(1)*wind_vecs(:,1) .* sin(wind_vecs(:,2));
-nframes = length(n_WFS_frames);
-n_comp = zeros(nframes,1);
-for k = 1:nframes
-  %
-  %  We need to find a composite grid size, and the amount of padding needed
-  %  to get from n_ap to n_conmp.  
-  %
-  [n_comp(k), n_comp_pad] = GetCompositeGridSize(n_ap, n_WFS_frames(k), deltax, deltay);
-end
\ No newline at end of file
diff --git a/Generator/library/GradientReconTools/GetCompositeMask.m b/Generator/library/GradientReconTools/GetCompositeMask.m
deleted file mode 100644
index b2ef9ac..0000000
--- a/Generator/library/GradientReconTools/GetCompositeMask.m
+++ /dev/null
@@ -1,57 +0,0 @@
-function pupil_maskC = GetCompositeMask(A, pupil_mask, n_comp, n_comp_pad, n_frames, n_layers)
-%
-%  pupil_maskC = GetCompositeMask(pupil_mask, wind_vecs, ssp, n_ap, ...
-%        n_comp, n_comp_pad, n_frames, n_layers);
-%
-%  This function comptues the mask of the composit grid.
-%
-%  Input:
-%    A           - matrix that defines the motion of the various layers
-%    pupil_mask  - pupil mask
-%    n_comp      - size of composite grid
-%    n_comp_pad  - size of padding to get from n_ap to n_comp
-%                  (see GetCompositeGridSize.m)
-%    n_frames    - number of frames of data
-%    n_layers    - number of atmospheric layers
-%
-%  Output:
-%    pupil_maskC - 3D logical array containing mask for composite
-%                  information (phases and gradients) on leach layer.
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%  Modified April, 2016 to reduce memory requirements.
-%
-
-%
-%    * Start with the pupil mask on the composite grid.
-%    * Move the pupil mask across the composite grid
-%    * BUT make sure that the pupil mask moves in the opposite 
-%      direction as the sky.  This done by adding pi to the
-%      angle of the wind vectors.
-%
-%if length(ssp) == 1
-%    ssp = [ssp, ssp];
-%end
-%deltax2 = ssp(2)*wind_vecs(:,1) .* cos(pi+wind_vecs(:,2));
-%deltay2 = ssp(1)*wind_vecs(:,1) .* sin(pi+wind_vecs(:,2));
-%A2 = MotionMatrix(deltax2, deltay2, n_comp, n_ap, n_frames);
-pupil_mask_pad = padarray(pupil_mask, [n_comp_pad,n_comp_pad],'both');
-N = n_comp*n_comp;
-v = kron(speye(n_layers),pupil_mask_pad(:));
-%v = full(A2*v);
-%
-%  Instead of creating a new matrix that does the motion in the opposite
-%  direction, let's move in the given direction, then rotate the result.
-%  This will avoid having to create another large matrix.
-%
-v = full(A*v);
-v = reshape(v, N, n_frames, n_layers);
-for k = 1:n_layers
-%   v(:,:,k) = transpose(rot90(transpose(v),2));
-   v(:,:,k) = transpose(rot90(transpose(v(:,:,k)),2));
-
-end
-pupil_maskC = reshape(squeeze(sum(v, 2) > 0),n_comp,n_comp,n_layers);
diff --git a/Generator/library/GradientReconTools/GetPixelCenters2D.m b/Generator/library/GradientReconTools/GetPixelCenters2D.m
deleted file mode 100755
index 959b55d..0000000
--- a/Generator/library/GradientReconTools/GetPixelCenters2D.m
+++ /dev/null
@@ -1,23 +0,0 @@
-function [X, Y] = GetPixelCenters2D(m,n)
-%
-%           [X, Y] = GetPixelCenters(m,n);
-%
-%  Find the (x,y) coordinates of the centers of pixels of an image.
-%  NOTE:  Here it is assumed that the image boundaries are defined by the
-%         standard Euclidean coordinate system:
-%              y ^
-%                |
-%                |
-%                |-------->
-%                         x
-%         and the centers of the pixels are given at (x,y), where
-%         x = 0, 1, 2, ..., n-1, 
-%         y = 0, 1, 2, ..., m-1
-%
-%  Input:  m, n = dimension of the image
-%
-%  Output: X = x-coordinates of centers of the pixels
-%          Y = y-coordinates of centers of the pixels
-%
-
-[X, Y] = meshgrid(0:n-1, m-1:-1:0);
\ No newline at end of file
diff --git a/Generator/library/GradientReconTools/MotionMatrix.m b/Generator/library/GradientReconTools/MotionMatrix.m
deleted file mode 100755
index 3d78343..0000000
--- a/Generator/library/GradientReconTools/MotionMatrix.m
+++ /dev/null
@@ -1,66 +0,0 @@
-function A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames)
-%
-%     A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames);
-%
-%  Use the motion information, as given by deltax and deltay,
-%  to create a sparse matrix that, when multiplied to the large 
-%  global wavefront (or gradient fields) will move them to get the
-%  wavefronts (or gradient fields) in the position corresponding to
-%  each frame.
-%
-%  Input:
-%   deltax     - motion information of each of the layers; number of
-%                high resolution pixels shifting in x - direction.
-%   deltay     - motion information of each of the layers; number of
-%                high resolution pixels shifting in y - direction.
-%   n_comp     - composit grid size
-%   n_ap       - number of pixels across the aperture (diameter)
-%   n_frames   - number of frames
-%
-%  Output:
-%   A          - sparse matrix
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-n_layers = size(deltax,1);
-
-%
-%  Get affine transformations for the motion:
-%
-T = AffineTransform(n_ap, n_frames, deltax, deltay);
-
-A = [];
-for L = 1:n_layers 
-  %
-  % Get pixel centers of composite image.
-  %
-  [X, Y] = GetPixelCenters2D(n_comp, n_comp);
-
-  AA = [];
-  %h = waitbar(0, sprintf('Building motion matrices for layer %d', L));
-  for k = 1:n_frames
-    %
-    %  Use affine transfromation to transfrom coordinates:
-    %
-    [Xnew, Ynew] = TransformCoordinates2D(T(:,:,k,L), X, Y);
- 
-    %
-    %  Get MATLAB indices corresponding to these new coordinates:
-    %
-    [I, J] = SpaceToMidx2D(Xnew, Ynew);
-  
-    %
-    % Now build the sparse matrix that does the geometric
-    % transformation on the image.
-    %
-    S = BuildInterpMatrix(I, J, n_comp, n_comp);
-    AA = [AA; S];
-    
-    %waitbar(k/n_frames)
-  end
-  %close(h)
-  A = [A, AA];
-end
diff --git a/Generator/library/GradientReconTools/ScaleXY.m b/Generator/library/GradientReconTools/ScaleXY.m
deleted file mode 100755
index 01bb606..0000000
--- a/Generator/library/GradientReconTools/ScaleXY.m
+++ /dev/null
@@ -1,33 +0,0 @@
-function [Xr, Yr] = ScaleXY(X, Y, s1, s2)
-%
-%              [Xr, Yr] = ScaleXY(X, Y, s1, s2);
-%
-%  Scale a given set of (x,y) points by values s1, s2.
-%  It is assumed that the points lie in the unit square [0,1]X[0,1]
-%
-%  Input:  X     = array containing x coordinates of original points
-%          Y     = array containing y coordinates of original points
-%          s1    = scaling of x-coordinates
-%          s2    = scaling of y-coordinates
-%
-%  Output: Xr = array containing scaled x coordinates
-%          Yr = array containing scaled y coordinates
-%
-
-%
-%  Create affine transformation to do the rotation of coordinates:
-%
-T = [s1, 0, 0;0, s2, 0; 0, 0, 1];
-
-%
-%  Note that we need to shift the center from (0.5,0.5) to (0,0)
-%  before scaling, then shift back.
-%
-SL = [1 0 0;0 1 0; -0.5,  -0.5, 1];
-SR = [1 0 0;0 1 0; 0.5,  0.5, 1];
-
-Z = (([X(:), Y(:), ones(length(X(:)), 1)] * SL) * T ) * SR;
-
-Xr = reshape(Z(:,1), size(X));
-Yr = reshape(Z(:,2), size(Y));
-
diff --git a/Generator/library/GradientReconTools/SpaceToMidx2D.m b/Generator/library/GradientReconTools/SpaceToMidx2D.m
deleted file mode 100755
index 94a4f18..0000000
--- a/Generator/library/GradientReconTools/SpaceToMidx2D.m
+++ /dev/null
@@ -1,20 +0,0 @@
-function [I, J] = SpaceToMidx2D(X, Y, m, n)
-%
-%  Convert the Euclidean spatial coordinates given by (X,Y) to
-%  MATLAB indices.  That is, assume the image array is situated
-%  on the Eucldean axes:
-%
-%              y ^
-%                |
-%                |
-%                |-------->
-%                         x
-%
-if nargin < 3
-  m = size(Y,1);
-  n = size(X,2);
-elseif nargin < 2
-  n = m;
-end
-I = m - Y;
-J = X + 1;
diff --git a/Generator/library/GradientReconTools/SubsampleMatrix.m b/Generator/library/GradientReconTools/SubsampleMatrix.m
deleted file mode 100755
index fa21bd8..0000000
--- a/Generator/library/GradientReconTools/SubsampleMatrix.m
+++ /dev/null
@@ -1,189 +0,0 @@
-function R = SubsampleMatrix(n, ssp)
-%
-%   R = SubsampleMatrix(n, ssp);
-%   
-% This function constructs a sparse matrix that implements subsampling
-% on an image vector. 
-%
-% Input:
-%   n   - dimension of high resolution grid (that is
-%         the high resolution grid is n-by-n pixels)
-%         If n is a scalar, it is assumed the high res image is n-by-n
-%         If n is a 1-by-2 vector, then it is assumed that the high res
-%         image is n(1)-by-n(2)
-%   ssp - subsampling parameter
-%         If ssp is a scalar, then it is assumed that the subsampling
-%         is the same in both x and y directions.
-%         If ssp is a 1-by-2 vector, then it is assumed that
-%          ssp(1) = subsampling in y-direction (down rows of image)
-%          ssp(2) = subsampling in x-direction (across cols of image)
-%
-% Output: 
-%   R   - sparse matrix 
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-%  Modified November, 2015 by J. Nagy
-%  This now allows non-integer ssp, and the ssp can be different in
-%  the x and y directions.
-%
-
-%
-%  
-if length(n) == 1
-    nrows = n; ncols = n;
-else
-    nrows = n(1); ncols = n(2);
-end
-if length(ssp) == 1
-    ssp_row = ssp; ssp_col = ssp;
-else
-    ssp_row = ssp(1); ssp_col = ssp(2);
-end
-
-nrows_low = round(nrows/ssp_row); % should be an integer, but round just to be sure
-ncols_low = round(ncols/ssp_col); % should be an integer, but round just to be sure
-
-%
-%  We create a matrices that will do the subsampling of the high res image
-%  to obtain the low res images.  
-%  First we create the subsampling in the y-direction (subsampling of rows)
-%
-Drow = sparse(nrows_low, nrows);
-idx = round(linspace(1, nrows, nrows_low));
-Drow(:,idx) = speye(nrows_low);
-%
-% The below commented out code is another way to do the subsampling.
-%
-%mid = round(nrows/2);
-%idx1 = round(linspace(1,mid,fix(nrows_low/2)));
-%h = min(diff(idx1));
-%idx2 = round(linspace(idx1(end)+h,nrows,round(nrows_low/2)));
-%Drow(:,[idx1,idx2]) = speye(nrows_low);
-
-%
-%  Now create the subsampling in the x-direction (subsampling of cols)
-%
-Dcol = sparse(ncols_low, ncols);
-idx = round(linspace(1, ncols, ncols_low));
-Dcol(:,idx) = speye(ncols_low);
-%
-% The below commented out code is another way to do the subsampling.
-%
-%mid = round(ncols/2);
-%idx1 = round(linspace(1,mid,fix(ncols_low/2)));
-%h = min(diff(idx1));
-%idx2 = round(linspace(idx1(end)+h,ncols,round(ncols_low/2)));
-%Dcol(:,[idx1,idx2]) = speye(ncols_low);
-
-%
-%  Before subsampling the high res image, we first apply a low-pass
-%  (smoothing) filter over the image.  The next two lines of code
-%  create windowed sinc filters.
-%
-% original is below
-% [hrow, ~] = SincKernel(nrows, nrows, 0.1, max(1/ssp_row,0.25));
-% [hcol, ~] = SincKernel(ncols, ncols, 0.1, max(1/ssp_col,0.25));
-
-% Changed by Doug to limit the amount of smoothing
-% on Apr 8 when working with SOR Ceiling fan data - used 5 for independent
-% phases
-[hrow, ~] = SincKernel(nrows, nrows, 0.10, max(1/ssp_row,0.25));
-[hcol, ~] = SincKernel(ncols, ncols, 0.10, max(1/ssp_col,0.25));
-
-
-
-%
-%  The SincKernel requires a couple of parameters that change the
-%  shape of the kernel.  I'm not sure precisely how these should be 
-%  chosen.  Below are some experiments I did, but it seems that
-%  the amount of filtering should depend on the subsampling.  If
-%  ssp = 1, the high res and low res images should be the same.
-%  
-%[hrow, Hrow] = SincKernel(nrows, nrows, 0.1, 0.08);
-%[hcol, Hcol] = SincKernel(ncols, ncols, 0.1, 0.08);
-%
-%[hrow, Hrow] = SincKernel(nrows, nrows, 0.1, 0.3);
-%[hcol, Hcol] = SincKernel(ncols, ncols, 0.1, 0.3);
-%
-%[hrow, Hrow] = SincKernel(nrows, nrows, 1, 2);
-%[hcol, Hcol] = SincKernel(ncols, ncols, 1, 2);
-%
-%  The second output of SincKernel implements the filtering with zero
-%  boundary conditions.  This seemed to cause slight artifacts on the 
-%  boundaries, so we now implement refelctive boundary conditions.
-%  The next lines of code do this:
-%
-crow = (length(hrow)+1)/2;
-ccol = (length(hcol)+1)/2;
-hrow = [hrow; zeros(nrows-length(hrow),1)];
-hcol = [hcol; zeros(nrows-length(hcol),1)];
-Arow = sparse(buildToep(hrow, crow) + buildHank(hrow, crow));
-Acol = sparse(buildToep(hcol, ccol) + buildHank(hcol, ccol));
-
-%
-%  Now that we have the filters and subsampling, we can create one big
-%  sparse matrix that performs the transformation from high res image to
-%  low res. (The commented out line uses zero boundary conditions.)
-%
-%R = kron(Dcol*Hcol,Drow*Hrow);
-R = kron(Dcol*Acol,Drow*Arow);
-
-%
-%--------------------------------------------------
-%  This version needs a few subfunctions.
-%
-function [h, H] = SincKernel(nrows, ncols, fc, b)
-%
-%  This constructs a windowed sinc filter.  This implementation is 
-%  modled after a python code at http://tomroelandts.com
-%  
-N = ceil(4 / b);
-if N/2 == fix(N/2)
-    N = N + 1;      
-end
-n = (0:N-1)';
-% Compute sinc filter.
-h = p_Sinc(2 * fc * (n - (N - 1) / 2));
-% Compute Blackman window.
-w = 0.42 - 0.5 * cos(2 * pi * n / (N - 1)) + 0.08 * cos(4 * pi * n / (N - 1));
-% Multiply sinc filter with window.
-h = h .* w;
-% Normalize to get unity gain.
-h = h / sum(h);
-B = repmat(h.', [min(nrows,ncols),1]);
-d = -(N-1)/2:(N-1)/2;
-H = spdiags(B, d, nrows, ncols);
-
-%
-%-------------------------------------------
-%
-function T = buildToep(c, k)
-%
-%  Build a banded Toeplitz matrix from a central column and an index
-%  denoting the central column.
-%
-n = length(c);
-col = zeros(n,1);
-row = col';
-col(1:n-k+1,1) = c(k:n);
-row(1,1:k) = c(k:-1:1)';
-T = toeplitz(col, row);
-
-%
-%-------------------------------------------
-%
-function H = buildHank(c, k)
-%
-%  Build a Hankel matrix for separable PSF and reflective boundary
-%  conditions.
-%
-n = length(c);
-col = zeros(n,1);
-col(1:n-k) = c(k+1:n);
-row = zeros(n,1);
-row(n-k+2:n) = c(1:k-1);
-H = hankel(col, row);
\ No newline at end of file
diff --git a/Generator/library/GradientReconTools/TransformCoordinates2D.m b/Generator/library/GradientReconTools/TransformCoordinates2D.m
deleted file mode 100755
index 143ce9a..0000000
--- a/Generator/library/GradientReconTools/TransformCoordinates2D.m
+++ /dev/null
@@ -1,11 +0,0 @@
-function [Xnew, Ynew] = TransformCoordinates2D(T, X, Y)
-%
-%  Transform (x,y) coordinates given by X and Y using the
-%  affine transformation given by T.  That is,
-%     [xnew, ynew] = [x, y, 1]*T
-%
-
-W = [X(:), Y(:), ones(length(X(:)), 1)] * T;
-
-Xnew = reshape(W(:,1), size(X));
-Ynew = reshape(W(:,2), size(Y));
diff --git a/Generator/library/GradientReconTools/WindowMatrix.m b/Generator/library/GradientReconTools/WindowMatrix.m
deleted file mode 100755
index 186dd2c..0000000
--- a/Generator/library/GradientReconTools/WindowMatrix.m
+++ /dev/null
@@ -1,32 +0,0 @@
-function W = WindowMatrix(n_ap, n_comp, pupil_mask, row_start, col_start)
-%
-%  W = WindowMatrix(n_ap, n_comp, pupil_mask, row_start, col_start);
-%
-%  This function constructs a sparse matrix that operates as a mask 
-%  to grab a certain region from an image array.
-%
-%  Input:
-%    n_ap       - size of high resolution image domain at telescope 
-%                       (e.g., 128-by-128)
-%    n_comp     - size of large (global, or composite) image
-%    pupil_mask - pupil mask of telescope
-%    row_start  -  These tell were the rectangular winow, which contains
-%    col_start  /  the pupil mask, should begin in the composite grid.
-%
-%  Output:
-%    W          - sparse matrix
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-jw1 = kron((0:n_ap-1)',n_comp*ones(n_ap,1));
-%jw2 = kron(ones(n_ap,1),(1:n_ap)');
-t1 = n_comp*(col_start-1)+row_start;
-jw2 = kron(ones(n_ap,1),(t1:t1+n_ap-1)');
-jw = jw1+jw2;
-iw = (1:n_ap*n_ap)';
-W = sparse(iw, jw, pupil_mask(:), n_ap*n_ap, n_comp*n_comp);
-%Wh = sparse(iw, jw, ones(n_ap*n_ap,1), n_ap*n_ap, n_comp*n_comp);
diff --git a/Generator/library/GradxMatrix.m b/Generator/library/GradxMatrix.m
deleted file mode 100755
index 7a192ba..0000000
--- a/Generator/library/GradxMatrix.m
+++ /dev/null
@@ -1,43 +0,0 @@
-function Dx = GradxMatrix(n, scale)
-%
-%  Dx = GradxMatrix(n, scale);
-%
-% Generates a sparse matrix that models computation of x-gradients
-% obtained by a wavefront sensor with Fried geometry.
-%
-% Important Remarks:
-%    1. The geometry is strange -- this computes what really seems like
-%       a y-gradient.  However, this code constructs a matrix that is
-%       consistent with what is found in the adaptive optics literature.
-%       See ...
-%    2. However, we do make one change with previously published papers:
-%       Our Dx is -1 times what is found in the above cited literature.  
-%    3. We are currently implementing this with a reflective boundary
-%       condition.
-%
-% Input:
-%   n  -    number of pixels across the image (assumed square)
-%
-% Optional Input:
-%   scale - allows for a normalization scale for specific geometries.
-%           Default is to use scale = 1;
-%
-% Output:
-%   Dx -    n^2 x n^2 sparse matrix
-%
-
-if nargin == 1
-  scale = [];
-end
-if isempty(scale)
-  scale = 1;
-end
-
-e = ones(n, 1);
-d1 = [e(1:n-1); 2];
-d2 = [e(1:n-1); 0];
-
-H = spdiags([-d2, e], 0:1, n, n);
-F = .5*spdiags([d1, e], 0:1, n, n);
-
-Dx = scale*kron(F, H);
diff --git a/Generator/library/GradyMatrix.m b/Generator/library/GradyMatrix.m
deleted file mode 100755
index 660e957..0000000
--- a/Generator/library/GradyMatrix.m
+++ /dev/null
@@ -1,43 +0,0 @@
-function Dy = GradyMatrix(n, scale)
-%
-%  Dy = GradyMatrix(n, scale);
-%
-% Generates a sparse matrix that models computation of y-gradients
-% obtained by a wavefront sensor with Fried geometry.
-%
-% Important Remarks:
-%    1. The geometry is strange -- this computes what really seems like
-%       a x-gradient.  However, this code constructs a matrix that is
-%       consistent with what is found in the adaptive optics literature.
-%       See ...
-%    2. However, we do make one change with previously published papers:
-%       Our Dy is -1 times what is found in the above cited literature.  
-%    3. We are currently implementing this with a reflective boundary
-%       condition.
-%
-% Input:
-%   n  -    number of pixels across the image (assumed square)
-%
-% Optional Input:
-%   scale - allows for a normalization scale for specific geometries.
-%           Default is to use scale = 1;
-%
-% Output:
-%   Dy -    n^2 x n^2 sparse matrix
-%
-
-if nargin == 1
-  scale = [];
-end
-if isempty(scale)
-  scale = 1;
-end
-
-e = ones(n, 1);
-d1 = [e(1:n-1); 2];
-d2 = [e(1:n-1); 0];
-
-H = spdiags([-d2, e], 0:1, n, n);
-F = .5*spdiags([d1, e], 0:1, n, n);
-
-Dy = scale*kron(H, F);
diff --git a/Generator/library/ObjectReconTools/._p_ReconstructObject_Wiener.m b/Generator/library/ObjectReconTools/._p_ReconstructObject_Wiener.m
deleted file mode 100755
index 42a8b1d..0000000
Binary files a/Generator/library/ObjectReconTools/._p_ReconstructObject_Wiener.m and /dev/null differ
diff --git a/Generator/library/ObjectReconTools/._p_ReconstructObject_gdnn.m b/Generator/library/ObjectReconTools/._p_ReconstructObject_gdnn.m
deleted file mode 100755
index 42a8b1d..0000000
Binary files a/Generator/library/ObjectReconTools/._p_ReconstructObject_gdnn.m and /dev/null differ
diff --git a/Generator/library/ObjectReconTools/._p_gdnn_project.m b/Generator/library/ObjectReconTools/._p_gdnn_project.m
deleted file mode 100755
index a258ab8..0000000
Binary files a/Generator/library/ObjectReconTools/._p_gdnn_project.m and /dev/null differ
diff --git a/Generator/library/ObjectReconTools/.p_ReconstructObject_gdnn.m.swp b/Generator/library/ObjectReconTools/.p_ReconstructObject_gdnn.m.swp
deleted file mode 100644
index 5033a2a..0000000
Binary files a/Generator/library/ObjectReconTools/.p_ReconstructObject_gdnn.m.swp and /dev/null differ
diff --git a/Generator/library/ObjectReconTools/p_ReconstructObject_Wiener.m b/Generator/library/ObjectReconTools/p_ReconstructObject_Wiener.m
deleted file mode 100755
index fa67c22..0000000
--- a/Generator/library/ObjectReconTools/p_ReconstructObject_Wiener.m
+++ /dev/null
@@ -1,30 +0,0 @@
-function object = p_ReconstructObject_Wiener(PSF, G, reg_par_WF)
-%
-%  Wiener filter reconstruction method for multi-frame deconvolution.
-%  This can be used to solve least squares problem 
-%     min sum ||g_k - conv(PSF_k,object)|| + reg_par_WF*||object||
-%  where g_k and PSF_k are data and PSF for k-th data frame.
-%
-%   Input: PSF         - 3D array containing PSFs for each frame.
-%          G           - 3D array containing 2D-FFT of data frames.
-%          reg_par_WF  - regularization parameter
-% 
-%   Output:
-%          object      -  reconstructed object
-%
-% J. Nagy, December, 2013
-%   
-
-%
-%  We need a little information about number of frames and number of 
-%  pixels in the object.
-%
-nframes = size(G, 3);
-n_obj =   size(G, 1);
-
-H = zeros(n_obj, n_obj, nframes);
-for k = 1:nframes
-  H(:,:,k) = fft2(fftshift(PSF(:,:,k)));
-end
-F = sum(conj(H).*G,3)./( sum(abs(H).^2,3) + reg_par_WF);
-object=real(ifft2(F));
diff --git a/Generator/library/ObjectReconTools/p_ReconstructObject_gdnn.m b/Generator/library/ObjectReconTools/p_ReconstructObject_gdnn.m
deleted file mode 100755
index 2a1e3b7..0000000
--- a/Generator/library/ObjectReconTools/p_ReconstructObject_gdnn.m
+++ /dev/null
@@ -1,170 +0,0 @@
-function [object, IterInfo] = p_ReconstructObject_gdnn(PSF, G, object, MaxIter)
-%
-%  Projected Gradient Descent Iterative Method for multi-frame 
-%  deconvolution, subject to a nonnegativity and volume preserving
-%  constraints.
-%
-%  This can be used to solve least squares problem 
-%     min sum ||g_k - conv(PSF_k,object)|| 
-%  subject to object >= 0 and sum(object(:)) = v,
-%  where g_k and PSF_k are data and PSF for k-th data frame, and v is
-%  the data volume.
-%
-%   Input: 
-%     PSF     - 3D array containing PSFs for each frame.
-%     G       - 3D array containing 2D-FFT of data frames.
-%     object  - initial guess at object -- sum of these pixels will
-%                    be conserved.
-% 
-%   Optional Input:
-%     MaxIter - Maximum number of iterations.  Default is n_obj/2, where
-%               the object is assumed to have n_obj -by- n_obj pixels.
-%
-%   Output:
-%     object  -  solution
-%   IterInfo  -  structure containing some information about the iteration
-%                Iter     -  actual number of iterations performed
-%                Rnrm     -  norm of the residual at each iteration
-%                NE_Rnrm  -  norm of the residual at each iteration
-%                StopFlag -  integer that indicates reason for stopping
-%                            iteration:
-%                               1 ==> Rtol satisfied
-%                               2 ==> NE_Rtol satisfied
-%                               3 ==> MaxIter reached
-%
-% J. Nagy, December, 2013
-%
-%  References: [1] H. Engl, M. Hanke, A. Neubauer. "Regularization of 
-%                  Inverse Problems", Kluwer, 2000.
-%              [2] P.C. Hansen. "Discrete Inverse Problems: Insight and
-%                  Algorithms", SIAM, 2010.
-%              [3] C. Vogel. "Computational Methods for Inverse Problems",
-%                  SIAM, 2002.
-%              [4] Y. Saad. "Iterative Methods for Sparse Linear Systems",
-%                  2nd Edition, SIAM, 2003
-%   
-
-%
-%  Set some tolerances to check for convergence.
-%
-Rtol = 1e-6;               % absolute residual tolerance
-Rtol = norm(G(:)) * Rtol;  % relative residual tolerance
-
-NE_Rtol = 1e-6;            % absolute normal equations tolerance
-
-%
-%  We need a little information about number of frames and number of 
-%  pixels in the object.
-%
-nframes = size(G, 3);
-n_obj =   size(G, 1);
-if nargin == 3
-  MaxIter = [];
-end
-if isempty(MaxIter)
-  MaxIter = n_obj/2;
-end
-
-%
-%  Precompute FFTs of all PSFs
-%
-H = zeros(n_obj, n_obj, nframes);
-for k = 1:nframes
-  H(:,:,k) = fft2(fftshift(PSF(:,:,k)));
-end
-
-%
-% We need to compute the data volume.  Here we use:
-%
-%data_volume = sum(sum(mean(real(ifft2(G)),3)));
-
-% Commenting this out and getting the data volume from the initial object
-% which comes from the abs(WF estimate).
-% data_volume = max( sum(sum(real(ifft2(G)),1),2) );
-data_volume = sum(object(:));
-
-%
-%  If we think of the problem as:
-%     min || b - Ax || subject to x>= 0
-%  then the major computations are to compute A*vector and A'*vector.
-%  But in this particular problem, A* and A'* are convolutions, so 
-%  everything is done using FFTs.
-%
-%  Here, trAb = A'*b 
-%
-trAb = sum(conj(H).*G, 3);
-NE_Rtol = norm(trAb(:)) * NE_Rtol;   % relative normal eq. tolerance
-
-Rnrm = zeros(MaxIter+1, 1);
-NE_Rnrm = zeros(MaxIter+1, 1);
-
-%r = b - A*x;
-%  
-% Again, if we think about this problem as the nonnegative least squares
-% problem,
-%          min || b - Ax || subject to x>= 0
-% then here we use x = object, and r = b - Ax.
-%
-x = object;
-r = G - H.*repmat(fft2(x), [1,1,nframes]);
-
-%
-% d = A'*r
-%
-d = sum(conj(H).*r, 3);
-
-Rnrm(1) = norm(r(:));
-NE_Rnrm(1) = norm(d(:));
-
-for k = 1:MaxIter
-  if Rnrm(k) <= Rtol
-    % stop because residual satisfies ||b-A*x||<= Rtol
-    StopFlag = 1;
-    break
-  end
-  if NE_Rnrm(k) <= NE_Rtol
-    % stop because normal equations residual satisfies ||A'*b-A'*A*x||<= NE_Rtol
-    StopFlag = 2;
-    break
-  end
-  %w = A*d;
-  w = H.*repmat(d, [1,1,nframes]);
-  % use steepest descent step length
-  tau = (d(:)'*d(:))/(w(:)'*w(:));
-  %
-  %  Do simple line search with backtracking
-  %
-  di = real(ifft2(d));
-  for lstep = 1:10
-    xnew1 = x + tau*di;
-    xnew = p_gdnn_project(xnew1, data_volume);
-    rnew = r - tau*w;
-    xdiff = xnew - x;
-    if (rnew(:)'*rnew(:)-r(:)'*r(:)) > -(1e-4)*(xdiff(:)'*xdiff(:))/tau;
-      tau = tau/2;
-    else
-      break
-    end
-  end
-  x = xnew;
-  r = rnew;
-  %d = A'*r;
-  d = sum(conj(H).*r, 3);
-  Rnrm(k+1) = norm(r(:));
-  NE_Rnrm(k+1) = norm(d(:));
-end
-object = x;
-
-if k == MaxIter
-  % Stop because max number of iterations reached
-  StopFlag = 3;
-else
-  k = k - 1;
-end
-if nargout==2
-  IterInfo.Iter = k;
-  IterInfo.Rnrm = Rnrm(1:k+1);
-  IterInfo.NE_Rnrm = NE_Rnrm(1:k+1);
-  IterInfo.StopFlag = StopFlag;
-end
-
diff --git a/Generator/library/ObjectReconTools/p_gdnn_project.m b/Generator/library/ObjectReconTools/p_gdnn_project.m
deleted file mode 100755
index eb7531e..0000000
--- a/Generator/library/ObjectReconTools/p_gdnn_project.m
+++ /dev/null
@@ -1,70 +0,0 @@
-function w = p_gdnn_project(y, v)
-%
-%  The function implements the projection needed in the projected 
-%  gradient method.  Specifically, it solves the problem:
-%
-%     w = argmin||w - y||, such that w >= 0 and sum(w(:)) = v
-%
-%  That is, we enforce nonnegativity on w, and preservtion of volume of 
-%  the data.
-%
-%  The solution to this problem is:
-%
-%     w = min(y - lambda, 0)
-%
-%  where the Lagrange multiplier, lambda, satisfies:
-%
-%     sum_i max(y(i) - lambda, 0) = v,
-%
-%  or lambda is a root of 
-%
-%     f(lambda) = sum_i max(y(i) - lambda, 0) - v = 0
-%
-%  We find a good initial guess of the root, using the given y(i), and
-%  then use a couple Newton iterations to refine the approximation.
-%
-%  J. Nagy, December, 2013.
-
-%
-%  Define the function f(lambda)
-%
-[M, N] = size(y);
-y = y(:);
-f = @(lambda) sum(max(y-lambda,0)) - v;
-
-%
-%  Find a good initial guess of the root using the given y values.
-%  Specifically, f(lambda) is a monotonically decreasing function, so
-%  if y(1)<=y(2)<=...<=y(n), then we find the largest j such that 
-%      sum_{j=k+1}^n (y(k) - y(j)) - v > 0
-%  and take the initial lambda to be y(j).
-%
-ys = sort(y,'ascend');
-n = length(ys);
-s = zeros(n,1);
-s(1) = sum(ys(2:n)) - (n-1)*ys(1) - v;
-for j = 1:n-1
-  s(j+1) = s(j) - (n-j)*(ys(j+1)-ys(j));
-end
-idx = find(s>0, 1, 'last');
-if isempty(idx)
-  lambda = 0;
-else
-  lambda = ys(idx);
-end
-f0 = f(lambda);
-%
-%  Now do a few Newton iterations.  Here the maximum number of iterations
-%  is set to 10, but generally only 2 or 3 iterations are needed.
-%
-for k = 1:10
-  nmax = length(find(y-lambda>0));
-  lambda = lambda + f0/nmax;
-  f1 = f(lambda);
-  if f0 - f1 < 1e-10
-    break
-  end
-  f0 = f1;
-end
-w = max(y-lambda,0);
-w = reshape(w, M, N);
\ No newline at end of file
diff --git a/Generator/library/OptimTools.tgz b/Generator/library/OptimTools.tgz
deleted file mode 100755
index 148a9b7..0000000
Binary files a/Generator/library/OptimTools.tgz and /dev/null differ
diff --git a/Generator/library/OptimTools/._p_NLCG.m b/Generator/library/OptimTools/._p_NLCG.m
deleted file mode 100755
index a258ab8..0000000
Binary files a/Generator/library/OptimTools/._p_NLCG.m and /dev/null differ
diff --git a/Generator/library/OptimTools/._p_NLCG_LSplay.m b/Generator/library/OptimTools/._p_NLCG_LSplay.m
deleted file mode 100755
index e28ebf0..0000000
Binary files a/Generator/library/OptimTools/._p_NLCG_LSplay.m and /dev/null differ
diff --git a/Generator/library/OptimTools/._p_bracket.m b/Generator/library/OptimTools/._p_bracket.m
deleted file mode 100755
index a258ab8..0000000
Binary files a/Generator/library/OptimTools/._p_bracket.m and /dev/null differ
diff --git a/Generator/library/OptimTools/._p_brent.m b/Generator/library/OptimTools/._p_brent.m
deleted file mode 100755
index e28ebf0..0000000
Binary files a/Generator/library/OptimTools/._p_brent.m and /dev/null differ
diff --git a/Generator/library/OptimTools/._p_cstep.m b/Generator/library/OptimTools/._p_cstep.m
deleted file mode 100755
index b172684..0000000
Binary files a/Generator/library/OptimTools/._p_cstep.m and /dev/null differ
diff --git a/Generator/library/OptimTools/._p_cvsrch.m b/Generator/library/OptimTools/._p_cvsrch.m
deleted file mode 100755
index d7f6946..0000000
Binary files a/Generator/library/OptimTools/._p_cvsrch.m and /dev/null differ
diff --git a/Generator/library/OptimTools/._p_func_mnbrak.m b/Generator/library/OptimTools/._p_func_mnbrak.m
deleted file mode 100755
index e28ebf0..0000000
Binary files a/Generator/library/OptimTools/._p_func_mnbrak.m and /dev/null differ
diff --git a/Generator/library/OptimTools/._p_initial0.m b/Generator/library/OptimTools/._p_initial0.m
deleted file mode 100755
index a258ab8..0000000
Binary files a/Generator/library/OptimTools/._p_initial0.m and /dev/null differ
diff --git a/Generator/library/OptimTools/p_NLCG.m b/Generator/library/OptimTools/p_NLCG.m
deleted file mode 100755
index 2650388..0000000
--- a/Generator/library/OptimTools/p_NLCG.m
+++ /dev/null
@@ -1,302 +0,0 @@
-function [ p, IterInfo] = p_NLCG(p, OPTIM_params, fval0)
-%
-% Nonlinear conjugate gradient (NLCG) method, used to update the PSF 
-% parameters, which are the high resolution composite phase gradients on 
-% each atmospheric layer.
-%
-% This implementation is a translation from Numerical Recipes.  It miht
-% be worth changing this, for example to use a Strong Wolfe condition for
-% the line search, instead of the current exact line search we are doing.
-%
-% Input:  
-%   p      - initial guess of the PSF paramters -- these are the
-%            unknowns over which we want to optimize.
-%   object - current estimate of the object. 
-%   Structures:
-%     The folowing strucutres contain a variety of parameters, which are
-%     needed for the function evaluations.  See other codes for the 
-%     description of these parameters, as well as 
-%     p_GradOptFun_and_DFun_poly.m for more information.
-%          - DORA_input_data
-%          - WFS_params
-%          - PSF_params
-%          - OBJ_params
-%          - OPTIM_params
-%          - FFM_options
-%   SparseMatrices - cell array containing the sparse matrices from the
-%                    FFM reconstruction.  These are needed in the
-%                    function and gradient evaluations.
-%
-%   Optional Input:
-%    fval0 - initial function value -- used to initialize RelFunChange.
-%            Default to is to initialize RelFunChange(1) = 1;
-%
-%  Output:
-%    p - update of the PSF parameters
-%    IterInfo - structure that contains the following information about
-%               the iterations:
-%                  StopFlag - indicates why the iteration terminated:
-%                             StopFlag = 0 
-%                               ==> MaxIters reached
-%                             StopFlag = 1 
-%                               ==> norm(gradient)/length(p) is less than 
-%                                   OPTIM_params.NLCG_RelGradTol
-%                             StopFlag = 2 
-%                               ==> |F(p)-F(p_old)|/|F(p_old)| is less than
-%                                   OPTIM_params.NLCG_RelFunChangeTol
-%                   FunVals - vector containg the function values at each
-%                             iteration.
-%                  FunEvals - vector containing the number of function 
-%                             evaluations needed for each iteration 
-%                 GradEvals - vector containing the number of gradient 
-%                             evaluations needed for each iteration 
-%              RelGradNorms - vector containing norm(gradient)/length(p)
-%                             for each iteration (first entry is 1, to 
-%                             correspond to initialization step, second
-%                             entry is for iteration 1, etc.)
-%              RelFunChange - vector containing |F(p)-F(p_old)|/|F(p_old)|
-%                             for each iteration (first entry is 1, to 
-%                             correspond to initialization step, second
-%                             entry is for iteration 1, etc.)
-%                 IterTimes - vector containing time needed for each
-%                             iteration (first entry is for the 
-%                             initialization step, second entry is for 
-%                             iteration 1, etc.)
-%                 
-
-global cost_params
-% object = reshape(p(cost_params.idx_obj_vars).^2,[cost_params.mdim cost_params.mdim]);
-
-%
-% First extract some information from the OPTIM_params structure.
-%
-func_name           = OPTIM_params.func_name;
-func_and_dfunc_name = OPTIM_params.func_and_dfunc_name;
-MaxIters            = OPTIM_params.NLCG_MaxIters;
-RelFunChangeTol     = OPTIM_params.NLCG_RelFunChangeTol;
-RelGradTol          = OPTIM_params.NLCG_RelGradTol;
-IterPrint           = OPTIM_params.IterPrint;
-
-
-%
-% If IterPrint = 0, then we should print information at each iteration
-%
-if IterPrint == 0
-  echo_out(' Iter  FuncEvals GradEvals    F(X)/N        |F(X)-F(Xold)|/|F(Xold)|   ||G(X)||/N           Time (seconds)     \n');
-  echo_out('------ --------- --------- ---------------- ------------------------  ----------------     --------------- \n');
-end
-tic;
-
-%
-%  To call the func and dfunc, it will be easier to organize the precise
-%  inputs the function needs, and just pass this one structure.
-%  Here we put together this input structure.
-%
-% fun_input.DORA_input_data = DORA_input_data;
-% fun_input.WFS_params      = WFS_params;
-% fun_input.PSF_params      = PSF_params;
-% fun_input.FFM_options     = FFM_options;
-% fun_input.OPTIM_params    = OPTIM_params;
-% fun_input.OBJ_params      = OBJ_params;
-% fun_input.SparseMatrices  = SparseMatrices;
-
-%
-%  We will use a function handle to evaluate the function and gradient,
-%  so here we define those function handles.
-%
-func = eval(['@(p)',func_name,'(p)']);
-func_and_dfunc  = eval(['@(p)',func_and_dfunc_name,'(p)']);
-
-%
-%  We need a tolerance for finding a line search using Brent's method
-%  (see below).  It might be worth investigating what should be the
-%  best choice for this parameter.
-%
-Brent_TOL = 2e-4;
- 
-%
-%  We need to compute an initial gradient, and the initial direction
-%  d = negative gradient.
-%
-%g = dfunc(p);
-[fval, g] = feval(func_and_dfunc, p);
-d = -g;
-
-
-
-%  And we need to compute an initial function evaluation.
-%fval = func(p);
-%fval0 = fval;
-
-%
-%  Before starting the iterations, we need to initialize several things:
-%
-n_params = length(p);
-StopFlag = 0;
-IterTimes = zeros(MaxIters+1,1);
-FunEvals = zeros(MaxIters+1,1);
-FunVals = zeros(MaxIters+1,1);
-GradEvals = zeros(MaxIters+1,1);
-RelGradNorms = zeros(MaxIters+1,1);
-RelFunChange = zeros(MaxIters+1,1);
-FunVals(1) = fval;
-FunEvals(1) = 1;
-GradEvals(1) = 1;
-FunEvalsii = 0;
-GradEvalsii = 0;
-RelGradNorms(1) = norm(g)/n_params;
-if isempty(fval0)
-  RelFunChange(1) = 1;
-else
-  RelFunChange(1) = abs(fval-fval0)/abs(fval0);
-end
-IterTimes(1) = toc;
-%
-%  If IterPrint = 0, print to the screen information for  the initialization
-%  step (iteration 0).
-%
-if IterPrint == 0
-    %[ a_hat, H_hat, aAu, aPu ]      = feval(cost_params.PSF_func,p);
-   % object = reshape(p(cost_params.idx_obj_vars).^2,[cost_params.mdim cost_params.mdim]);
-  %  GH = fft2(object).*H_hat{cost_params.curr_chann}.H_hat(:,:,1);
- %   echo_out(sprintf('%6d %9d %9d %16.8e   %16.8e       %16.8e      %8.2f   %10.5e   %10.5e   \n', 0, FunEvals(1), GradEvals(1), fval, RelFunChange(1), RelGradNorms(1), IterTimes(1),sum(object(:)),GH(1,1)./sum(sum(cost_params.gg2{cost_params.curr_chann}(:,:,1)))));
-  echo_out(sprintf('%6d %9d %9d %16.8e   %16.8e       %16.8e      %8.2f    \n', 0, FunEvals(1), GradEvals(1), fval, RelFunChange(1), RelGradNorms(1), IterTimes(1)));
-end
-tic;
-
-if ~isempty(OPTIM_params.out_func)
-    feval(OPTIM_params.out_func,p,0,OPTIM_params);
-end
-
-for ii = 1:MaxIters
-    cost_params.ii = cost_params.ii +1;
-  %
-  %  In nonlinear conjugate gradient, the first thing that needs to
-  %  be done is to use a line search method to compute a step
-  %  step length.  Basically, the idea is to do the following:
-  %  find alpha to minimize:
-  %      f(alpha) = func_name(p + alpha*d)
-  %  where p is the parameter vector and d is the current step
-  %  direction.  Note that, although func_name is a multivariable
-  %  function, for the line search, we only consider f(alpha) as
-  %  a function of a single variable.
-  %
-  %  There are many ways to find this minimum ... here we are using
-  %  "Brent's method", which needs a bracket around where the 
-  %  minimum is located.  
-  %  
-  if ii == 1
-    ax = 0;
-    bx = 1;
-  end
-  [ax,bx,cx,fa,fb,fc,BRAK_FunEvals] = p_func_mnbrak(func,ax,bx,p,d);
-  FunEvalsii = FunEvalsii + BRAK_FunEvals;
-  %
-  % There are built-in functions in MATLAB called "lower" and "upper", so
-  % don't use those as variable names here.
-  %
-  if (ax > cx)
-    lower_bkt=cx;
-    upper_bkt=ax;
-  else
-    lower_bkt=ax;
-    upper_bkt=cx;
-  end               
-  [alpha, ~, ~, BRENT_FunEvals] = p_brent(func, lower_bkt, bx, upper_bkt,p,d, Brent_TOL);
-  FunEvalsii = FunEvalsii + BRENT_FunEvals;
-  ax = 0;
-  bx = alpha;
-  
-  %
-  %  Note that I think the above function brent.m is essentially
-  %  the same as what MATLAB's built-in fminbnd function does.
-  %  It would be interesting to compare this.
-  %  It might also be worth changing this exact line search to an
-  %  inexact line search based on the strong Wolfe condition.
-  %
-  %p    = p + alpha*xi;
-  p = p + alpha*d;
-
-  %
-  % Save the previous function value and gradint, and update:
-  %
-  fvalp = fval;
-  g_old = g;
-  [fval, g] = feval(func_and_dfunc, p);
-  FunEvalsii = FunEvalsii + 1;
-  GradEvalsii = GradEvalsii + 1;
-           
-  % Use Polak-Ribiere CG 
-  gg = sum(g_old(:).*g_old(:));
-  dgg = sum((g(:)-g_old(:)).*g(:));
-  beta    = dgg/gg;
-  %  If you want to use Fletcher-Reeves CG, then uncomment the 
-  %  next few lines, and comment out the Polak-Ribiere lines.
-  %
-  % gg      = sum(g_old(:).*g_old(:));
-  % dgg     = sum(g(:).*g(:));
-  % beta    = dgg/gg;
-  %
-  d = -g + beta*d;
-  
-  %
-  % Update iteration information, and check for convergence
-  %
-  RelGradNorms(ii+1) = norm(g)/n_params;
-  RelFunChange(ii+1) = abs(fval-fvalp)/abs(fvalp);
-  FunVals(ii+1) = fval;
-  FunEvals(ii+1) = FunEvalsii;
-  GradEvals(ii+1) = GradEvalsii;
-  FunEvalsii = 0;
-  GradEvalsii = 0;
-  IterTimes(ii+1) = toc;
-  %
-  %  If IterPrint = 0, print the iteration information to the screen
-  %
-%   [ a_hat, H_hat, aAu, aPu ]      = feval(cost_params.PSF_func,p);
-%   object = reshape(p(cost_params.idx_obj_vars).^2,[cost_params.mdim cost_params.mdim]);
-%     GH = fft2(object).*H_hat{cost_params.curr_chann}.H_hat(:,:,1);
-  if IterPrint == 0
-    echo_out(sprintf('%6d %9d %9d %16.8e   %16.8e       %16.8e      %8.2f    \n', ii, FunEvals(ii+1), GradEvals(ii+1), fval, RelFunChange(ii+1), RelGradNorms(ii+1), IterTimes(ii+1)));
-  end
-  tic;
-  if RelGradNorms(ii+1) <= RelGradTol
-    StopFlag = 1;
-    break
-  end
-  if RelFunChange(ii+1) <= RelFunChangeTol
-    StopFlag = 2;
-    break
-  end
-  if ~isempty(OPTIM_params.out_func)
-  	feval(OPTIM_params.out_func,p,ii,OPTIM_params);
-  end
- 
-end
-IterInfo.StopFlag     = StopFlag;
-IterInfo.FunEvals     = FunEvals(1:ii+1);
-IterInfo.GradEvals    = GradEvals(1:ii+1);
-IterInfo.FunVals      = FunVals(1:ii+1);
-IterInfo.RelGradNorms = RelGradNorms(1:ii+1);
-IterInfo.RelFunChange = RelFunChange(1:ii+1);
-IterInfo.IterTimes    = IterTimes(1:ii+1);
-if IterPrint == 0
-  if StopFlag == 0
-    echo_out('^^^^^^\n');
-    echo_out('NLCG STOP\n');
-    echo_out('MaxIter\n');
-    echo_out(sprintf('%6d\n',MaxIters));
-  elseif StopFlag == 2 
-    echo_out('                                               ^^^^^^^^^^^^^^^^\n');
-    echo_out('                                                  NLCG STOP\n');
-    echo_out('                                                RelFunChangeTol\n');
-    echo_out(sprintf('                                              %16.8e\n',RelFunChangeTol));
-  else
-    echo_out('                                                                       ^^^^^^^^^^^^^^^^\n');
-    echo_out('                                                                          NLCG STOP\n');
-    echo_out('                                                                        RelGradNormTol\n');
-    echo_out(sprintf('                                                                     %16.8e\n',RelGradTol));
-  end
-end
-
-
diff --git a/Generator/library/OptimTools/p_NLCG_LSplay.m b/Generator/library/OptimTools/p_NLCG_LSplay.m
deleted file mode 100755
index 39a5503..0000000
--- a/Generator/library/OptimTools/p_NLCG_LSplay.m
+++ /dev/null
@@ -1,321 +0,0 @@
-function [ p, IterInfo] = p_NLCG_LSplay(p, object, DORA_input_data, WFS_params, PSF_params, OBJ_params, OPTIM_params, FFM_options, SparseMatrices, fval0)
-%
-% Nonlinear conjugate gradient (NLCG) method, used to update the PSF 
-% parameters, which are the high resolution composite phase gradients on 
-% each atmospheric layer.
-%
-% This implementation is a translation from Numerical Recipes.  It miht
-% be worth changing this, for example to use a Strong Wolfe condition for
-% the line search, instead of the current exact line search we are doing.
-%
-% Input:  
-%   p      - initial guess of the PSF paramters -- these are the
-%            unknowns over which we want to optimize.
-%   object - current estimate of the object.
-%   Structures:
-%     The folowing strucutres contain a variety of parameters, which are
-%     needed for the function evaluations.  See other codes for the 
-%     description of these parameters, as well as 
-%     p_GradOptFun_and_DFun_poly.m for more information.
-%          - DORA_input_data
-%          - WFS_params
-%          - PSF_params
-%          - OBJ_params
-%          - OPTIM_params
-%          - FFM_options
-%   SparseMatrices - cell array containing the sparse matrices from the
-%                    FFM reconstruction.  These are needed in the
-%                    function and gradient evaluations.
-%
-%   Optional Input:
-%    fval0 - initial function value -- used to initialize RelFunChange.
-%            Default to is to initialize RelFunChange(1) = 1;
-%
-%  Output:
-%    p - update of the PSF parameters
-%    IterInfo - structure that contains the following information about
-%               the iterations:
-%                  StopFlag - indicates why the iteration terminated:
-%                             StopFlag = 0 
-%                               ==> MaxIters reached
-%                             StopFlag = 1 
-%                               ==> norm(gradient)/length(p) is less than 
-%                                   OPTIM_params.NLCG_RelGradTol
-%                             StopFlag = 2 
-%                               ==> |F(p)-F(p_old)|/|F(p_old)| is less than
-%                                   OPTIM_params.NLCG_RelFunChangeTol
-%                  FunEvals - vector containing the number of iterations
-%                             needed for each iteration (time for 
-%                             initialization is the first entry, time for
-%                             iteration 1 is the second entry, etc.)
-%                  FunEvals - vector containing the number of iterations
-%                             needed for each iteration (time for 
-%                             initialization is the first entry, time for
-%                             iteration 1 is the second entry, etc.)
-%              RelGradNorms - vector containing norm(gradient)/length(p)
-%                             for each iteration (first entry is 1, to 
-%                             correspond to initialization step, second
-%                             entry is for iteration 1, etc.)
-%              RelFunChange - vector containing |F(p)-F(p_old)|/|F(p_old)|
-%                             for each iteration (first entry is 1, to 
-%                             correspond to initialization step, second
-%                             entry is for iteration 1, etc.)
-%                 IterTimes - vector containing time needed for each
-%                             iteration (first entry is for the 
-%                             initialization step, second entry is for 
-%                             iteration 1, etc.)
-%                 
-
-%LineSearch_params.delta = 0.1;
-%LineSearch_params.sigma = 0.9;
-%LineSearch_params.epsk  = 1e-6;
-%LineSearch_params.omega = 1e-3;
-%LineSearch_params.theta = 0.5;
-%LineSearch_params.gamma = 0.66;
-%LineSearch_params.rho   = 5;
-LineSearch_params.ftol   = 1e-4;
-LineSearch_params.gtol   = 1e-2;
-LineSearch_params.xtol   = 1e-4;
-LineSearch_params.stpmin = 1e-15;
-LineSearch_params.stpmax = 1e15;
-LineSearch_params.maxfev = 20;
-LineSearch_params.psi0   = 1e-2;
-LineSearch_params.psi1   = 1e-1;
-LineSearch_params.psi2   = 2;
-
-%
-% First extract some information from the OPTIM_params structure.
-%
-%func_name       = OPTIM_params.func_name;
-%dfunc_name      = OPTIM_params.dfunc_name;
-func_and_dfunc_name = OPTIM_params.func_and_dfunc_name;
-MaxIters        = OPTIM_params.NLCG_MaxIters;
-RelFunChangeTol = OPTIM_params.NLCG_RelFunChangeTol;
-RelGradTol      = OPTIM_params.NLCG_RelGradTol;
-IterPrint       = OPTIM_params.IterPrint;
-LogFile_fid     = OPTIM_params.LogFile_fid;
-
-%
-% If IterPrint = 0, then we should print information at each iteration
-%
-if IterPrint == 0
-  fprintf(LogFile_fid,' Iter  FuncEvals GradEvals    F(X)/N        |F(X)-F(Xold)|/|F(Xold)|   ||G(X)||/N           Time (seconds)     \n');
-  fprintf(LogFile_fid,'------ --------- --------- ---------------- ------------------------  ----------------     --------------- \n');
-  tic;
-end
-
-%
-%  To call the func and dfunc, it will be easier to organize the precise
-%  inputs the function needs, and just pass this one structure.
-%  Here we put together this input structure.
-%
-fun_input.DORA_input_data = DORA_input_data;
-fun_input.WFS_params      = WFS_params;
-fun_input.PSF_params      = PSF_params;
-fun_input.FFM_options     = FFM_options;
-fun_input.OPTIM_params    = OPTIM_params;
-fun_input.OBJ_params      = OBJ_params;
-fun_input.SparseMatrices  = SparseMatrices;
-
-%
-%  We will use a function handle to evaluate the function and gradient,
-%  so here we define those function handles.
-%
-%func  = eval(['@(p)',func_name,'(p, object, fun_input)']);
-%dfunc = eval(['@(p)',dfunc_name,'(p, object, fun_input)']);
-func_and_dfunc  = eval(['@(p)',func_and_dfunc_name,'(p, object, fun_input)']);
-
-%
-%  We need a tolerance for finding a line search using Brent's method
-%  (see below).  It might be worth investigating what should be the
-%  best choice for this parameter.
-%
-%Brent_TOL = 2e-4;
- 
-%
-%  We need to compute an initial gradient, and the initial direction
-%  d = negative gradient.
-%
-[fval, g] = feval(func_and_dfunc, p);
-%g = dfunc(p);
-d = -g;
-
-%  And we need to compute an initial function evaluation.
-%fval = func(p);
-%fval0 = fval;
-
-%
-%  Before starting the iterations, we need to initialize several things:
-%
-n_params = length(p);
-StopFlag = 0;
-IterTimes = zeros(MaxIters+1,1);
-FunEvals = zeros(MaxIters+1,1);
-FunVals = zeros(MaxIters+1,1);
-GradEvals = zeros(MaxIters+1,1);
-RelGradNorms = zeros(MaxIters+1,1);
-RelFunChange = zeros(MaxIters+1,1);
-FunVals(1) = fval;
-FunEvals(1) = 1;
-GradEvals(1) = 1;
-FunEvalsii = 0;
-GradEvalsii = 0;
-RelGradNorms(1) = norm(g)/n_params;
-if isempty(fval0)
-  RelFunChange(1) = 1;
-else
-  RelFunChange(1) = abs(fval-fval0)/abs(fval0);
-end
-IterTimes(1) = toc;
-%
-%  If IterPrint = 0, print to the screen information for  the initialization
-%  step (iteration 0).
-%
-if IterPrint == 0
-  fprintf(LogFile_fid,'%6d %9d %9d %16.8e   %16.8e       %16.8e      %8.2f \n', 0, FunEvals(1), GradEvals(1), fval/n_params, RelFunChange(1), RelGradNorms(1), IterTimes(1));
-end
-tic;
-
-for ii = 1:MaxIters
-  %
-  %  In nonlinear conjugate gradient, the first thing that needs to
-  %  be done is to use a line search method to compute a step
-  %  step length.  Basically, the idea is to do the following:
-  %  find alpha to minimize:
-  %      f(alpha) = func_name(p + alpha*d)
-  %  where p is the parameter vector and d is the current step
-  %  direction.  Note that, although func_name is a multivariable
-  %  function, for the line search, we only consider f(alpha) as
-  %  a function of a single variable.
-  %
-  %  There are many ways to find this minimum ... here we are using
-  %  "Brent's method", which needs a bracket around where the 
-  %  minimum is located.  
-  %  
-  %alpha = 1;
-  %if ii == 1;
-    alpha = p_initial0(p, fval, g, LineSearch_params);
-  %else
-  %  phi0 = fval;
-  %  phi_der0 = d'*g;
-  %  [alpha, FunEvals_initial] = p_initial(func_and_dfunc, p, d, phi0, phi_der0, alpha, LineSearch_params);
-  %  FunEvalsii = FunEvalsii + FunEvals_initial;
-  %  GradEvalsii = GradEvalsii + FunEvals_initial;
-  %end
-  fvalp = fval;
-  g_old = g;
-  [p,fval,g,alpha,info,LS_FunEvals] = p_cvsrch(func_and_dfunc,p,fval,g,d,alpha,LineSearch_params);
-  FunEvalsii = FunEvalsii + LS_FunEvals;
-  GradEvalsii = GradEvalsii + LS_FunEvals;
-  %[alpha_new, FunEvalsiii]
-  %if ii == 1
-  %  ax = 0;
-  %  bx = 1;
-  %end
-  %[ax,bx,cx,fa,fb,fc,FunEvalsii] = p_func_mnbrak(func,ax,bx,p,d,FunEvalsii);
-  %
-  % There are built-in functions in MATLAB called "lower" and "upper", so
-  % don't use those as variable names here.
-  %
-  %if (ax > cx)
-  %  lower_bkt=cx;
-  %  upper_bkt=ax;
-  %else
-  %  lower_bkt=ax;
-  %  upper_bkt=cx;
-  %end               
-  %[alpha, ~, ~, FunEvalsii] = p_brent(func, lower_bkt, bx, upper_bkt,p,d, Brent_TOL, FunEvalsii);
-  %ax = 0;
-  %bx = alpha
-  
-  %[alpha, alpha_new]
-  %[FunEvalsii, FunEvalsiii]
-  %
-  %  Note that I think the above function brent.m is essentially
-  %  the same as what MATLAB's built-in fminbnd function does.
-  %  It would be interesting to compare this.
-  %  It might also be worth changing this exact line search to an
-  %  inexact line search based on the strong Wolfe condition.
-  %
-  %p    = p + alpha*d;
-
-  %
-  % Save the previous function value, and compute the current
-  % function value:
-  %
-  %fvalp = fval;
-  %fval = func(p);
-  %FunEvalsii = FunEvalsii + 1;
-
-  % udate the gradient
-  %g_old = g;
-  %g = dfunc(p);
-  %FunEvalsii = FunEvalsii + 1;
-           
-  % Use Polak-Ribiere CG 
-  gg = sum(g_old(:).*g_old(:));
-  dgg = sum((g(:)-g_old(:)).*g(:));
-  beta    = dgg/gg;
-  %  If you want to use Fletcher-Reeves CG, then uncomment the 
-  %  next few lines, and comment out the Polak-Ribiere lines.
-  %
-  % gg      = sum(g_old(:).*g_old(:));
-  % dgg     = sum(g(:).*g(:));
-  % beta    = dgg/gg;
-  %
-  d = -g + beta*d; 
-  
-  %
-  % Update iteration information, and check for convergence
-  %
-  RelGradNorms(ii+1) = norm(g)/n_params;
-  RelFunChange(ii+1) = abs(fval-fvalp)/abs(fvalp);
-  FunVals(ii+1) = fval;
-  FunEvals(ii+1) = FunEvalsii;
-  GradEvals(ii+1) = GradEvalsii;
-  FunEvalsii = 0;
-  GradEvalsii = 0;
-  IterTimes(ii+1) = toc;
-  %
-  %  If IterPrint = 0, print the iteration information to the screen
-  %
-  if IterPrint == 0
-    fprintf(LogFile_fid,'%6d %9d %9d %16.8e   %16.8e       %16.8e      %8.2f \n', ii, FunEvals(ii+1), GradEvals(ii+1), fval/n_params, RelFunChange(ii+1), RelGradNorms(ii+1), IterTimes(ii+1));
-  end
-  tic;
-  if RelGradNorms(ii+1) <= RelGradTol
-    StopFlag = 1;
-    break
-  end
-  if RelFunChange(ii+1) <= RelFunChangeTol
-    StopFlag = 2;
-    break
-  end
-end
-IterInfo.StopFlag     = StopFlag;
-IterInfo.FunEvals     = FunEvals(1:ii+1);
-IterInfo.GradEvals    = GradEvals(1:ii+1);
-IterInfo.FunVals      = FunVals(1:ii+1);
-IterInfo.RelGradNorms = RelGradNorms(1:ii+1);
-IterInfo.RelFunChange = RelFunChange(1:ii+1);
-IterInfo.IterTimes    = IterTimes(1:ii+1);
-if IterPrint == 0
-  if StopFlag == 0
-    fprintf(LogFile_fid,'^^^^^^\n');
-    fprintf(LogFile_fid,'NLCG STOP\n');
-    fprintf(LogFile_fid,'MaxIter\n');
-    fprintf(LogFile_fid,'%6d\n',MaxIters);
-  elseif StopFlag == 2 
-    fprintf(LogFile_fid,'                                               ^^^^^^^^^^^^^^^^\n');
-    fprintf(LogFile_fid,'                                                  NLCG STOP\n');
-    fprintf(LogFile_fid,'                                                RelFunChangeTol\n');
-    fprintf(LogFile_fid,'                                              %16.8e\n',RelFunChangeTol);
-  else
-    fprintf(LogFile_fid,'                                                                      ^^^^^^^^^^^^^^^^\n');
-    fprintf(LogFile_fid,'                                                                         NLCG STOP\n');
-    fprintf(LogFile_fid,'                                                                       RelGradNormTol\n');
-    fprintf(LogFile_fid,'                                                                     %16.8e\n',RelGradTol);
-  end
-end
-
-
diff --git a/Generator/library/OptimTools/p_bracket.m b/Generator/library/OptimTools/p_bracket.m
deleted file mode 100755
index 0459b0c..0000000
--- a/Generator/library/OptimTools/p_bracket.m
+++ /dev/null
@@ -1,34 +0,0 @@
-function [a, b, FunEvals] = p_bracket(FUN, c, x, d, phi0, phi_der0, LineSearch_params, FunEvals)
-%
-%
-
-epsk = LineSearch_params.epsk;
-rho  = LineSearch_params.rho;
-MaxSteps = 4; %LineSearch_params.bracketMaxSteps;
-
-c_vec = zeros(MaxSteps, 1);
-phic_vec = zeros(MaxSteps,1);
-phic_vec(1) = phi_der0;
-
-c_vec(2) = c;
-
-for j = 2:MaxSteps
-  xc = x + c_vec(j)*d;
-  [~, gc] = feval(FUN, xc);
-  FunEvals = FunEvals + 1;
-  phi_derc = d'*gc;
-  if phi_derc >= 0
-    b = c_vec(j);
-    idx = find(phic_vec(1:j-1) <= phi0+epsk, 1, 'last');
-    a = c_vec(idx);
-    return
-  elseif (phi_derc < 0  && phi_derc > phi0+epsk)
-    [a, b, FunEvals] = p_update0(FUN, a, b, phi0, phi_der0, x, d, LineSearch_params, FunEvals);
-    return
-  else
-    c(j+1) = rho*c(j);
-  end
-end
-if j == MaxSteps
-  error('bracket did max steps')
-end
diff --git a/Generator/library/OptimTools/p_brent.m b/Generator/library/OptimTools/p_brent.m
deleted file mode 100755
index 97d5765..0000000
--- a/Generator/library/OptimTools/p_brent.m
+++ /dev/null
@@ -1,208 +0,0 @@
-function [xmin,fmin,iter,FunEvals] = p_brent(f, ax, bx, cx, x_in,d_in, tol)
-
-%  Brents Method for Minimization.
-%
-%  [ xmin, fmin ] = brent(f, ax, bx, cx, x_in,d_in, tol)
-%
-%  Given a function f, and given a bracketing triplet of abscissas ax,
-%  bx and cx, and fx(b) is less than both f(ax) and f(cx), this routine
-%  isolates the minimum to a fractional precision of about TOL using
-%  Brent's method. The abscissa of the minimum is returned in xmin, and
-%  the minimum function value is returned in fmin.
-%
-%  References:
-%
-%  Brent, R.P. 1973, Algorithms for Minimization without Derivatives
-%     (Englewood Cliffs, NJ: Prentice Hall), Chapter 5
-%  Press, W.H. et al, 1992,  Numerical recipes in C: the art of scientific
-%     computing (Cambridge University Press), Chapter 10.2
-%
-%  Description of variables:
-%
-%    a, b   the minimum is bracketed between a and b
-%    x      point with the least function value found so far
-%    w      point with the second least function value found so far
-%    v      previous value of w
-%    u      point at which the function was evaluated most recently
-%    xm     midpoint between a and b (the function is not evaluated there)
-%
-%    Note: these points are not necessarily all distinct.
-%
-%    e      movement from best current value in the last iteration step
-%    etemp  movement from the best current value in the second last
-%           iteration step
-%
-%  General principles:
-%
-%    - The parabola is fitted trough the points x, v and w
-%    - To be acceptable the parabolic step must
-%        (i)  fall within the bounding interval (a,b)
-%        (ii) imply a movement from the best current value x that is
-%             *less* than half the movement of the *step before last*
-%    - The code never evaluates the function less than a distance tol1
-%      from a point already evaluated or from a known bracketing point
-%
-% Written by:
-% --
-% John L. Weatherwax                2004-12-11
-%
-% email: wax@alum.mit.edu
-%
-% Please send comments and especially bug reports to the
-% above email address.
-%
-%-----
-
-
-VERBOSE = 0;                % Print steps taken for the solution.
-CGOLD   = (3-sqrt(5))/2;    % golden ratio
-ITMAX   = 100;              % max number of iterations
-ZEPS    = 1e-10;            % absolute error tolerance
-
-% initialization
-e = 0;
-if ax < cx
- a = ax; b = cx;
-else
- a = cx; b = ax;
-end;
-v = bx; w = v; x = w;
-
-%x_in,d_in
-
-fx = feval(f,x_in + x.*d_in); fv = fx; fw = fv;
-FunEvals = 1;
-
-for iter = 1:ITMAX,
- if( VERBOSE )
-   fprintf(1, 'k=%4d, |a-b|=%e\n', iter, abs(a-b));
- end
- xm = 0.5*(a+b);
- tol1 = tol*abs(x) + ZEPS;
- tol2 = 2*tol1;
- % Stopping criterion: equivalent to: max(x-a, b-x) <= tol2
- if abs(x-xm) <= tol2-0.5*(b-a)
-   xmin = x;
-   fmin = fx;
-   return
- end
- if abs(e) > tol1
-   %
-   % The second last move was sufficently large:
-   % let's construct the parabolic fit
-   %
-   r = (x-w)*(fx-fv);
-   q = (x-v)*(fx-fw);
-   p = (x-v)*q - (x-w)*r;
-   q = 2.0*(q-r);
-   if q > 0, p = -p; end
-   q = abs(q);
-   etemp = e;
-   e = d;
-   if abs(p) >= abs(0.5*q*etemp) | p <= q*(a-x) | p >= q*(b-x)
-     %
-     % The parabolic fit did not meet the reqirements above:
-     % use a golden section refinement instead.
-     %
-     % Print an explanation of what condition failed:
-     %
-     if( VERBOSE )
-       if abs(p) >= abs(0.5*q*etemp)
-        % disp('abs(p) >= abs(0.5*q*etemp)')
-       end
-       if p <= q*(a-x)
-         %disp('p <= q*(a-x)')
-       end
-       if p >= q*(b-x)
-         %disp('p >= q*(b-x)')
-       end
-     end
-     %
-     % Set e in such a way, that a parabolic fit is possible in the
-     % next iteration.
-     %
-     if x >= xm
-       e = a-x;
-     else
-       e = b-x;
-     end
-     d = CGOLD*e;
-     if( VERBOSE )
-       disp('golden section step');
-     end
-   else
-     %
-     % the parabolic fit meets the above requirements: use iteration
-     %
-     d = p/q;
-     u = x+d;
-     if u-a < tol2 | b-u < tol2
-       %
-       % the parabolic fit is too close to the boundaries of the
-       % bracketing interval: put new point tol1 apart from the
-       % midpoint
-       %
-       d = tol1*sign(xm-x);
-       if( VERBOSE ) disp('too close to interval boundaries'); end
-     else
-       if( VERBOSE ) disp('parabolic step'); end
-     end
-   end
- else
-   %
-   % The second last move was not sufficently large: use golden section
-   % set e in such a way, that a parabolic fit is possible in the next
-   % iteration.
-   %
-   if x >= xm
-     e = a-x;
-   else
-     e = b-x;
-   end
-   d = CGOLD*e;
-   if( VERBOSE )
-     disp('abs(e) > tol1');
-     disp('golden section step');
-   end
- end
- if abs(d) >= tol1
-   u = x+d;
- else
-   %
-   % u is too close to x: put u farer apart
-   %
-   u = x + tol1*sign(d);
-   if( VERBOSE ) disp('u is too close to x'); end;
- end
- fu = feval(f,x_in + u.*d_in);    % finally evaluate the function
- FunEvals = FunEvals + 1;
- if fu <= fx
-   %
-   % u is better than x: x becomes new boundary
-   %
-   if u >= x
-     a = x;
-   else
-     b = x;
-   end
-   v = w; w = x; x = u;
-   fv = fw; fw = fx; fx = fu;
- else
-   %
-   % x is better than u: u becomes new boundary
-   %
-   if u < x
-     a = u;
-   else
-     b = u;
-   end
-   if fu <= fw | w == x
-     v = w; w = u;
-     fv = fw; fw = fu;
-   elseif fu <= fv | v == x | v == w
-     v = u;
-     fv = fu;
-   end
- end
-end
-error('too many iterations in brent');
\ No newline at end of file
diff --git a/Generator/library/OptimTools/p_cstep.m b/Generator/library/OptimTools/p_cstep.m
deleted file mode 100755
index f024d76..0000000
--- a/Generator/library/OptimTools/p_cstep.m
+++ /dev/null
@@ -1,244 +0,0 @@
-
-
-     function  [stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt,info] ...
-       = p_cstep(stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt,stpmin,stpmax)
-%   Translation of minpack subroutine cstep 
-%   Dianne O'Leary   July 1991
-%     **********
-%
-%     Subroutine cstep
-%
-%     The purpose of cstep is to compute a safeguarded step for
-%     a linesearch and to update an interval of uncertainty for
-%     a minimizer of the function.
-%
-%     The parameter stx contains the step with the least function
-%     value. The parameter stp contains the current step. It is
-%     assumed that the derivative at stx is negative in the
-%     direction of the step. If brackt is set true then a
-%     minimizer has been bracketed in an interval of uncertainty
-%     with endpoints stx and sty.
-%
-%     The subroutine statement is
-%
-%       subroutine cstep(stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt,
-%                        stpmin,stpmax,info)
-% 
-%     where
-%
-%       stx, fx, and dx are variables which specify the step,
-%         the function, and the derivative at the best step obtained
-%         so far. The derivative must be negative in the direction
-%         of the step, that is, dx and stp-stx must have opposite 
-%         signs. On output these parameters are updated appropriately.
-%
-%       sty, fy, and dy are variables which specify the step,
-%         the function, and the derivative at the other endpoint of
-%         the interval of uncertainty. On output these parameters are 
-%         updated appropriately.
-%
-%       stp, fp, and dp are variables which specify the step,
-%         the function, and the derivative at the current step.
-%         If brackt is set true then on input stp must be
-%         between stx and sty. On output stp is set to the new step.
-%
-%       brackt is a logical variable which specifies if a minimizer
-%         has been bracketed. If the minimizer has not been bracketed
-%         then on input brackt must be set false. If the minimizer
-%         is bracketed then on output brackt is set true.
-%
-%       stpmin and stpmax are input variables which specify lower 
-%         and upper bounds for the step.
-%
-%       info is an integer output variable set as follows:
-%         If info = 1,2,3,4,5, then the step has been computed
-%         according to one of the five cases below. Otherwise
-%         info = 0, and this indicates improper input parameters.
-%
-%     Subprograms called
-%
-%       FORTRAN-supplied ... abs,max,min,sqrt
-%                        ... dble
-%
-%     Argonne National Laboratory. MINPACK Project. June 1983
-%     Jorge J. More', David J. Thuente
-%
-%     **********
-      p66 = 0.66;
-      info = 0;
-%
-%     Check the input parameters for errors.
-%
-      if ((brackt & (stp <= min(stx,sty) | ...
-          stp >= max(stx,sty))) | ...
-          dx*(stp-stx) >= 0.0 | stpmax < stpmin) 
-         return
-      end
-%
-%     Determine if the derivatives have opposite sign.
-%
-      sgnd = dp*(dx/abs(dx));
-%
-%     First case. A higher function value.
-%     The minimum is bracketed. If the cubic step is closer
-%     to stx than the quadratic step, the cubic step is taken,
-%     else the average of the cubic and quadratic steps is taken.
-%
-      if (fp > fx) 
-         info = 1;
-         bound = 1;
-         theta = 3*(fx - fp)/(stp - stx) + dx + dp;
-         s = norm([theta,dx,dp],inf);
-         gamma = s*sqrt((theta/s)^2 - (dx/s)*(dp/s));
-         if (stp < stx) 
-             gamma = -gamma;
-         end
-         p = (gamma - dx) + theta;
-         q = ((gamma - dx) + gamma) + dp;
-         r = p/q;
-         stpc = stx + r*(stp - stx);
-         stpq = stx + ((dx/((fx-fp)/(stp-stx)+dx))/2)*(stp - stx);
-         if (abs(stpc-stx) < abs(stpq-stx)) 
-            stpf = stpc;
-         else
-           stpf = stpc + (stpq - stpc)/2;
-         end 
-         brackt = 1;
-%
-%     Second case. A lower function value and derivatives of
-%     opposite sign. The minimum is bracketed. If the cubic
-%     step is closer to stx than the quadratic (secant) step, 
-%     the cubic step is taken, else the quadratic step is taken.
-%
-      elseif (sgnd < 0.0) 
-         info = 2;
-         bound = 0;
-         theta = 3*(fx - fp)/(stp - stx) + dx + dp;
-         s = norm([theta,dx,dp],inf);
-         gamma = s*sqrt((theta/s)^2 - (dx/s)*(dp/s));
-         if (stp > stx) 
-            gamma = -gamma;
-         end
-         p = (gamma - dp) + theta;
-         q = ((gamma - dp) + gamma) + dx;
-         r = p/q;
-         stpc = stp + r*(stx - stp);
-         stpq = stp + (dp/(dp-dx))*(stx - stp);
-         if (abs(stpc-stp) > abs(stpq-stp))
-            stpf = stpc;
-         else
-            stpf = stpq;
-         end 
-         brackt = 1;
-%
-%     Third case. A lower function value, derivatives of the
-%     same sign, and the magnitude of the derivative decreases.
-%     The cubic step is only used if the cubic tends to infinity 
-%     in the direction of the step or if the minimum of the cubic
-%     is beyond stp. Otherwise the cubic step is defined to be 
-%     either stpmin or stpmax. The quadratic (secant) step is also 
-%     computed and if the minimum is bracketed then the the step 
-%     closest to stx is taken, else the step farthest away is taken.
-%
-      elseif (abs(dp) < abs(dx)) 
-         info = 3;
-         bound = 1;
-         theta = 3*(fx - fp)/(stp - stx) + dx + dp;
-         s = norm([theta,dx,dp],inf);
-%
-%        The case gamma = 0 only arises if the cubic does not tend
-%        to infinity in the direction of the step.
-%
-         gamma = s*sqrt(max(0.,(theta/s)^2 - (dx/s)*(dp/s)));
-         if (stp > stx) 
-             gamma = -gamma;
-         end
-         p = (gamma - dp) + theta;
-         q = (gamma + (dx - dp)) + gamma;
-         r = p/q;
-         if (r < 0.0 & gamma ~= 0.0)
-            stpc = stp + r*(stx - stp);
-         elseif (stp > stx)
-            stpc = stpmax;
-         else
-            stpc = stpmin;
-         end 
-         stpq = stp + (dp/(dp-dx))*(stx - stp);
-         if (brackt) 
-            if (abs(stp-stpc) < abs(stp-stpq)) 
-               stpf = stpc;
-            else
-               stpf = stpq;
-            end
-         else
-            if (abs(stp-stpc) > abs(stp-stpq)) 
-               stpf = stpc;
-            else
-               stpf = stpq;
-            end 
-         end 
-%
-%     Fourth case. A lower function value, derivatives of the
-%     same sign, and the magnitude of the derivative does
-%     not decrease. If the minimum is not bracketed, the step
-%     is either stpmin or stpmax, else the cubic step is taken.
-%
-      else
-         info = 4;
-         bound = 0;
-         if (brackt) 
-            theta = 3*(fp - fy)/(sty - stp) + dy + dp;
-            s = norm([theta,dy,dp],inf);
-            gamma = s*sqrt((theta/s)^2 - (dy/s)*(dp/s));
-            if (stp > sty) 
-                gamma = -gamma;
-            end
-            p = (gamma - dp) + theta;
-            q = ((gamma - dp) + gamma) + dy;
-            r = p/q;
-            stpc = stp + r*(sty - stp);
-            stpf = stpc;
-         elseif (stp > stx)
-            stpf = stpmax;
-         else
-            stpf = stpmin;
-         end 
-      end 
-%
-%     Update the interval of uncertainty. This update does not
-%     depend on the new step or the case analysis above.
-%
-      if (fp > fx) 
-         sty = stp;
-         fy = fp;
-         dy = dp;
-      else
-         if (sgnd < 0.0)
-            sty = stx;
-            fy = fx;
-            dy = dx;
-         end 
-         stx = stp;
-         fx = fp;
-         dx = dp;
-      end
-%
-%     Compute the new step and safeguard it.
-%
-      stpf = min(stpmax,stpf);
-      stpf = max(stpmin,stpf);
-      stp = stpf;
-      if (brackt & bound)
-         if (sty > stx) 
-            stp = min(stx+p66*(sty-stx),stp);
-         else
-            stp = max(stx+p66*(sty-stx),stp);
-         end
-      end
-      return
-%
-%     Last card of subroutine cstep.
-%
-
-
-
diff --git a/Generator/library/OptimTools/p_cvsrch.m b/Generator/library/OptimTools/p_cvsrch.m
deleted file mode 100755
index c3d7593..0000000
--- a/Generator/library/OptimTools/p_cvsrch.m
+++ /dev/null
@@ -1,331 +0,0 @@
-function [x,f,g,stp,info,nfev] = p_cvsrch(fcn,x,f,g,s,stp,LineSearch_params)
-%   Translation of minpack subroutine cvsrch
-%   Dianne O'Leary   July 1991
-%     **********
-%
-%     Subroutine cvsrch
-%
-%     The purpose of cvsrch is to find a step which satisfies 
-%     a sufficient decrease condition and a curvature condition.
-%     The user must provide a subroutine which calculates the
-%     function and the gradient.
-%
-%     At each stage the subroutine updates an interval of
-%     uncertainty with endpoints stx and sty. The interval of
-%     uncertainty is initially chosen so that it contains a 
-%     minimizer of the modified function
-%
-%          f(x+stp*s) - f(x) - ftol*stp*(gradf(x)'s).
-%
-%     If a step is obtained for which the modified function 
-%     has a nonpositive function value and nonnegative derivative, 
-%     then the interval of uncertainty is chosen so that it 
-%     contains a minimizer of f(x+stp*s).
-%
-%     The algorithm is designed to find a step which satisfies 
-%     the sufficient decrease condition 
-%
-%           f(x+stp*s) <= f(x) + ftol*stp*(gradf(x)'s),
-%
-%     and the curvature condition
-%
-%           abs(gradf(x+stp*s)'s)) <= gtol*abs(gradf(x)'s).
-%
-%     If ftol is less than gtol and if, for example, the function
-%     is bounded below, then there is always a step which satisfies
-%     both conditions. If no step can be found which satisfies both
-%     conditions, then the algorithm usually stops when rounding
-%     errors prevent further progress. In this case stp only 
-%     satisfies the sufficient decrease condition.
-%
-%     The subroutine statement is
-%
-%        subroutine cvsrch(fcn,n,x,f,g,s,stp,ftol,gtol,xtol,
-%                          stpmin,stpmax,maxfev,info,nfev,wa)
-%     where
-%
-%	fcn is the name of the user-supplied subroutine which
-%         calculates the function and the gradient.  fcn must 
-%      	  be declared in an external statement in the user 
-%         calling program, and should be written as follows.
-%
-%         function [f,g] = fcn(n,x) (Matlab)     (10/2010 change in documentation)
-%	  (derived from Fortran subroutine fcn(n,x,f,g) )
-%         integer n
-%         f
-%         x(n),g(n)
-%	  ----------
-%         Calculate the function at x and
-%         return this value in the variable f.
-%         Calculate the gradient at x and
-%         return this vector in g.
-%	  ----------
-%	  return
-%	  end
-%
-%       n is a positive integer input variable set to the number
-%	  of variables.
-%
-%	x is an array of length n. On input it must contain the
-%	  base point for the line search. On output it contains 
-%         x + stp*s.
-%
-%	f is a variable. On input it must contain the value of f
-%         at x. On output it contains the value of f at x + stp*s.
-%
-%	g is an array of length n. On input it must contain the
-%         gradient of f at x. On output it contains the gradient
-%         of f at x + stp*s.
-%
-%	s is an input array of length n which specifies the
-%         search direction.
-%
-%	stp is a nonnegative variable. On input stp contains an
-%         initial estimate of a satisfactory step. On output
-%         stp contains the final estimate.
-%
-%       ftol and gtol are nonnegative input variables. Termination
-%         occurs when the sufficient decrease condition and the
-%         directional derivative condition are satisfied.
-%
-%	xtol is a nonnegative input variable. Termination occurs
-%         when the relative width of the interval of uncertainty 
-%	  is at most xtol.
-%
-%	stpmin and stpmax are nonnegative input variables which 
-%	  specify lower and upper bounds for the step.
-%
-%	maxfev is a positive integer input variable. Termination
-%         occurs when the number of calls to fcn is at least
-%         maxfev by the end of an iteration.
-%
-%	info is an integer output variable set as follows:
-%	  
-%	  info = 0  Improper input parameters.
-%
-%	  info = 1  The sufficient decrease condition and the
-%                   directional derivative condition hold.
-%
-%	  info = 2  Relative width of the interval of uncertainty
-%		    is at most xtol.
-%
-%	  info = 3  Number of calls to fcn has reached maxfev.
-%
-%	  info = 4  The step is at the lower bound stpmin.
-%
-%	  info = 5  The step is at the upper bound stpmax.
-%
-%	  info = 6  Rounding errors prevent further progress.
-%                   There may not be a step which satisfies the
-%                   sufficient decrease and curvature conditions.
-%                   Tolerances may be too small.
-%
-%       nfev is an integer output variable set to the number of
-%         calls to fcn.
-%
-%	wa is a work array of length n.
-%
-%     Subprograms called
-%
-%	user-supplied......fcn
-%
-%	MINPACK-supplied...cstep
-%
-%	FORTRAN-supplied...abs,max,min
-%	  
-%     Argonne National Laboratory. MINPACK Project. June 1983
-%     Jorge J. More', David J. Thuente
-%
-%     **********
-
-
-ftol = LineSearch_params.ftol;
-gtol = LineSearch_params.gtol;
-xtol = LineSearch_params.xtol;
-stpmin = LineSearch_params.stpmin;
-stpmax = LineSearch_params.stpmax;
-maxfev = LineSearch_params.maxfev;
-
-n = length(x);
-               
-               
-      p5 = .5;
-      p66 = .66;
-      xtrapf = 4;
-      info = 0;
-      infoc = 1;
-
-%
-%     Check the input parameters for errors.
-%
-      if (n <= 0 | stp <= 0.0 | ftol < 0.0 |  ...
-          gtol < 0.0 | xtol < 0.0 | stpmin < 0.0  ...
-          | stpmax < stpmin | maxfev <= 0) 
-         return
-      end
-%
-%     Compute the initial gradient in the search direction
-%     and check that s is a descent direction.
-%
-      dginit = g'*s;
-      if (dginit >= 0.0) 
-          return
-      end
-%
-%     Initialize local variables.
-%
-      brackt = 0;
-      stage1 = 1;
-      nfev = 0;
-      finit = f;
-      dgtest = ftol*dginit;
-      width = stpmax - stpmin;
-      width1 = 2*width;
-      wa = x;
-%
-%     The variables stx, fx, dgx contain the values of the step, 
-%     function, and directional derivative at the best step.
-%     The variables sty, fy, dgy contain the value of the step,
-%     function, and derivative at the other endpoint of
-%     the interval of uncertainty.
-%     The variables stp, f, dg contain the values of the step,
-%     function, and derivative at the current step.
-%
-      stx = 0.0;
-      fx = finit;
-      dgx = dginit;
-      sty = 0.0;
-      fy = finit;
-      dgy = dginit;
-%
-%     Start of iteration.
-%
-   while (1)   
-%
-%        Set the minimum and maximum steps to correspond
-%        to the present interval of uncertainty.
-%
-         if (brackt) 
-            stmin = min(stx,sty);
-            stmax = max(stx,sty);
-         else
-            stmin = stx;
-            stmax = stp + xtrapf*(stp - stx);
-         end 
-%
-%        Force the step to be within the bounds stpmax and stpmin.
-%
-         stp = max(stp,stpmin);
-         stp = min(stp,stpmax);
-%
-%        If an unusual termination is to occur then let 
-%        stp be the lowest point obtained so far.
-%
-         if ((brackt & (stp <= stmin | stp >= stmax)) ...
-            | nfev >= maxfev-1 | infoc == 0 ...
-            | (brackt & stmax-stmin <= xtol*stmax)) 
-            stp = stx;
-         end
-%
-%        Evaluate the function and gradient at stp
-%        and compute the directional derivative.
-%
-         x = wa + stp * s;
-         [f,g] = feval(fcn,x);
-         nfev = nfev + 1;
-         dg = g' * s;
-         ftest1 = finit + stp*dgtest;
-%
-%        Test for convergence.
-%
-         if ((brackt & (stp <= stmin | stp >= stmax)) | infoc == 0) 
-                  info = 6;
-         end
-         if (stp == stpmax & f <= ftest1 & dg <= dgtest) 
-                  info = 5;
-         end
-         if (stp == stpmin & (f > ftest1 | dg >= dgtest)) 
-                  info = 4;
-         end
-         if (nfev >= maxfev) 
-                  info = 3;
-         end
-         if (brackt & stmax-stmin <= xtol*stmax) 
-                  info = 2;
-         end
-         if (f <= ftest1 & abs(dg) <= gtol*(-dginit)) 
-                  info = 1;
-         end
-%
-%        Check for termination.
-%
-         if (info ~= 0) 
-                  return
-         end
-%
-%        In the first stage we seek a step for which the modified
-%        function has a nonpositive value and nonnegative derivative.
-%
-         if (stage1 & f <= ftest1 & dg >= min(ftol,gtol)*dginit) 
-                stage1 = 0;
-         end
-%
-%        A modified function is used to predict the step only if
-%        we have not obtained a step for which the modified
-%        function has a nonpositive function value and nonnegative 
-%        derivative, and if a lower function value has been  
-%        obtained but the decrease is not sufficient.
-%
-         if (stage1 & f <= fx & f > ftest1) 
-%
-%           Define the modified function and derivative values.
-%
-            fm = f - stp*dgtest;
-            fxm = fx - stx*dgtest;
-            fym = fy - sty*dgtest;
-            dgm = dg - dgtest;
-            dgxm = dgx - dgtest;
-            dgym = dgy - dgtest;
-% 
-%           Call cstep to update the interval of uncertainty 
-%           and to compute the new step.
-%
-            [stx,fxm,dgxm,sty,fym,dgym,stp,fm,dgm,brackt,infoc] ...
-             = p_cstep(stx,fxm,dgxm,sty,fym,dgym,stp,fm,dgm, ...
-                     brackt,stmin,stmax);
-%
-%           Reset the function and gradient values for f.
-%
-            fx = fxm + stx*dgtest;
-            fy = fym + sty*dgtest;
-            dgx = dgxm + dgtest;
-            dgy = dgym + dgtest;
-         else
-% 
-%           Call cstep to update the interval of uncertainty 
-%           and to compute the new step.
-%
-            [stx,fx,dgx,sty,fy,dgy,stp,f,dg,brackt,infoc] ...
-             = cstep(stx,fx,dgx,sty,fy,dgy,stp,f,dg, ...
-                     brackt,stmin,stmax);
-         end
-%
-%        Force a sufficient decrease in the size of the
-%        interval of uncertainty.
-%
-         if (brackt) 
-            if (abs(sty-stx) >= p66*width1) 
-              stp = stx + p5*(sty - stx);
-            end
-            width1 = width;
-            width = abs(sty-stx);
-         end
-%
-%        End of iteration.
-%
-     end
-%
-%     Last card of subroutine cvsrch.
-%
-
-
diff --git a/Generator/library/OptimTools/p_func_mnbrak.m b/Generator/library/OptimTools/p_func_mnbrak.m
deleted file mode 100755
index 33df2df..0000000
--- a/Generator/library/OptimTools/p_func_mnbrak.m
+++ /dev/null
@@ -1,99 +0,0 @@
-function [ax,bx,cx,fa,fb,fc,FunEvals] = p_func_mnbrak(func,ax,bx,x_in,d_in)
-
-% brackets a minimum 
-
-%1. Uses a user-defined func.m
-%2. To bracket a minimum from initial guess of ax and bx; see p.393 in Numerical Recipes F77. 
-%3. I added axt=x_in+ax.*d_in, etc, for use in multidimensional conjugate gradient 
-%   calculation, where the search direction is d. In NR, this step is 
-%   performed by the function f1dim on p.413.
-%4. If you are following us, the outputs from these function are all scalars.
-%5. Nothing too interesting here, unless you are hunting a bug.
-
-GOLD=1.618034;
-GLIMIT=100.;
-TINY=1.e-20;
-
-axt=x_in+ax.*d_in;
-[fa]=feval(func,axt);
-FunEvals = 1;
-bxt=x_in+bx.*d_in;
-[fb]=feval(func,bxt);
-FunEvals = FunEvals + 1;
-
-if fb > fa 
-  dum=ax;
-  ax=bx;
-  bx=dum;
-  dum=fb;
-  fb=fa;
-  fa=dum;
-end
-
-%first guess for c
-cx=bx+GOLD.*(bx-ax);
-cxt=x_in+cx.*d_in;
-[fc]=feval(func,cxt);
-FunEvals = FunEvals + 1;
-
-while fb >= fc
-
-     r=(bx-ax).*(fb-fc);
-     q=(bx-cx).*(fb-fa);
-     u=bx-((bx-cx).*q-(bx-ax).*r)./(2.*abs(max(abs(q-r),TINY)).*sign(q-r));
-     
-     if (2.*abs(max(abs(q-r),TINY)).*sign(q-r))==0
-  %       3.134
-     end
-     ulim=bx+GLIMIT.*(cx-bx);
-     if (bx-u).*(u-cx) > 0. 
-        ut=x_in+u.*d_in;
-        [fu]=feval(func,ut);
-        FunEvals = FunEvals + 1;
-        if fu < fc  
-           ax=bx;
-           fa=fb;
-           bx=u;
-           fb=fu;
-           break;
-        elseif fu > fb 
-           cx=u;
-           fc=fu;
-           break;
-        end
-        u=cx+GOLD.*(cx-bx);
-        ut=x_in+u.*d_in;
-        [fu]=feval(func,ut);
-        FunEvals = FunEvals + 1;
-     elseif (cx-u).*(u-ulim) > 0. 
-        ut=x_in+u.*d_in; 
-        [fu]=feval(func,ut);
-        FunEvals = FunEvals + 1;
-        if fu < fc 
-           bx=cx;
-           cx=u;
-           u=cx+GOLD.*(cx-bx);
-           fb=fc;
-           fc=fu;
-           ut=x_in+u.*d_in;
-           [fu]=feval(func,ut);
-           FunEvals = FunEvals + 1;
-        end
-     elseif (u-ulim).*(ulim-cx) >= 0 
-           u=ulim;
-           ut=x_in+u.*d_in;
-           [fu]=feval(func,ut);
-           FunEvals = FunEvals + 1;
-     else
-            u=cx+GOLD.*(cx-bx);
-            ut=x_in+u.*d_in;
-            [fu]=feval(func,ut);
-            FunEvals = FunEvals + 1;
-     end
-     ax=bx;
-     bx=cx;
-     cx=u;
-     fa=fb;
-     fb=fc;
-     fc=fu;
-end    
\ No newline at end of file
diff --git a/Generator/library/OptimTools/p_initial0.m b/Generator/library/OptimTools/p_initial0.m
deleted file mode 100755
index 5fc1d61..0000000
--- a/Generator/library/OptimTools/p_initial0.m
+++ /dev/null
@@ -1,25 +0,0 @@
-function c = p_initial0(x, fval, g, LineSearch_params)
-%
-%  This should be used only for first iteration
-%
-%  x    = initial guess at unknowns
-%  fval = initial function value
-%  g    = initial gradient 
-%  LineSearc_params = structure containing stuff needed for the line
-%                     search. 
-
-psi0 = LineSearch_params.psi0;
-
-%
-%  Need to check if some values are approximately zero. So use
-%  MATLAB's eps for this (double precision is approximately 2.2204e-16).
-%
-zeroTol = eps;
-
-if norm(x) > zeroTol
-  c = psi0*max(abs(x))/max(abs(g));
-elseif abs(fval) > zeroTol
-  c = psi0*abs(fval)/(g'*g);
-else
-  c = 1;
-end
diff --git a/Generator/library/PhaseReconTools/.DS_Store b/Generator/library/PhaseReconTools/.DS_Store
deleted file mode 100644
index 5008ddf..0000000
Binary files a/Generator/library/PhaseReconTools/.DS_Store and /dev/null differ
diff --git a/Generator/library/PhaseReconTools/._.DS_Store b/Generator/library/PhaseReconTools/._.DS_Store
deleted file mode 100644
index f5e3c80..0000000
Binary files a/Generator/library/PhaseReconTools/._.DS_Store and /dev/null differ
diff --git a/Generator/library/PhaseReconTools/._ComputeGradx.m b/Generator/library/PhaseReconTools/._ComputeGradx.m
deleted file mode 100755
index bd90d5f..0000000
Binary files a/Generator/library/PhaseReconTools/._ComputeGradx.m and /dev/null differ
diff --git a/Generator/library/PhaseReconTools/._ComputeGrady.m b/Generator/library/PhaseReconTools/._ComputeGrady.m
deleted file mode 100755
index bd90d5f..0000000
Binary files a/Generator/library/PhaseReconTools/._ComputeGrady.m and /dev/null differ
diff --git a/Generator/library/PhaseReconTools/._GradxMatrix.m b/Generator/library/PhaseReconTools/._GradxMatrix.m
deleted file mode 100755
index 115074d..0000000
Binary files a/Generator/library/PhaseReconTools/._GradxMatrix.m and /dev/null differ
diff --git a/Generator/library/PhaseReconTools/._GradyMatrix.m b/Generator/library/PhaseReconTools/._GradyMatrix.m
deleted file mode 100755
index 115074d..0000000
Binary files a/Generator/library/PhaseReconTools/._GradyMatrix.m and /dev/null differ
diff --git a/Generator/library/PhaseReconTools/._MakeMask.m b/Generator/library/PhaseReconTools/._MakeMask.m
deleted file mode 100755
index 6a569c9..0000000
Binary files a/Generator/library/PhaseReconTools/._MakeMask.m and /dev/null differ
diff --git a/Generator/library/PhaseReconTools/._MosaicPadding.m b/Generator/library/PhaseReconTools/._MosaicPadding.m
deleted file mode 100755
index bd90d5f..0000000
Binary files a/Generator/library/PhaseReconTools/._MosaicPadding.m and /dev/null differ
diff --git a/Generator/library/PhaseReconTools/._PhaseTranspSolve.m b/Generator/library/PhaseReconTools/._PhaseTranspSolve.m
deleted file mode 100755
index bd90d5f..0000000
Binary files a/Generator/library/PhaseReconTools/._PhaseTranspSolve.m and /dev/null differ
diff --git a/Generator/library/PhaseReconTools/._PhaseTranspSolve_fast.m b/Generator/library/PhaseReconTools/._PhaseTranspSolve_fast.m
deleted file mode 100755
index 24a9f92..0000000
Binary files a/Generator/library/PhaseReconTools/._PhaseTranspSolve_fast.m and /dev/null differ
diff --git a/Generator/library/PhaseReconTools/._PunchOutFrames.m b/Generator/library/PhaseReconTools/._PunchOutFrames.m
deleted file mode 100755
index bd90d5f..0000000
Binary files a/Generator/library/PhaseReconTools/._PunchOutFrames.m and /dev/null differ
diff --git a/Generator/library/PhaseReconTools/._inpaintn.m b/Generator/library/PhaseReconTools/._inpaintn.m
deleted file mode 100755
index bd90d5f..0000000
Binary files a/Generator/library/PhaseReconTools/._inpaintn.m and /dev/null differ
diff --git a/Generator/library/PhaseReconTools/ComputeGradx.m b/Generator/library/PhaseReconTools/ComputeGradx.m
deleted file mode 100755
index 77ec226..0000000
--- a/Generator/library/PhaseReconTools/ComputeGradx.m
+++ /dev/null
@@ -1,47 +0,0 @@
-function phase_gradx = ComputeGradx(phase, pupil_mask)
-%
-%     phase_gradx = ComputeGradx(phase, pupil_mask);
-%
-%  This function can be used to compute gradients of a phase, assuming
-%  a Fried geometry of the WFS.
-%
-%  Input:
-%    phase      - array containing phases -- could be 3D
-%
-%  Optional Input:
-%    pupil_mask - array defining pupil mask -- could be 3D.
-%                     2D array ==> pupil mask is the same for each phase
-%                     3D array ==> size(pupil_mask) = size(phase)
-%                 If this is given, then the phase is padded outside
-%                 the pupil mask using an inpainting technique.
-%
-%  Output:
-%    phase_gradx - computed gradients
-%                  array same size as phase
-%
-%
-if nargin == 1
-  pupil_mask = [];
-end
-
-[m_ap, n_ap, n_frames] = size(phase);
-if m_ap ~= n_ap
-  error('Expected input frames to be square')
-end
-
-Dx = GradxMatrix(n_ap);
-
-if ~isempty(pupil_mask)
-  if size(pupil_mask,3) ~= size(phase,3)
-    pupil_mask = pupil_mask(:,:,ones(1,n_frames));
-  end
-  for k = 1:n_frames
-    phase(:,:,k) = MosaicPadding(phase(:,:,k), pupil_mask(:,:,k));
-  end
-end
-
-phase_gradx = zeros(size(phase));
-for k = 1:n_frames
-  phase_gradx(:,:,k) = pupil_mask(:,:,k).*reshape(Dx*reshape(phase(:,:,k),n_ap*n_ap,1),n_ap,n_ap);
-end
-
diff --git a/Generator/library/PhaseReconTools/ComputeGrady.m b/Generator/library/PhaseReconTools/ComputeGrady.m
deleted file mode 100755
index f6f35ee..0000000
--- a/Generator/library/PhaseReconTools/ComputeGrady.m
+++ /dev/null
@@ -1,47 +0,0 @@
-function phase_grady = ComputeGrady(phase, pupil_mask)
-%
-%     phase_grady = ComputeGrady(phase, pupil_mask);
-%
-%  This function can be used to compute gradients of a phase, assuming
-%  a Fried geometry of the WFS.
-%
-%  Input:
-%    phase      - array containing phases -- could be 3D
-%
-%  Optional Input:
-%    pupil_mask - array defining pupil mask -- could be 3D.
-%                     2D array ==> pupil mask is the same for each phase
-%                     3D array ==> size(pupil_mask) = size(phase)
-%                 If this is given, then the phase is padded outside
-%                 the pupil mask using an inpainting technique.
-%
-%  Output:
-%    phase_gradx - computed gradients
-%                  array same size as phase
-%
-%
-if nargin == 1
-  pupil_mask = [];
-end
-
-[m_ap, n_ap, n_frames] = size(phase);
-if m_ap ~= n_ap
-  error('Expected input frames to be square')
-end
-
-Dy = GradyMatrix(n_ap);
-
-if ~isempty(pupil_mask)
-  if size(pupil_mask,3) ~= size(phase,3)
-    pupil_mask = pupil_mask(:,:,ones(1,n_frames));
-  end
-  for k = 1:n_frames
-    phase(:,:,k) = MosaicPadding(phase(:,:,k), pupil_mask(:,:,k));
-  end
-end
-
-phase_grady = zeros(size(phase));
-for k = 1:n_frames
-  phase_grady(:,:,k) = pupil_mask(:,:,k).*reshape(Dy*reshape(phase(:,:,k),n_ap*n_ap,1),n_ap,n_ap);
-end
-
diff --git a/Generator/library/PhaseReconTools/GradxMatrix.m b/Generator/library/PhaseReconTools/GradxMatrix.m
deleted file mode 100755
index 7a192ba..0000000
--- a/Generator/library/PhaseReconTools/GradxMatrix.m
+++ /dev/null
@@ -1,43 +0,0 @@
-function Dx = GradxMatrix(n, scale)
-%
-%  Dx = GradxMatrix(n, scale);
-%
-% Generates a sparse matrix that models computation of x-gradients
-% obtained by a wavefront sensor with Fried geometry.
-%
-% Important Remarks:
-%    1. The geometry is strange -- this computes what really seems like
-%       a y-gradient.  However, this code constructs a matrix that is
-%       consistent with what is found in the adaptive optics literature.
-%       See ...
-%    2. However, we do make one change with previously published papers:
-%       Our Dx is -1 times what is found in the above cited literature.  
-%    3. We are currently implementing this with a reflective boundary
-%       condition.
-%
-% Input:
-%   n  -    number of pixels across the image (assumed square)
-%
-% Optional Input:
-%   scale - allows for a normalization scale for specific geometries.
-%           Default is to use scale = 1;
-%
-% Output:
-%   Dx -    n^2 x n^2 sparse matrix
-%
-
-if nargin == 1
-  scale = [];
-end
-if isempty(scale)
-  scale = 1;
-end
-
-e = ones(n, 1);
-d1 = [e(1:n-1); 2];
-d2 = [e(1:n-1); 0];
-
-H = spdiags([-d2, e], 0:1, n, n);
-F = .5*spdiags([d1, e], 0:1, n, n);
-
-Dx = scale*kron(F, H);
diff --git a/Generator/library/PhaseReconTools/GradyMatrix.m b/Generator/library/PhaseReconTools/GradyMatrix.m
deleted file mode 100755
index 660e957..0000000
--- a/Generator/library/PhaseReconTools/GradyMatrix.m
+++ /dev/null
@@ -1,43 +0,0 @@
-function Dy = GradyMatrix(n, scale)
-%
-%  Dy = GradyMatrix(n, scale);
-%
-% Generates a sparse matrix that models computation of y-gradients
-% obtained by a wavefront sensor with Fried geometry.
-%
-% Important Remarks:
-%    1. The geometry is strange -- this computes what really seems like
-%       a x-gradient.  However, this code constructs a matrix that is
-%       consistent with what is found in the adaptive optics literature.
-%       See ...
-%    2. However, we do make one change with previously published papers:
-%       Our Dy is -1 times what is found in the above cited literature.  
-%    3. We are currently implementing this with a reflective boundary
-%       condition.
-%
-% Input:
-%   n  -    number of pixels across the image (assumed square)
-%
-% Optional Input:
-%   scale - allows for a normalization scale for specific geometries.
-%           Default is to use scale = 1;
-%
-% Output:
-%   Dy -    n^2 x n^2 sparse matrix
-%
-
-if nargin == 1
-  scale = [];
-end
-if isempty(scale)
-  scale = 1;
-end
-
-e = ones(n, 1);
-d1 = [e(1:n-1); 2];
-d2 = [e(1:n-1); 0];
-
-H = spdiags([-d2, e], 0:1, n, n);
-F = .5*spdiags([d1, e], 0:1, n, n);
-
-Dy = scale*kron(H, F);
diff --git a/Generator/library/PhaseReconTools/MakeMask.m b/Generator/library/PhaseReconTools/MakeMask.m
deleted file mode 100755
index 272941f..0000000
--- a/Generator/library/PhaseReconTools/MakeMask.m
+++ /dev/null
@@ -1,35 +0,0 @@
-function [mask] = MakeMask(n, r1, r0)
-%
-%  [mask] = MakeMask(n, r1, r0)
-%  [mask] = MakeMask(n, r1)
-%
-%  Constructs an n by n mask with outer radius r1.  If only two input
-%  arguments are given, the mask is circular.  Otherwise, it is annular
-%  with inner radius r0.  The largest circle contained in the n by n square
-%  has radius r1 = 1.
-%
-%  We assume n is an even integer. The central pixel has index
-%  (n+1)/2.
-%
-%  Inputs:
-%    n - size of mask to be constructed
-%    r1 - outer radius
-%    r0 - inner radius, if annular
-%
-%  Outputs:
-%    mask - array of 1s and 0s representing the mask
-%
-% Author: John Bardsley, Sarah Knepper
-% Date Created: 27 September 2009
-% Date Last Modified: 27 September 2009
-%
-
-h = 2/n;
-x = [-1:h:1-h]';
-onevec = ones(n,1);
-r = sqrt((x*onevec').^2 + (onevec*x').^2);
-if nargin == 2
-  mask = (r <= r1); 
-else
-  mask = (r0 <= r) & (r <= r1);
-end
diff --git a/Generator/library/PhaseReconTools/MosaicPadding.m b/Generator/library/PhaseReconTools/MosaicPadding.m
deleted file mode 100755
index 7dfebd6..0000000
--- a/Generator/library/PhaseReconTools/MosaicPadding.m
+++ /dev/null
@@ -1,25 +0,0 @@
-function image_frames = MosaicPadding(image_frames, pupil_mask)
-%
-%  When building the mosaic images from set of frames, there
-%  might be issues from boundary artifacts if the region of interest
-%  is not known throughout the whole domain.  In particular, it
-%  it is only known in a region defined by the pupil_mask.
-%  This function will use inpainting techniques to fill in the
-%  missing regions, and hopefully avoid the boundary artifacts
-%  when we use ReconMosaic.m
-%
-%  Note that if we are using this for a multi-layer FFH problem,
-%  we might build mosaics for each layer.  But we need only do
-%  this padding once.
-%
-
-[m, n, nframes] = size(image_frames);
-
-%h = waitbar(0,'Start padding ...');
-for k = 1:nframes
-  X = image_frames(:,:,k);
-  X(~pupil_mask) = NaN;
-  image_frames(:,:,k) = inpaintn(X);
-  %waitbar(k/nframes,h)
-end
-%close(h)
diff --git a/Generator/library/PhaseReconTools/PhaseTranspSolve.m b/Generator/library/PhaseReconTools/PhaseTranspSolve.m
deleted file mode 100755
index e408271..0000000
--- a/Generator/library/PhaseReconTools/PhaseTranspSolve.m
+++ /dev/null
@@ -1,89 +0,0 @@
-function [phase_gradx, phase_grady] = PhaseTranspSolve(phase, pupil_mask, scale, alpha, method)
-%
-%    [phase_gradx, phase_grady] = ReconstructPhase_fast(phase, pupil_mask, alpha);
-%
-%  This function is needed in the MFBD codes.  In particular, we need
-%  to apply the transpose of the phase reconstructor to an array, which
-%  has dimensions the same as a phase on a single frame.
-%  We assume a Fried geometry of the wavefront sensor.
-%
-%  Input:
-%    phase       - array containing x-gradients of phases.  This can be
-%                  either a 2D or a 3D array.  In case of 3D, each 2D
-%                  slice, phase(:,:,k), can be a 
-%                  particular frame of data.
-%    pupil_mask  - pupil mask for phases.  If a 2D array, then it is
-%                  that each phase has the same pupil mask.
-%
-%  Optional Input:
-%    scale       - allows for a normalization scale for specific geometries.
-%                  Default is to use scale = 1;
-%    alpha       - Tikhonov regularization parameter. Default is
-%                  alpha = sqrt(eps).
-%    method      - character string, either 'direct' or 'lsqr'.
-%                  direct:    Tikhonov regularized least squares problems
-%                             are solved by MATLAB's backslash operator,  
-%                             exploiting sparse matrix tools.
-%                  iterative: Tikhonov regularized least squares problems
-%                             are solved using the iterative method LSQR.
-%                  Default is 'direct'.
-%
-%  Output:
-%    phase_gradx - an array in the phase x-gradient space.
-%    phase_grady - an array in the phase y-gradient space
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-%
-%  Check inputs and set default values.
-%
-narginchk(2, 5);
-switch nargin
-  case 2
-    scale = []; alpha = []; method = [];
-  case 3
-    alpha = []; method = [];
-  case 4
-    method = [];
-end
-
-if isempty(scale)
-  scale = 1;
-end
-if isempty(alpha)
-  alpha = sqrt(sqrt(eps));
-end
-if isempty(method)
-  method = 'direct';
-end
-alpha = scale*alpha;
-
-%
-%  This can help reduce some boundary artifacts ...
-%
-pad_size = 1;
-phase  = padarray(padarray(phase, [pad_size, pad_size], 'pre'),[pad_size pad_size],'post');
-pupil_mask  = padarray(padarray(pupil_mask, [pad_size, pad_size], 'pre'),[pad_size pad_size],'post');
-
-% phase = padarray(phase, [pad_size, pad_size], 'both');
-% pupil_mask = padarray(pupil_mask, [pad_size, pad_size], 'both');
-
-[m_ap, n_ap, n_frames] = size(phase);
-
-Dx = GradxMatrix(n_ap, scale);
-Dy = GradyMatrix(n_ap, scale);
-P = spdiags(reshape(pupil_mask,n_ap*n_ap,1), 0, n_ap*n_ap, n_ap*n_ap);
-A = Dx'*P'*P*Dx + Dy'*P'*P*Dy + alpha*alpha*speye(n_ap*n_ap);
-
-w = A\reshape(phase, n_ap*n_ap, n_frames);
-phase_gradx = reshape(P*Dx*w, n_ap, n_ap, n_frames);
-phase_grady = reshape(P*Dy*w, n_ap, n_ap, n_frames);
-
-phase_gradx = phase_gradx(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
-phase_grady = phase_grady(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
-
-
diff --git a/Generator/library/PhaseReconTools/PhaseTranspSolve_fast.m b/Generator/library/PhaseReconTools/PhaseTranspSolve_fast.m
deleted file mode 100755
index 5a5a362..0000000
--- a/Generator/library/PhaseReconTools/PhaseTranspSolve_fast.m
+++ /dev/null
@@ -1,86 +0,0 @@
-function [phase_gradx, phase_grady] = PhaseTranspSolve_fast(phase, pupil_mask, scale, alpha, method)
-%
-%    [phase_gradx, phase_grady] = ReconstructPhase_fast(phase, pupil_mask, alpha);
-%
-%  This function is needed in the MFBD codes.  In particular, we need
-%  to apply the transpose of the phase reconstructor to an array, which
-%  has dimensions the same as a phase on a single frame.
-%  We assume a Fried geometry of the wavefront sensor.
-%
-%  Input:
-%    phase       - array containing x-gradients of phases.  This can be
-%                  either a 2D or a 3D array.  In case of 3D, each 2D
-%                  slice, phase(:,:,k), can be a 
-%                  particular frame of data.
-%    pupil_mask  - pupil mask for phases.  If a 2D array, then it is
-%                  that each phase has the same pupil mask.
-%
-%  Optional Input:
-%    scale       - allows for a normalization scale for specific geometries.
-%                  Default is to use scale = 1;
-%    alpha       - Tikhonov regularization parameter. Default is
-%                  alpha = sqrt(eps).
-%    method      - character string, either 'direct' or 'lsqr'.
-%                  direct:    Tikhonov regularized least squares problems
-%                             are solved by MATLAB's backslash operator,  
-%                             exploiting sparse matrix tools.
-%                  iterative: Tikhonov regularized least squares problems
-%                             are solved using the iterative method LSQR.
-%                  Default is 'direct'.
-%
-%  Output:
-%    phase_gradx - an array in the phase x-gradient space.
-%    phase_grady - an array in the phase y-gradient space
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-%
-%  Check inputs and set default values.
-%
-narginchk(2, 5);
-switch nargin
-  case 2
-    scale = []; alpha = []; method = [];
-  case 3
-    alpha = []; method = [];
-  case 4
-    method = [];
-end
-
-if isempty(scale)
-  scale = 1;
-end
-if isempty(alpha)
-  alpha = sqrt(sqrt(eps));
-end
-if isempty(method)
-  method = 'direct';
-end
-alpha = scale*alpha;
-
-%
-%  This can help reduce some boundary artifacts ...
-%
-pad_size = 1;
-phase = padarray(phase, [pad_size, pad_size], 'both');
-pupil_mask = padarray(pupil_mask, [pad_size, pad_size], 'both');
-
-[m_ap, n_ap, n_frames] = size(phase);
-
-Dx = GradxMatrix(n_ap, scale);
-Dy = GradyMatrix(n_ap, scale);
-P = spdiags(reshape(pupil_mask,n_ap*n_ap,1), 0, n_ap*n_ap, n_ap*n_ap);
-A = Dx'*P'*P*Dx + Dy'*P'*P*Dy + alpha*alpha*speye(n_ap*n_ap);
-
-w = A\reshape(phase, n_ap*n_ap, n_frames);
-phase_gradx = reshape(P*Dx*w, n_ap, n_ap, n_frames);
-phase_grady = reshape(P*Dy*w, n_ap, n_ap, n_frames);
-
-phase_gradx = phase_gradx(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
-phase_grady = phase_grady(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
-
-
diff --git a/Generator/library/PhaseReconTools/PunchOutFrames.m b/Generator/library/PhaseReconTools/PunchOutFrames.m
deleted file mode 100755
index 4966686..0000000
--- a/Generator/library/PhaseReconTools/PunchOutFrames.m
+++ /dev/null
@@ -1,30 +0,0 @@
-function phase = PunchOutFrames(phaseC, A, W, n_frames, n_layers, n_comp, n_ap)
-%
-%  phase = PunchOutFrames(phaseC, A, W, n_frames, n_layers, n_comp, n_ap);
-%
-%  Input:
-%    phaseC   - composite information (could be phases or gradients)
-%               for each astmospheric layer
-%    A, W     - sparse matrices that model the FFM process of WFS data 
-%               collection.
-%    n_frames - number of frames of data
-%    n_layers - number of atmospheric layers
-%    n_comp   - size of composite grid
-%    n_ap     - size of aperture
-%
-%  Output
-%    phase    - punnched out versions of input on each frame
-%
-
-%
-%  J. Nagy
-%  August, 2012
-%
-
-N = n_comp*n_comp;
-phaseC_vec = zeros(N*n_layers,1);
-for L = 1:n_layers
-  phaseC_vec((L-1)*N+1:L*N,1) = reshape(phaseC(:,:,L),n_comp*n_comp,1);
-end
-phase_vec = kron(speye(n_frames),W)*A*phaseC_vec;
-phase = reshape(phase_vec, n_ap, n_ap, n_frames);
\ No newline at end of file
diff --git a/Generator/library/PhaseReconTools/inpaintn.m b/Generator/library/PhaseReconTools/inpaintn.m
deleted file mode 100755
index 60cdf86..0000000
--- a/Generator/library/PhaseReconTools/inpaintn.m
+++ /dev/null
@@ -1,217 +0,0 @@
-function y = inpaintn(x,n,y0)
-
-% INPAINTN Inpaint over missing data in N-D array
-%   Y = INPAINTN(X) replaces the missing data in X by extra/interpolating
-%   the non-missing elements. The non finite values (NaN or Inf) in X are
-%   considered as missing data. X can be any N-D array.
-%
-%   INPAINTN (no input/output argument) runs the following 3-D example.
-%
-%   Important note:
-%   --------------
-%   INPAINTN uses an iterative process that converges toward the solution.
-%   Y = INPAINTN(X,N) uses N iterations. By default, N = 100. If you
-%   estimate that INPAINTN did not totally converge, increase N:
-%   Y = INPAINTN(X,1000);
-%
-%   Y = INPAINTN(X,N,Y0) uses Y0 as initial guess. This could be useful if
-%   you want to run the process a second time or if you have a GOOD guess
-%   of the final result. By default, INPAINTN makes a nearest neighbor
-%   interpolation (by using BWDIST) to obtain a rough guess.
-%
-%   Notes:
-%   -----
-%   <a href="matlab:web('http://www.mathworks.com/matlabcentral/fileexchange/4551')">INPAINT_NANS</a> and <a href="matlab:web('http://www.mathworks.com/matlabcentral/fileexchange/21214')">INPAINT_NANS3</a> are much faster than INPAINTN when
-%   the number of NaN elements is (relatively) small. However, because
-%   INPAINT_NANS and INPAINT_NANS3 both involve huge matrices, they can be
-%   limited with large datasets.
-%
-%   Examples
-%   --------
-%
-%     %% ---- Image ---- %%
-%     onion = imread('onion.png');
-%     I = randperm(numel(onion));
-%     onionNaN = double(onion); onionNaN(I(1:round(numel(I)*0.5))) = NaN;
-%     subplot(211), imshow(uint8(onionNaN)), title('Corrupted image - 50%')
-%     for k=1:3, onion(:,:,k) = inpaintn(onionNaN(:,:,k)); end
-%     subplot(212), imshow(uint8(onion)), title('Inpainted image')
-%
-%     %% ---- 3-D data ---- %%
-%     load wind
-%     xmin = min(x(:)); xmax = max(x(:));
-%     zmin = min(z(:)); ymax = max(y(:));
-%     %-- wind velocity
-%     vel0 = interp3(sqrt(u.^2+v.^2+w.^2),1,'cubic');
-%     x = interp3(x,1); y = interp3(y,1); z = interp3(z,1);
-%     %-- remove randomly 90% of the data
-%     I = randperm(numel(vel0));
-%     velNaN = vel0;
-%     velNaN(I(1:round(numel(I)*.9))) = NaN;
-%     %-- inpaint using INPAINTN
-%     vel = inpaintn(velNaN);
-%     %-- display the results
-%     subplot(221), imagesc(velNaN(:,:,15)), axis equal off
-%     title('Corrupt plane, z = 15')
-%     subplot(222), imagesc(vel(:,:,15)), axis equal off
-%     title('Reconstructed plane, z = 15')    
-%     subplot(223)
-%     hsurfaces = slice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);
-%     set(hsurfaces,'FaceColor','interp','EdgeColor','none')
-%     hcont = contourslice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);
-%     set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)
-%     view(3), daspect([2,2,1]), axis tight
-%     title('Original data compared with...')
-%     subplot(224)
-%     hsurfaces = slice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);
-%     set(hsurfaces,'FaceColor','interp','EdgeColor','none')
-%     hcont = contourslice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);
-%     set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)
-%     view(3), daspect([2,2,1]), axis tight
-%     title('... reconstructed data')
-%
-%     %% --- 4-D data --- %%
-%     [x1,x2,x3,x4] = ndgrid(-2:0.2:2);
-%     z0 = x2.*exp(-x1.^2-x2.^2-x3.^2-x4.^2);
-%     I = randperm(numel(z0));
-%     % remove 50% of the data
-%     zNaN = z0; zNaN(I(1:round(numel(I)*.5))) = NaN;
-%     % reconstruct the data using INPAINTN
-%     z = inpaintn(zNaN);
-%     % display the results (for x4 = 0)
-%     subplot(211)
-%     zNaN(isnan(zNaN)) = 0.5;
-%     slice(x2(:,:,:,1),x1(:,:,:,1),x3(:,:,:,1),zNaN(:,:,:,11),...
-%        [-1.2 0.8 2],2,[-2 0.2])
-%     title('Corrupt data, x4 = 0')
-%     subplot(212)
-%     slice(x2(:,:,:,1),x1(:,:,:,1),x3(:,:,:,1),z(:,:,:,11),...
-%        [-1.2 0.8 2],2,[-2 0.2])
-%     title('Reconstructed data')
-%
-%   See also GRIDDATAN, INPAINT_NANS, INPAINT_NANS3
-%
-%   -- Damien Garcia -- 2010/06
-%   website: <a
-%   href="matlab:web('http://www.biomecardio.com')">www.BiomeCardio.com</a>
-
-test4DCTNandIDCTN
-
-if nargin==0&&nargout==0, RunTheExample, return, end
-
-x = double(x);
-if nargin==1, n = 100; end
-
-sizx = size(x);
-d = ndims(x);
-Lambda = zeros(sizx);
-for i = 1:d
-    siz0 = ones(1,d);
-    siz0(i) = sizx(i);
-    Lambda = bsxfun(@plus,Lambda,...
-        cos(pi*(reshape(1:sizx(i),siz0)-1)/sizx(i)));
-end
-Lambda = -2*(d-Lambda);
-
-% Initial condition
-W = isfinite(x);
-if nargin==3
-    y = y0;
-    s0 = 0;
-else
-    if any(~W(:))
-        [y,s0] = InitialGuess(x,isfinite(x));
-    else
-        y = x;
-        return
-    end
-end
-x(~W) = 0;
-
-% Smoothness parameters: from high to negligible values
-s = logspace(s0,-3,n);
-
-RF = 2; % relaxation factor
-Lambda = Lambda.^2;
-
-%h = waitbar(0,'Inpainting...');
-for i = 1:n
-        Gamma = 1./(1+s(i)*Lambda);
-        y = RF*idct2(Gamma.*dct2(W.*(x-y)+y)) + (1-RF)*y;
-%        waitbar(i/n,h)
-end
-%close(h)
-
-y(W) = x(W);
-
-end
-
-%% Test for DCTN and IDCTN
-function test4DCTNandIDCTN
-    if ~exist('dct2','file')
-        error('MATLAB:smoothn:MissingFunction',...
-            ['DCTN and IDCTN are required. Download DCTN <a href="matlab:web(''',...
-            'http://www.biomecardio.com/matlab/dctn.html'')">here</a>.'])
-    elseif ~exist('idct2','file')
-        error('MATLAB:smoothn:MissingFunction',...
-            ['DCTN and IDCTN are required. Download IDCTN <a href="matlab:web(''',...
-            'http://www.biomecardio.com/matlab/idctn.html'')">here</a>.'])
-    end
-end
-
-%% Initial Guess
-function [z,s0] = InitialGuess(y,I)
-
-if license('test','image_toolbox')
-    %-- nearest neighbor interpolation
-    [z,L] = bwdist(I);
-    z = y;
-    z(~I) = y(L(~I));
-    s0 = 3;
-else
-    warning('MATLAB:inpaintn:InitialGuess',...
-        ['BWDIST (Image Processing Toolbox) does not exist. ',...
-        'The initial guess may not be optimal; additional',...
-        ' iterations can thus be required to ensure complete',...
-        ' convergence. Increase N value if necessary.'])
-    z = y;
-    z(~I) = mean(y(I));
-    s0 = 6;
-end
-
-end
-
-%% Example (3-D)
-function RunTheExample
-      load wind
-      xmin = min(x(:)); xmax = max(x(:));
-      zmin = min(z(:)); ymax = max(y(:));
-      %-- wind velocity
-      vel0 = interp3(sqrt(u.^2+v.^2+w.^2),1,'cubic');
-      x = interp3(x,1); y = interp3(y,1); z = interp3(z,1);
-      %-- remove randomly 90% of the data
-      I = randperm(numel(vel0));
-      velNaN = vel0;
-      velNaN(I(1:round(numel(I)*.9))) = NaN;
-      %-- inpaint using INPAINTN
-      vel = inpaintn(velNaN);
-      %-- display the results
-      subplot(221), imagesc(velNaN(:,:,15)), axis equal off
-      title('Corrupt plane, z = 15')
-      subplot(222), imagesc(vel(:,:,15)), axis equal off
-      title('Reconstructed plane, z = 15')    
-      subplot(223)
-      hsurfaces = slice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);
-      set(hsurfaces,'FaceColor','interp','EdgeColor','none')
-      hcont = contourslice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);
-      set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)
-      view(3), daspect([2,2,1]), axis tight
-      title('Original data compared with...')
-      subplot(224)
-      hsurfaces = slice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);
-      set(hsurfaces,'FaceColor','interp','EdgeColor','none')
-      hcont = contourslice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);
-      set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)
-      view(3), daspect([2,2,1]), axis tight
-      title('... reconstructed data')
-end
diff --git a/Generator/library/ReconstructPhase_Layers.m b/Generator/library/ReconstructPhase_Layers.m
deleted file mode 100644
index bb84807..0000000
--- a/Generator/library/ReconstructPhase_Layers.m
+++ /dev/null
@@ -1,141 +0,0 @@
-function phase_layers = ReconstructPhase_Layers(A, W, FFM_input, FFM_output, FFM_options)
-%
-%    phase_layers = ReconstructPhaseC(FFM_input, FFM_output, FFM_options);
-%
-%  This function reconstructs the COMPOSITE phases on each layer from 
-%  the composite x and y-gradients on each layer. 
-%  We assume a Fried geometry of the wavefront sensor.
-%
-%  Input:
-%    FFM_input    - structure that defines input parameters and data 
-%                   for the FFM codes
-%    FFM_output   - structure that results from running the FFM codes.
-%                   In particular, this contains the reconstructed 
-%                   composite (sausage region) gradients on each layer.
-%
-%  Optional Input:
-%      FFM_options - structure containing some optional input paramteters.
-%                    See FFM.m for more information.
-%
-%  Output:
-%    phase_layers - reconstructed phases on each layer.  This is a 4-D
-%                   array, where
-%                       phase_layers(:,:,k,L)
-%                   contains the phase on layer L for frame k.
-%
-
-%
-%  J. Nagy
-%  December, 2012
-%  Modified, July 2015
-%  The previous version did not guarantee the frozen flow held on
-%  the reconstructed phases for each layer.  This version should
-%  fix this problem.
-%
-%  Modified November, 2015, to allow non square subapertures. (J. Nagy) 
-%  So now, ssp can be a scalar (equal diameters in both directions)
-%  or a 1-by-2 array, [ssp_rows, ssp_cols]
-%
-%  Modified April, 2016 to reduce memory requirements.  There are now
-%  two new inputs (A and W) which are needed in other parts of the code.
-%  So it makes no sense to rebuild them here.
-
-%
-%  These first statements just do a quick check to make sure enough
-%  input terms have been given; FFM_options is optional.
-%  Check options, and set default parameters.
-%
-%narginchk(2,3)
-if nargin == 4
-  % Use all defaults for options
-  phase_scale = [];
-  reg_par_PR = [];
-  method_PR = [];
-else
-  if isfield(FFM_options, 'phase_scale')
-    phase_scale = FFM_options.phase_scale;
-  else
-    phase_scale = [];
-  end
-  if isfield(FFM_options, 'reg_par_PR')
-    reg_par_PR = FFM_options.reg_par_PR;
-  else
-    reg_par_PR = [];
-  end
-  if isfield(FFM_options, 'method_PR')
-    method_PR = FFM_options.method_PR;
-  else
-    method_PR = [];
-  end
-end
-if isempty(phase_scale), phase_scale = 1; end
-if isempty(reg_par_PR), reg_par_PR = 1e-6; end
-if isempty(method_PR), method_PR = 'direct'; end
-
-n_ap = FFM_input.n_ap;
-n_frames = FFM_input.n_frames;
-n_layers = FFM_input.n_layers;
-phaseC_gradx = FFM_output.phaseC_gradx;
-phaseC_grady = FFM_output.phaseC_grady;
-pupil_mask = FFM_input.pupil_mask;
-wind_vecs = FFM_input.wind_vecs;
-ssp = FFM_input.ssp;
-%
-%  Modified November, 2015, to allow non square subapertures.
-%  J. Nagy
-%
-if length(ssp) == 1
-    ssp = [ssp, ssp];
-end
-%
-%  Convert wind_vecs into pixel shift values:
-%
-deltax = ssp(1)*wind_vecs(:,1) .* cos(wind_vecs(:,2));
-deltay = ssp(2)*wind_vecs(:,1) .* sin(wind_vecs(:,2));
-
-%
-%  We need to find a composite grid size, and the amount of padding needed
-%  to get from n_ap to n_conmp.  
-%
-[n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay);
-
-%
-%  In this version, we reconstruct the phase on the composite grid:
-%
-%pupil_maskC = GetCompositeMask(pupil_mask, wind_vecs, ssp, n_ap, n_comp, n_comp_pad, n_frames, n_layers);
-%
-%  April 2016 modification: Changed GetCompositeMask.m so that it does not
-%  build another big matrix.  Instead it uses the given motion matrix.
-%
-%
-%pupil_maskC = GetCompositeMask(pupil_mask, n_comp, n_comp_pad, n_frames, n_layers);
-
-pupil_maskC = GetCompositeMask(pupil_mask, wind_vecs, ssp(1), n_ap, n_comp, n_comp_pad, n_frames, n_layers);
-
-phaseC_layers = zeros(size(phaseC_gradx));
-for k = 1:n_layers
-    phaseC_layers(:,:,k) = p_ReconstructPhase(phaseC_gradx(:,:,k), phaseC_grady(:,:,k), pupil_maskC(:,:,k), phase_scale, reg_par_PR);
-end
-
-
-%
-%  We need the following matrices to punch out the phases from the
-%  composite grid.
-%
-%  April 2016 modification: These matrices are created in the FFM code,
-%  so instead of rebuilding them, pass them in as input.
-%
-%W = WindowMatrix(n_ap, n_comp, pupil_mask, n_comp_pad+1, n_comp_pad+1);
-%A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames);
-
-%
-%  To punch out, I zero out all other layers, so that the punch out
-%  steps adds zeros.  There might be a better way to do this, but it
-%  will require a significant rewrite of the code.
-%
-phase_layers = zeros(n_ap, n_ap, n_frames, n_layers);
-for k = 1:n_layers
-  phaseC_layers1 = zeros(size(phaseC_layers));
-  phaseC_layers1(:,:,k) = phaseC_layers(:,:,k);
-  phase_layers(:,:,:,k) = PunchOutFrames(phaseC_layers1, A, W, n_frames, n_layers, n_comp, n_ap);
-end
diff --git a/Generator/library/ReconstructPhase_fast.m b/Generator/library/ReconstructPhase_fast.m
deleted file mode 100755
index 93fd705..0000000
--- a/Generator/library/ReconstructPhase_fast.m
+++ /dev/null
@@ -1,96 +0,0 @@
-function phase = ReconstructPhase_fast(phase_gradx, phase_grady, pupil_mask, scale, alpha, method)
-%
-%    phase = ReconstructPhase_fast(phase_gradx, phase_grady, pupil_mask, alpha);
-% 
-%  This function reconstructs the phase from its gradient measurements.
-%  We assume a Fried geometry of the wavefront sensor.
-%
-%  Input:
-%    phase_gradx - array containing x-gradients of phases.  This can be
-%                  either a 2D or a 3D array.  In case of 3D, each 2D
-%                  slice, phase_gradx(:,:,k), should be gradients for a 
-%                  particular frame of data.
-%    phase_grady - array containing y-gradients of phases.  This can be
-%                  either a 2D or a 3D array.  In case of 3D, each 2D
-%                  slice, phase_gradx(:,:,k), should be gradients for a 
-%                  particular frame of data.
-%    pupil_mask  - pupil mask for phases.  Must be a 2D array, so
-%                  that each phase has the same pupil mask.
-%
-%  Optional Input:
-%    scale       - allows for a normalization scale for specific geometries.
-%                  Default is to use scale = 1;
-%    alpha       - Tikhonov regularization parameter. Default is
-%                  alpha = 1e-6.
-%    method      - character string, either 'direct' or 'lsqr'.
-%                  direct:    Tikhonov regularized least squares problems
-%                             are solved by MATLAB's backslash operator,  
-%                             exploiting sparse matrix tools.
-%                  iterative: Tikhonov regularized least squares problems
-%                             are solved using the iterative method LSQR.
-%                  Default is 'direct'.
-%
-%  Output:
-%    phase       - reconstructed phases.
-%
-
-%
-%  J. Nagy
-%  November, 2012
-%
-
-%
-%  Check inputs and set default values.
-%
-% narginchk(3, 6);
-switch nargin
-  case 3
-    scale = []; alpha = []; method = [];
-  case 4
-    alpha = []; method = [];
-  case 5
-    method = [];
-end
-
-if isempty(scale)
-  scale = 1;
-end
-if isempty(alpha)
-  alpha = 1e-6;
-end
-if isempty(method)
-  method = 'direct';
-end
-alpha = scale*alpha;
-
-%
-%  This can help reduce some boundary artifacts ...
-%
-pad_size = 1;
-phase_gradx = padarray(phase_gradx, [pad_size, pad_size],0, 'both');
-phase_grady = padarray(phase_grady, [pad_size, pad_size],0, 'both');
-pupil_mask = padarray(pupil_mask, [pad_size, pad_size],0, 'both');
-
-[m_ap, n_ap, n_frames] = size(phase_gradx);
-
-Dx = GradxMatrix(n_ap, scale);
-Dy = GradyMatrix(n_ap, scale);
-
-% For this code, let's assume the pupil maskes are the same for all frames.
-%
-if size(pupil_mask,3) ~= 1
-  error('The pupil mask needs to be the same for all frames.')
-end
-
-switch method
-  case 'direct'
-    P = spdiags(pupil_mask(:), 0, n_ap*n_ap, n_ap*n_ap);
-    A = [P*Dx; P*Dy; alpha*speye(n_ap*n_ap)];
-    b = [reshape(phase_gradx,n_ap*n_ap,n_frames); reshape(phase_grady,n_ap*n_ap, n_frames); zeros(n_ap*n_ap,n_frames)];
-    phase_vecs = A\b;
-    pupil_mask = pupil_mask(:,:,ones(1,n_frames));
-    phase = pupil_mask .* reshape(phase_vecs, n_ap, n_ap, n_frames);
-  otherwise
-    error('this only uses a sparse direct factorization for the solve')
-end
-phase = phase(pad_size+1:m_ap-pad_size, pad_size+1:n_ap-pad_size, :);
diff --git a/Generator/library/SimpleImresize.m b/Generator/library/SimpleImresize.m
deleted file mode 100644
index c154656..0000000
--- a/Generator/library/SimpleImresize.m
+++ /dev/null
@@ -1,36 +0,0 @@
-function Iout = SimpleImresize(Iin, OutSize)
-%
-%  Resize given image In to size given by OutSize.
-%
-%  In = input image to be upsampled
-%  OutSize = size you want for the output image.  This can be a scalar
-%            or a 1-by-2 array, [nrows, ncols].  If the input is a scalar,
-%            say n, then [nrows, ncols] = [n, n].
-%
-%  Iout = output image, of size 
-%
-%  The input image can be a 3-d array of image frames, in which case the 
-%  output has the same number of frames, each frame resized to the 
-%  requested dimension.
-% 
-[nyin, nxin, nzin] = size(Iin);
-switch length(OutSize)
-    case 1
-        nxout = OutSize; nyout = OutSize; nzout = nzin;
-    case 2
-        nxout = OutSize(2); nyout = OutSize(1); nzout = nzin;
-    case 3
-        if nzin ~= OutSize(3)
-            error('can only resize 2-d slices of a 3-d array')
-        else
-            nxout = OutSize(2); nyout = OutSize(1); nzout = nzin;
-        end
-    otherwise
-        error('illegal input for OutSize')
-end
-Iout = zeros(nyout, nxout, nzout);
-[X, Y] = meshgrid(1:nxin,1:nyin);
-[Xup, Yup] = meshgrid(linspace(1,nxin,nxout), linspace(1,nyin,nyout));
-for k = 1:nzout
-    Iout(:,:,k) = interp2(X,Y,Iin(:,:,k),Xup,Yup);
-end
diff --git a/Generator/library/TestProblem.m b/Generator/library/TestProblem.m
deleted file mode 100644
index 0146190..0000000
--- a/Generator/library/TestProblem.m
+++ /dev/null
@@ -1,320 +0,0 @@
-function [FFM_input, FFM_truth, FFM_options, A, W, R] = TestProblem(n_frames, wind_vecs, noise_level)
-%
-%  This function will generate some data for a test problem for DORA.
-%
-%  Optional Input:
-%      n_frames     - number of frames used for the simulation.
-%                     Default is n_frames = 20
-%      wind_vecs    - specifies angle (theta) and magnitude (r) of wind 
-%                     velocity for each layer,
-%                         wind_vecs(L,1) = r     (L = 1, 2, ..., n_layers)
-%                         wind_vecs(L,2) = theta (L = 1, 2, ..., n_layers)
-%                     Default is
-%                         wind_vecs = [0.05 pi; 0.25 pi/2; 0.15 3*pi/4];
-%                     Note that the simulation currently works of at
-%                     most three layers.
-%      noise_level  - scalar, 0 <= noise_level < 1, which is used to 
-%                     determine the percentage of Gaussian white noise
-%                     added to the simulated measured data.
-%                     Default is noise_level = 0.01 (i.e., 1% noise)
-%
-%  Output:
-%      DORA__ffm_input   - structure containing the following parameters:
-%
-%         Name         Type               Purpose
-%         -----------  ---------------    --------------------------------
-%         phase_gradx  3D double array    contains measured x-gradients of 
-%                                         wavefront phase on each frame 
-%                                         (low resolution)
-%         phase_grady  3D double array    contains measured y-gradients of 
-%                                         wavefront phase on each frame 
-%                                         (low resolution)
-%         wind_vecs    2D double array    specifies angle (theta) and 
-%                                         magnitude (r) of wind 
-%                                         velocity for each layer:
-%                                             wind_vecs(L,1) = r   
-%                                             wind_vecs(L,2) = theta 
-%                                         L = 1, 2, ..., n_layers.
-%         pupil_mask   2D logical array   pupil mask for aperture
-%         n_subap      Integer            number of pixels across the 
-%                                         subaperture
-%         n_ap         Integer            number of pixels across the 
-%                                         aperture
-%         ssp          Integer            subsampling parameter, which 
-%                                         should satisfy
-%                                              n_ap = ssp*n_subap
-%         n_frames     Integer            number of frames of data
-%         n_layers     Integer            number of atmospheric layers
-%       
-%      FFM_truth   - structure containing the following parameters:
-%
-%         Name         Type               Purpose
-%         -----------  ---------------    --------------------------------
-%         phase        3D double array    contains true wavefront phases
-%                                         for each frame
-%         phaseC       3D double array    contains true composite 
-%                                         wavefront phases on each 
-%                                         atmospheric layer
-%         phase_gradx  3D double array    contains true x-gradients of 
-%                                         wavefront phase on each frame 
-%                                         (high resolution)
-%         phase_grady  3D double array    contains true y-gradients of 
-%                                         wavefront phase on each frame 
-%                                         (high resolution)
-%         phaseC_gradx 3D double array    contains true composite 
-%                                         x-gradients of wavefront phase 
-%                                         on each frame (high resolution)
-%         phaseC_grady 3D double array    contains true composite 
-%                                         y-gradients of wavefront phase 
-%                                         on each frame (high resolution)
-%         pupil_maskC  3D logical array   contains pupil mask for
-%                                         composite information (phases
-%                                         and gradients) on leach layer
-%          
-%      FFM_options - structure containing the following parameters:
-%
-%         Name         Type               Purpose
-%         -----------  ---------------    --------------------------------
-%         phase_scale  Double             parameter used to scale the 
-%                                         derivative opertation when 
-%                                         reconstructing phase from the
-%                                         gradients.
-%                                         Default: 1 (i.e., no scaling)
-%         reg_par_FFM  Double             Tikhonov regularization parameter 
-%                                         for frozen flow model high res
-%                                         gradient reconstruction.
-%                                         Default: 1e-3
-%         reg_par_PR   Double             Tikhonov regularization parameter                              
-%                                         for phase reconstruction.
-%                                         Default: sqrt(eps)
-%         method_FFM   String             Method used to solve the Tikhonov
-%                                         regularized least squares problem
-%                                         for the FFM gradient
-%                                         reconstruction.
-%                                         Currently we have only one
-%                                         method, 'lsqr', but we might want
-%                                         to put in other methods later.
-%                                         Default: 'lsqr'
-%         method_PR    String             Method used to solve the Tikhonov
-%                                         regularized least squares problem
-%                                         for the phase reconstruction
-%                                         reconstruction. Here we can use
-%                                         either 
-%                                          'direct': MATLAB's backslash
-%                                                    operator, which uses
-%                                                    efficient sparse 
-%                                                    factorization methods.
-%                                          'lsqr'  : iterative LSQR method.
-%                                         Default: 'direct'
-%         rtol_FFM     Double             Relative residual stopping 
-%                                         tolerance for phase reconst.
-%                                         This is needed if method_FFM is
-%                                         lsqr.
-%                                         Default: 1e-6
-%         rtol_PR      Double             Relative residual stopping 
-%                                         tolerance for phase reconst.
-%                                         This is needed if method_PR is
-%                                         lsqr.
-%                                         Default: 1e-6
-%
-
-% Some remarks on notation:
-%   * In the codes, I will try to use:
-%       k - integer to denote a specific frame of data, k = 1:n_frames
-%       L - integer to denote a specific layer, L = 1:n_layers
-%       (i,j) - integers denoting a specific pixel in a frame or layer.
-%   * In the FFM gradient reconstruction codes, we use pixel shifts
-%     given by detlax and deltay.  We assume the information in wind_vecs
-%     pertains to the low resolution grid, and so
-%       deltax = r*ssp*cos(theta)
-%       deltay = r*ssp*sin(theta)
-%     where r = wind_vecs(L,1) and theta = wind_vecs(L,2).
-%     Note that
-%       deltax = number of pixels the atmosphere shifts to the right
-%       deltay = number of pixels the atmosphere shifts to the left
-%     but this should be on the high resolution grid. So be careful here.
-%   * Generally we assume constant speed, but the FFM code does allow for
-%     non-constant speed.  Specifically:
-%             * Number of rows in deltax (and deltay) = n_layers
-%             * If there is only one colum, then it is 
-%               assumed that speed is constant.
-%             * For non-constant speed, deltax and deltay should
-%               have n_frames-1 columns, giving the number
-%               of pixels shifting in the x(y)-direction for
-%               each frame (the first frame is assumed
-%               fixed, so only need 2, 3, ..., n_frames)
-
-
-switch nargin
-  case 0
-    n_frames = []; wind_vecs = []; noise_level = [];
-  case 1
-    wind_vecs = []; noise_level = [];
-  case 2
-    noise_level = [];
-  case 3
-    [];
-  otherwise
-    error('Too many input arguments.')
-end
-
-if isempty(n_frames)
-  n_frames = 20;
-end
-if isempty(wind_vecs)
-  wind_vecs = [0.25 pi; 0.5 pi/2; 0.65 3*pi/4];
-end
-if isempty(noise_level)
-  noise_level = 0.01;
-end
-
-n_layers = size(wind_vecs,1);
-  
-load phi_comp_true
-phaseC_true = phi_comp_true(:,:,1:n_layers)./2;
-
-%
-%  We'll assume 32 pixels across subaperture, and ssp = 4
-%  (i.e., 128 pixels across aperture), and we'll pick a number of frames:
-%
-% ssp = 4;
-% n_subap = 32;
-
-
-ssp = 6;
-n_subap = 40;
-
-n_ap = ssp*n_subap;
-
-%
-%  Convert wind_vecs into pixel shift values:
-%
-deltax = ssp*wind_vecs(:,1) .* cos(wind_vecs(:,2));
-deltay = ssp*wind_vecs(:,1) .* sin(wind_vecs(:,2));
-
-%
-%  We need to find a composite grid size, and the amount of padding needed
-%  to get from n_ap to n_conmp.  We can then cut down the loaded true
-%  composite phases to the largest size that we need for this simulation.
-%
-[n_comp, n_comp_pad] = GetCompositeGridSize(n_ap, n_frames, deltax, deltay);
-phaseC_true = phaseC_true(1:n_comp, 1:n_comp, :);
-
-%
-%  With these, we can create pupil masks.  I'm not sure the correct way
-%  to do this, but here's what I think:
-%    Generally, the pupil mask is an annulus, where the ratio of the 
-%    diameters (or radii) of the circles to be 0.25.
-%  Our "MakeMask" function uses radius of 1 to generate a circle to the
-%  outer edge of the array.  So to geneate the pupil masks, we use:
-%
-pupil_mask_subap = MakeMask(n_subap, 1, 0.25);
-pupil_mask = MakeMask(n_ap, 1, 0.25);
-% pupil_mask = ones(n_ap);
-%
-% Note, for example, if n_ap = 128 (this is the diameter of the outer
-% circle in the pupil mask), then the diameter of the inner circle is
-% then 0.25*128 = 32 pixels.
-% Similarly, if n_subap = 32, then the diameter of the inner circle  is
-% then 0.25*32 = 8 pixels.
-%
-% For another example, in the case of the AEOS data, we used 
-% ssp = 6, n_subap = 32, and n_ap = ssp*n_subap = 192.  So in this case,
-% the diameter of the inner circle for the pupil mask is 
-% 0.25*192 = 48 pixels. 
-%
-
-%
-%  We need the following matrices:
-%
-R = SubsampleMatrix(n_ap, ssp);
-W = WindowMatrix(n_ap, n_comp, pupil_mask, n_comp_pad+1, n_comp_pad+1);
-A = MotionMatrix(deltax, deltay, n_comp, n_ap, n_frames);
-
-%
-%  Get punched out versions of the wavefront on each frame
-%
-N = n_comp*n_comp;
-phase_true_comp_vec = zeros(N*n_layers,1);
-for L = 1:n_layers
-  phase_true_comp_vec((L-1)*N+1:L*N,1) = reshape(phaseC_true(:,:,L),n_comp*n_comp,1);
-end
-
-phase_true_vec = kron(speye(n_frames),W)*A*phase_true_comp_vec;
-phase_true = reshape(phase_true_vec, n_ap, n_ap, n_frames);
-%
-% The next step in the simulation is to construct gradients.
-%
-Dx = GradxMatrix(n_comp);
-Dy = GradyMatrix(n_comp);
- 
-phaseC_gradx_true = zeros(size(phaseC_true));
-phaseC_grady_true = zeros(size(phaseC_true));
-for L = 1:n_layers
-  phaseC_gradx_true(:,:,L) = reshape(Dx*reshape(phaseC_true(:,:,L),n_comp*n_comp,1),n_comp,n_comp);
-  phaseC_grady_true(:,:,L) = reshape(Dy*reshape(phaseC_true(:,:,L),n_comp*n_comp,1),n_comp,n_comp);
-end
-
-%
-% Get punched out versions of these gradients, and the corresponding low
-% resolution versions:
-%
-N = n_comp*n_comp;
-phaseC_gradx_true_vec = zeros(N*n_layers,1);
-phaseC_grady_true_vec = zeros(N*n_layers,1);
-for L = 1:n_layers
-  phaseC_gradx_true_vec((L-1)*N+1:L*N,1) = reshape(phaseC_gradx_true(:,:,L),n_comp*n_comp,1);
-  phaseC_grady_true_vec((L-1)*N+1:L*N,1) = reshape(phaseC_grady_true(:,:,L),n_comp*n_comp,1);
-end
-phase_gradx_true_vec = kron(speye(n_frames),W)*A*phaseC_gradx_true_vec;
-phase_grady_true_vec = kron(speye(n_frames),W)*A*phaseC_grady_true_vec;
-phase_gradx_meas_vec = kron(speye(n_frames),R)*phase_gradx_true_vec;
-phase_grady_meas_vec = kron(speye(n_frames),R)*phase_grady_true_vec;
-
-phase_gradx_true = reshape(phase_gradx_true_vec, n_ap, n_ap, n_frames);
-phase_grady_true = reshape(phase_grady_true_vec, n_ap, n_ap, n_frames);
-phase_gradx_meas = reshape(phase_gradx_meas_vec, n_subap, n_subap, n_frames);
-phase_grady_meas = reshape(phase_grady_meas_vec, n_subap, n_subap, n_frames);
-
-%
-%  Now add noise to the measured gradients -- using the same noise level,
-%  but a different realization for each frame.
-%
-for k = 1:n_frames
-  phase_gradx_meas(:,:,k) = phase_gradx_meas(:,:,k) + ...
-    WhiteNoise(phase_gradx_meas(:,:,k), noise_level, k);
-  phase_grady_meas(:,:,k) = phase_grady_meas(:,:,k) + ...
-    WhiteNoise(phase_grady_meas(:,:,k), noise_level, n_frames+k);
-end
-%(A, pupil_mask, n_comp, n_comp_pad, n_frames, n_layers)
-pupil_maskC = GetCompositeMask(A,pupil_mask, n_comp, n_comp_pad, n_frames, n_layers);
-
-FFM_input.phase_gradx = phase_gradx_meas;
-FFM_input.phase_grady = phase_grady_meas;
-FFM_input.pupil_mask = pupil_mask;
-FFM_input.wind_vecs = wind_vecs;
-FFM_input.ssp = ssp;
-FFM_input.n_ap = n_ap;
-FFM_input.n_subap = n_subap;
-FFM_input.n_frames = n_frames;
-FFM_input.n_layers = n_layers;
-FFM_input.subap_mask = pupil_mask_subap;
-
-FFM_truth.phase = phase_true;
-FFM_truth.phaseC = phaseC_true;
-FFM_truth.phase_gradx = phase_gradx_true;
-FFM_truth.phase_grady = phase_grady_true;
-FFM_truth.phaseC_gradx = phaseC_gradx_true;
-FFM_truth.phaseC_grady = phaseC_grady_true;
-FFM_truth.pupil_maskC = pupil_maskC;
-
-FFM_options.phase_scale = 1;
-FFM_options.reg_par_FFM = 1e-3;
-FFM_options.reg_par_PR = sqrt(eps);
-FFM_options.method_FFM = 'lsqr';
-FFM_options.method_PR = 'direct';
-FFM_options.rtol_FFM = 1e-6;
-FFM_options.rtol_PR = [];
-
-
-
diff --git a/Generator/library/WhiteNoise.m b/Generator/library/WhiteNoise.m
deleted file mode 100755
index 6c3c7c1..0000000
--- a/Generator/library/WhiteNoise.m
+++ /dev/null
@@ -1,31 +0,0 @@
-function N = WhiteNoise(b, level, seed)
-%
-%      N = WhiteNoise(b, level, seed);
-%
-%  This function generates Gaussian white noise for the 
-%  data b. 
-%
-%  Input:  b - array containing data
-%      level - scalar in [0, 1] specifiying level (percentage) of
-%              noise.  For example, level = 0.01 implies
-%                  norm(N)/norm(b) = 0.01, or 1% noise
-%              Default is level = 0.01.
-%       seed - Used to set the random number generator.
-%              Default is seed = 0.
-%
-%  Output: N - array same dimension as b, containing pseudo-random
-%              values drawn from a normal distribution with mean zero
-%              and standard deviation one, and scaled as described above.
-%
-
-% Check inputs and set default values.
-if nargin == 1, level = [];, seed = [];, end
-if nargin == 2, seed = [];, end
-if isempty(level), level = 0.01;, end
-if isempty(seed), seed = 0;, end
-
-% Generate noise.
-randn('seed', seed);
-N = randn(size(b));
-N = N / norm(N(:));
-N = level*norm(b(:))*N;
diff --git a/Generator/library/azi_avg.m b/Generator/library/azi_avg.m
deleted file mode 100755
index 31e275a..0000000
--- a/Generator/library/azi_avg.m
+++ /dev/null
@@ -1,20 +0,0 @@
-function [ r_avg] = azi_avg( frame,Fmask ) 
-
-% function [ r_avg] = azi_avg( xxframe ) 
-% return the radial averages for an image or something square...
-
-xdim = size(frame,1);   %** assume square image
-start = xdim/2;
-
-[x,y]   = meshgrid(-start:1:start-1,-start:1:start-1);
-r_dist  = sqrt(x.^2 + y.^2);
-rad_avg = zeros(start,1);
-t       = r_dist(find(r_dist > 0)); 
-max_rad = round(max(max(r_dist)))+1;
-t_bin   = hist(t,max_rad);
-r_avg   = zeros(start,1);
-for i=0:start-1
-    idx = find(round(r_dist) == i & Fmask ==1);
-    r_avg(i+1) = sum(frame(idx))./length(idx);
-end
-    
diff --git a/Generator/library/block_avg.m b/Generator/library/block_avg.m
deleted file mode 100644
index b7b0c05..0000000
--- a/Generator/library/block_avg.m
+++ /dev/null
@@ -1,17 +0,0 @@
-function out=block_avg(in,pix)
-
-
-out=zeros(size(in,1)./pix,size(in,2)./pix,size(in,3));
-for k=1:size(in,3)
-    rr=1;
-    cc=1;
-    for i=1:pix:size(in,1)-(pix-1)
-        for j=1:pix:size(in,2)-(pix-1)
-            out(rr,cc,k)=sum(sum(in(i:i+(pix-1),j:j+(pix-1),k)));
-            cc=cc+1;
-        end
-        rr=rr+1;
-        cc=1;
-    end
-end
-out=out./pix^2;
\ No newline at end of file
diff --git a/Generator/library/block_rep.m b/Generator/library/block_rep.m
deleted file mode 100644
index 6d8a3a1..0000000
--- a/Generator/library/block_rep.m
+++ /dev/null
@@ -1,17 +0,0 @@
-function out=block_rep(in,ssp)
-
-out=zeros(size(in,1)*ssp,size(in,2)*ssp,size(in,3));
-
-for k=1:size(in,3)
-    ii=1;
-    for i=1:size(in,1)
-        jj=1;
-        for j=1:size(in,2)
-            out(ii:ii+(ssp-1),jj:jj+(ssp-1),k)=in(i,j,k);
-            jj=jj+ssp;
-        end
-        ii=ii+ssp;
-    end
-end
-
-            
\ No newline at end of file
diff --git a/Generator/library/blockrep.m b/Generator/library/blockrep.m
deleted file mode 100755
index 35a4e07..0000000
--- a/Generator/library/blockrep.m
+++ /dev/null
@@ -1,8 +0,0 @@
-function b = blockrep(a,n)
-
-% Block replicate the pixels of image cube a. Each pixel of each slice is replicated into a block of nxn pixels
-
-b = zeros(size(a,1)*n,size(a,2)*n,size(a,3));
-for k=1:n; b(1:n:end,k:n:end,:) = a; end
-for k=2:n; b(k:n:end,:,:)=b(1:n:end,:,:); end
-
diff --git a/Generator/library/brent.m b/Generator/library/brent.m
deleted file mode 100755
index ce493eb..0000000
--- a/Generator/library/brent.m
+++ /dev/null
@@ -1,206 +0,0 @@
-function [xmin,fmin,iter] = brent(f, ax, bx, cx, x_in,d_in, tol)
-%
-%BRENT - Brent's Method for Minimization.
-%
-%  [ xmin, fmin ] = brent(f, ax, bx, cx, x_in,d_in, tol)
-%
-%  Given a function f, and given a bracketing triplet of abscissas ax,
-%  bx and cx, and fx(b) is less than both f(ax) and f(cx), this routine
-%  isolates the minimum to a fractional precision of about TOL using
-%  Brent's method. The abscissa of the minimum is returned in xmin, and
-%  the minimum function value is returned in fmin.
-%
-%  References:
-%
-%  Brent, R.P. 1973, Algorithms for Minimization without Derivatives
-%     (Englewood Cliffs, NJ: Prentice Hall), Chapter 5
-%  Press, W.H. et al, 1992,  Numerical recipes in C: the art of scientific
-%     computing (Cambridge University Press), Chapter 10.2
-%
-%  Description of variables:
-%
-%    a, b   the minimum is bracketed between a and b
-%    x      point with the least function value found so far
-%    w      point with the second least function value found so far
-%    v      previous value of w
-%    u      point at which the function was evaluated most recently
-%    xm     midpoint between a and b (the function is not evaluated there)
-%
-%    Note: these points are not necessarily all distinct.
-%
-%    e      movement from best current value in the last iteration step
-%    etemp  movement from the best current value in the second last
-%           iteration step
-%
-%  General principles:
-%
-%    - The parabola is fitted trough the points x, v and w
-%    - To be acceptable the parabolic step must
-%        (i)  fall within the bounding interval (a,b)
-%        (ii) imply a movement from the best current value x that is
-%             *less* than half the movement of the *step before last*
-%    - The code never evaluates the function less than a distance tol1
-%      from a point already evaluated or from a known bracketing point
-%
-% Written by:
-% --
-% John L. Weatherwax                2004-12-11
-%
-% email: wax@alum.mit.edu
-%
-% Please send comments and especially bug reports to the
-% above email address.
-%
-%-----
-
-
-VERBOSE = 0;                % Print steps taken for the solution.
-CGOLD   = (3-sqrt(5))/2;    % golden ratio
-ITMAX   = 100;              % max number of iterations
-ZEPS    = 1e-10;            % absolute error tolerance
-
-% initialization
-e = 0;
-if ax < cx
- a = ax; b = cx;
-else
- a = cx; b = ax;
-end;
-v = bx; w = v; x = w;
-
-%x_in,d_in
-
-fx = feval(f,x_in + x.*d_in); fv = fx; fw = fv;
-
-for iter = 1:ITMAX,
- if( VERBOSE )
-   fprintf(1, 'k=%4d, |a-b|=%e\n', iter, abs(a-b));
- end
- xm = 0.5*(a+b);
- tol1 = tol*abs(x) + ZEPS;
- tol2 = 2*tol1;
- % Stopping criterion: equivalent to: max(x-a, b-x) <= tol2
- if abs(x-xm) <= tol2-0.5*(b-a)
-   xmin = x;
-   fmin = fx;
-   return
- end
- if abs(e) > tol1
-   %
-   % The second last move was sufficently large:
-   % let's construct the parabolic fit
-   %
-   r = (x-w)*(fx-fv);
-   q = (x-v)*(fx-fw);
-   p = (x-v)*q - (x-w)*r;
-   q = 2.0*(q-r);
-   if q > 0, p = -p; end
-   q = abs(q);
-   etemp = e;
-   e = d;
-   if abs(p) >= abs(0.5*q*etemp) | p <= q*(a-x) | p >= q*(b-x)
-     %
-     % The parabolic fit did not meet the reqirements above:
-     % use a golden section refinement instead.
-     %
-     % Print an explanation of what condition failed:
-     %
-     if( VERBOSE )
-       if abs(p) >= abs(0.5*q*etemp)
-        % disp('abs(p) >= abs(0.5*q*etemp)')
-       end
-       if p <= q*(a-x)
-         %disp('p <= q*(a-x)')
-       end
-       if p >= q*(b-x)
-         %disp('p >= q*(b-x)')
-       end
-     end
-     %
-     % Set e in such a way, that a parabolic fit is possible in the
-     % next iteration.
-     %
-     if x >= xm
-       e = a-x;
-     else
-       e = b-x;
-     end
-     d = CGOLD*e;
-     if( VERBOSE )
-       disp('golden section step');
-     end
-   else
-     %
-     % the parabolic fit meets the above requirements: use iteration
-     %
-     d = p/q;
-     u = x+d;
-     if u-a < tol2 | b-u < tol2
-       %
-       % the parabolic fit is too close to the boundaries of the
-       % bracketing interval: put new point tol1 apart from the
-       % midpoint
-       %
-       d = tol1*sign(xm-x);
-       if( VERBOSE ) disp('too close to interval boundaries'); end
-     else
-       if( VERBOSE ) disp('parabolic step'); end
-     end
-   end
- else
-   %
-   % The second last move was not sufficently large: use golden section
-   % set e in such a way, that a parabolic fit is possible in the next
-   % iteration.
-   %
-   if x >= xm
-     e = a-x;
-   else
-     e = b-x;
-   end
-   d = CGOLD*e;
-   if( VERBOSE )
-     disp('abs(e) > tol1');
-     disp('golden section step');
-   end
- end
- if abs(d) >= tol1
-   u = x+d;
- else
-   %
-   % u is too close to x: put u farer apart
-   %
-   u = x + tol1*sign(d);
-   if( VERBOSE ) disp('u is too close to x'); end;
- end
- fu = feval(f,x_in + u.*d_in);    % finally evaluate the function
- if fu <= fx
-   %
-   % u is better than x: x becomes new boundary
-   %
-   if u >= x
-     a = x;
-   else
-     b = x;
-   end
-   v = w; w = x; x = u;
-   fv = fw; fw = fx; fx = fu;
- else
-   %
-   % x is better than u: u becomes new boundary
-   %
-   if u < x
-     a = u;
-   else
-     b = u;
-   end
-   if fu <= fw | w == x
-     v = w; w = u;
-     fv = fw; fw = fu;
-   elseif fu <= fv | v == x | v == w
-     v = u;
-     fv = fu;
-   end
- end
-end
-error('too many iterations in brent');
\ No newline at end of file
diff --git a/Generator/library/centroid.m b/Generator/library/centroid.m
deleted file mode 100644
index c907adf..0000000
--- a/Generator/library/centroid.m
+++ /dev/null
@@ -1,18 +0,0 @@
-function c = centroid(im)
-
-% c = centroid(im)
-%    Computes the centroid of 2D array im with respect to the center
-%    of the array
-
-v = zeros(2,size(im,3));
-s = size(im(:,:,1));   
-[x y] = meshgrid(1:s(2),1:s(1));
-for k=1:size(im,3)
-   img = im(:,:,k);
-   c(1) = sum(sum(x.*img))/sum(img(:))-s(2)/2;
-   c(2) = sum(sum(y.*img))/sum(img(:))-s(1)/2;
-%    v(1,k) = c(1);
-   % v(2,k) = -c(2);
-   
-end
-
diff --git a/Generator/library/check_derivatives.m b/Generator/library/check_derivatives.m
deleted file mode 100755
index a4b3be5..0000000
--- a/Generator/library/check_derivatives.m
+++ /dev/null
@@ -1,53 +0,0 @@
-function check_derivatives( func_name, dfunc_name, p, vdx, max_checks)
-
-global cost_params
-
-if nargin == 4
-    max_checks = 4;
-end
-
-% fprintf('Derivative check \n');
-% fprintf('-------------------------------------------------------------\n');
-% fprintf(['func_name  : ' func_name '\n' ]);
-% fprintf(['dfunc_name : ' dfunc_name '\n\n' ]);
- 
-[ fval, grad ]       = feval(dfunc_name,p); 
-
-delta_x = [ 4 3 2 1 0.1 0.01];
-
-fprintf('initial step size used\n');
-fprintf('%8.7g ',delta_x');
-
-fprintf('\ncomparing analytical and numerical derivatives ... \n\n');
-fprintf('                                                \t\t\t\t\t\t\t lowest error\n');        
-fprintf('pixel  \t var value \t\t step \t error  \t numerical \t rel. error  \t analytic \t ratio\n');
-
-% cost_params.Hupdate=1;
-% cost_params.Fupdate=1;
-% 
-
-v_pixels            = vdx; %(1:2:end);
-
-checks=0;
-keep_going=1;
-while checks < max_checks
-
-       % pp=max(1,floor(2.8e4.*rand));
-
-    pp=max(1,floor(length(v_pixels).*rand));
-    if abs(grad(v_pixels(pp))) > 1e-15
-        fprintf('%5.0f\t%8.5g\t',v_pixels(pp),p(v_pixels(pp)));
-        zerr=zeros(length(delta_x),1);zfd=zerr;
-        for zp=1:length(delta_x)
-            [ err, fd, a ] = dfridr(func_name,p,pp,delta_x(zp));
-            zerr(zp)=err;zfd(zp) = fd;
-        end
-        idx=find(zerr==min(zerr(:))); [ err, fd, a ] = dfridr(func_name,p,v_pixels(pp),delta_x(idx(1)));
-        fprintf('%8.5g \t',delta_x(idx(1)));
-        fprintf('%8.5g \t %8.5g\t',err, fd);
-        fprintf('%8.5g\t %8.5g\t%8.5g\n',abs(err/fd),grad(v_pixels(pp)),grad(v_pixels(pp))/fd);
-        %    end
-        checks = checks + 1;
-        
-    end
-end
diff --git a/Generator/library/circle.m b/Generator/library/circle.m
deleted file mode 100755
index 91b88ac..0000000
--- a/Generator/library/circle.m
+++ /dev/null
@@ -1,17 +0,0 @@
-function c = circle(s,d,varargin)
-
-if nargin>2
-   cen = varargin{1};
-   if (size(cen,1)~=1)|(size(cen,2)~= 2)
-      fprintf('Error in center definition\n')
-      return
-   end
-else
-   m = bitshift(s,-1)+1;
-   cen = [m m];
-end
-
-c = zeros(s);
-[x,y] = meshgrid(-cen(1)+1:s-cen(1),-cen(2)+1:s-cen(2));
-r = sqrt(double(x.^2+y.^2));
-c(r<d/2) = 1;
diff --git a/Generator/library/compute_dwfs.m b/Generator/library/compute_dwfs.m
deleted file mode 100644
index a63d1c5..0000000
--- a/Generator/library/compute_dwfs.m
+++ /dev/null
@@ -1,106 +0,0 @@
-function [afx,v_fit] = compute_dwfs(SM_params,G,aphase,wfs_transpose,wfs_rot_angle)
-
-
-mdim        = size(G,1);
-Gmodsq      = fftshift(abs(G).^2);
-noise       = mean(Gmodsq(1:10,1:10,:));err = mean(noise(:));
-SNR         = Gmodsq./err;
-idx         = find(SNR>10);
-mask        = zeros(size(SNR));
-mask(idx)   = 1.0;
-for k=1:size(mask,3);mask(:,:,k) = ifftshift(mask(:,:,k));end
-
-
-%% Vary pupil size and phase scaling to get the best object
-v_size =  108; %:2:192; %[60:2:192 ];
-v_scale = 1:0.1:4;
-
-v_max = zeros(length(v_scale),length(v_size));v_fit = v_max;
-afx   = zeros(mdim,mdim,length(v_scale),length(v_size));
-H=zeros(size(G));
-
-v_int = 16;
-
-for ss=1:length(v_size)
-    
-    xx          = (SM_params.Diam_sec./SM_params.Diam_pri);
-    pupil_outer = dora_make_mask(v_size(ss),v_size(ss));
-    r0          = round( xx*v_size(ss)/2);
-    pupil_inner = dora_make_mask(v_size(ss),r0);
-    pupil_mask  = pupil_outer - pupil_inner;
-
-    % Make Pupil amplitude mask 
-    pad_size = (mdim - v_size(ss))/2;
-    pad_size_pre  = fix([pad_size, pad_size]);
-    pad_size_post = pad_size_pre;
-
-    pupil_amp  =  padarray(padarray(pupil_mask, pad_size_pre, 'pre'), pad_size_post, 'post');
-    pupil_amp  = pupil_amp./max(pupil_amp(:));
-    pupil_amp  = (mdim.*pupil_amp)./sqrt(sum(sum(pupil_amp.^2)));
-
-    for aa=1:length(v_scale)
-        for k=1:size(G,3)
-            hh = zeros(mdim);
-            for jp=1:length(v_int)
-                jj          = v_int(jp);
-               phi         = aphase(:,:,jj,k);                            
-%                 phiR         = rot90(phi,round(wfs_rot_angle/90));  
-                       phiR         = imrotate(phi,wfs_rot_angle,'crop');   
-                if wfs_transpose 
-                    phiR=phiR';
-                end       
-               
-                pad_dim     = (mdim-size(phiR))/2;
-                phasek4     = padarray(phiR.*v_scale(aa),pad_dim,0,'both');
-                a           = ifft2(pupil_amp.*exp(sqrt(-1).*phasek4));
-                h           = abs(a).^2;
-                hh          = hh + h;
-            end  
-            hh=hh./length(v_int);
-            H(:,:,k)    = fft2(hh);
-%             figure(8);imagesc(fftshift(hh));pause(0.5);
-        end
-        F       = sum(conj(H).*G,3)./(sum(abs(H).^2,3) + 1e-2);
-        fval    = 0;
-        for k=1:size(G,3)
-            fval = fval + sum(sum(mask(:,:,k).*abs( G(:,:,k) - F.*H(:,:,k)).^2));
-        end
-        fx = real(ifft2(F));
-        afx(:,:,aa,ss)  = fx;
-%         v_max(aa,ss)    = max(fx(:));
-         v_fit(aa,ss)    = fval;
-%          figure(5);imagesc(phiR);pause(0.5);
-%       %  figure(81);pcolor(v_size,v_scale,v_fit);colorbar;pause(0.2);shading interp
-%         
-%         figure(81);plot(v_scale(1:aa),v_fit(1:aa),'bsq-');colorbar;pause(0.2);
-        
-    end
-%     ss
-%     figure(11);   
-%     set(gcf,'Color','w');
-%     subplot(1,3,1);
-% %     pcolor(v_size,v_scale,log10(v_fit));shading interp;colorbar
-%     xlabel('Pupil diameter');ylabel('phase scaling');
-%     set(gca,'FontSize',13);
-%     title( [ 'wfs transp: ' num2str(wfs_transpose) '  angle: ' num2str(wfs_subap_rot_angle) ' > wind: ' num2str(vecs(1)) '  ' num2str(vecs(2))]);
-% 
-%     subplot(1,3,2);
-%     pcolor(v_size,v_scale,v_max);shading interp
-%     xlabel('Pupil diameter');ylabel('phase scaling');
-%     set(gca,'FontSize',13);
-%     title( [ 'wfs transp: ' num2str(wfs_transpose) '  angle: ' num2str(wfs_subap_rot_angle) ' > wind: ' num2str(vecs(1)) '  ' num2str(vecs(2))]);
-%     colorbar
-%     
-%     pause(0.5);
-end
-% v_co = 129:129+255;
-% 
-% subplot(1,3,3);
-% [aa,ss]=ind2sub(size(v_max),find(v_max==max(v_max(:))));[ v_scale(aa) v_size(ss) ]
-% [aa,ss]=ind2sub(size(v_max),find(v_fit==min(v_fit(:))));[ v_scale(aa) v_size(ss) ]
-% imagesc(afx(:,:,aa(1),ss(1)));colorbar;%title( [ 'wfs transpose: ' num2str(wfs_transpose) '  rotation: ' num2str(wfs_subap_rot_angle) ' ==> wind: ' num2str(vecs(1)) '  ' num2str(vecs(2))]);
-% 
-
-
-% 
-% v_noise
\ No newline at end of file
diff --git a/Generator/library/dfridr.m b/Generator/library/dfridr.m
deleted file mode 100755
index 5bcbff0..0000000
--- a/Generator/library/dfridr.m
+++ /dev/null
@@ -1,38 +0,0 @@
-function [ err, ans, a ] = dfridr( func_name, x, pp, hh) 
-
-CON = 1.4;
-CON2 = CON*CON;
-SAFE = 2.0;
-
-global cost_params
-
-xp1=x;
-xp2=x;
-a=zeros(10,10);
-x1=x;x2=x;
-x1(pp)=x1(pp)+hh;
-x2(pp)=x2(pp)-hh;
-a(1,1)=(feval(func_name,x1) - feval(func_name,x2))/(2*hh);
-err=1e30;
-for i=2:20
-    hh = hh/CON;
-    xp1=x;
-    xp1(pp) = xp1(pp) - hh;
-    xp2(pp) = xp2(pp) + hh;
-    a(1,i)=(feval(func_name,xp2) - feval(func_name,xp1))/(2*hh);
-    fac = CON2;
-    for j=2:i
-        a(j,i) = (a(j-1,i)*fac - a(j-1,i-1))/(fac-1.0);
-        fac=CON2*fac;
-        errt=max(abs(a(j,i)-a(j-1,i)),abs(a(j,i)-a(j-1,i-1)));
-        if ( errt <= err )
-            err=errt;
-            ans=a(j,i);
-        end
-    end
-    if ( abs(a(i,i)-a(i-1,i-1)) >= SAFE*err )
-        break
-    end
-    xp1(pp) = xp1(pp) + hh;
-    xp2(pp) = xp2(pp) - hh;    
-end
\ No newline at end of file
diff --git a/Generator/library/dora_make_mask.m b/Generator/library/dora_make_mask.m
deleted file mode 100644
index adbba8f..0000000
--- a/Generator/library/dora_make_mask.m
+++ /dev/null
@@ -1,19 +0,0 @@
-function mask = dora_make_mask(sz,rad)
-
-% mask = dora_make_mask(sz,rad)
-
-c1 = -((sz-1)/2);
-c2 = sz+c1-1;
-
-[x,y]   = meshgrid([c1:c2],[c1:c2]);
-rho     = sqrt(x.*x+y.*y);
-
-
-
-theta = atan2(y,x);
-
-mask=circle(sz,sz,[(sz+1)/2 (sz+1)/2]);
-mask(rho>rad)=0.0;
-
-
-
diff --git a/Generator/library/echo_out.m b/Generator/library/echo_out.m
deleted file mode 100755
index de32f58..0000000
--- a/Generator/library/echo_out.m
+++ /dev/null
@@ -1,13 +0,0 @@
-function echo_out( out_string )
-
-%echo_out( out_string )
-
-global cost_params 
-
-fid =  fopen( cost_params.out_fname,'a');
-
-fprintf(fid,out_string);
- 
-fprintf(out_string);
-fclose(fid);
-
diff --git a/Generator/library/f_special.m b/Generator/library/f_special.m
deleted file mode 100644
index b11e9df..0000000
--- a/Generator/library/f_special.m
+++ /dev/null
@@ -1,6 +0,0 @@
-function h = f_special(ctype,sz,sigx)
-
-
-[x,y]   = meshgrid(-(sz/2):1:(sz/2)-1,-(sz/2):1:(sz/2)-1);
-rad2    = x.^2+y.^2;
-h       = exp(-rad2./(2*sigx^2))./(2*pi*sigx^2);
diff --git a/Generator/library/fourier_view.m b/Generator/library/fourier_view.m
deleted file mode 100644
index 94d866d..0000000
--- a/Generator/library/fourier_view.m
+++ /dev/null
@@ -1,11 +0,0 @@
-function fourier_view( fname )
-
-ft=fitsread(fname);
-cube = zeros(size(ft));
-fname2 = [fname(1:findstr(fname,'.fits')-1) '_modsq.fits' ];
-for k=1:size(cube,3)
-    cube(:,:,k) = abs(fftshift(fft2(ft(:,:,k)))).^2;   
-end
-
-fitswrite(cube,fname2)
-fprintf(['Fourier modsq -> ' fname2 '\n\n' ]);
\ No newline at end of file
diff --git a/Generator/library/func_gaussian.m b/Generator/library/func_gaussian.m
deleted file mode 100755
index f50f149..0000000
--- a/Generator/library/func_gaussian.m
+++ /dev/null
@@ -1,11 +0,0 @@
-function h = func_gaussian(mdim,sig2)
-
-if sig2>0
-    mdim2   = mdim/2;
-    [x,y]   = meshgrid(-mdim2:1:(mdim2-1),-mdim2:1:(mdim2-1));rad2=x.^2 + y.^2;       
-    h       = exp(-rad2./(2*sig2^2))./(2*pi.*sig2^2);
-else
-    h = zeros(mdim);
-    h(mdim/2+1,mdim/2+1)=1.0;
-end
-
diff --git a/Generator/library/func_golden.m b/Generator/library/func_golden.m
deleted file mode 100755
index 4213159..0000000
--- a/Generator/library/func_golden.m
+++ /dev/null
@@ -1,50 +0,0 @@
-function [xmin,golden] = func_golden(func_name,ax,bx,cx,x_in,d_in)
-
-%1. Given bracket points ax, bx, cx, this function finds the minimum with tol; 
-%   return independent variable as xmin (a scalar!) and func_nametion value as golden. 
-%   See NR F77, p.394
-%2. Uses a user-defined func.m
-%3. I added x1t=x_in+x1.*d_in, etc, for the use of multidimensional conjugate 
-%   gradient method. This step is performed by f1dim in NR on p.413.
-%4. Like in func_mnbrak.m the outputs from this function are again scalars.
-%5. You may want to change tol here.
-
-tol=1.e-7;
-R=0.61803399;
-C=1.-R;
-
-x0=ax;
-x3=cx;
-if abs(cx-bx) > abs(bx-ax) 
-  x1=bx;
-  x2=bx+C.*(cx-bx);
-else
-  x2=bx;
-  x1=bx-C.*(bx-ax);
-end
-f1=feval(func_name,x1);
-f2=feval(func_name,x2);
-
-while abs(x3-x0) > tol.*(abs(x1)+abs(x2))
-      if f2 < f1
-         x0=x1;
-         x1=x2;
-         x2=R.*x1+C.*x3;
-         f1=f2;        
-         [f2]=feval(func_name,x2);
-      else
-         x3=x2;
-         x2=x1;
-         x1=R.*x2+C.*x0;
-         f2=f1;         
-         [f1]=feval(func_name,x1);
-      end
-end
-
-if f1 < f2
-  golden=f1;
-  xmin=x1;
-else
-  golden=f2;
-  xmin=x2;
-end
\ No newline at end of file
diff --git a/Generator/library/func_mnbrak.m b/Generator/library/func_mnbrak.m
deleted file mode 100755
index 88ce59d..0000000
--- a/Generator/library/func_mnbrak.m
+++ /dev/null
@@ -1,88 +0,0 @@
-function [ax,bx,cx,fa,fb,fc] = func_mnbrak(func,ax,bx,x_in,d_in)
-
-%1. Uses a user-defined func.m
-%2. To bracket a minimum from initial guess of ax and bx; see p.393 in Numerical Recipes F77. 
-%3. I added axt=x_in+ax.*d_in, etc, for use in multidimensional conjugate gradient 
-%   calculation, where the search direction is d. In NR, this step is 
-%   performed by the function f1dim on p.413.
-%4. If you are following us, the outputs from these function are all scalars.
-%5. Nothing too interesting here, unless you are hunting a bug.
-
-GOLD=1.618034;
-GLIMIT=100.;
-TINY=1.e-20;
-
-axt=x_in+ax.*d_in;
-[fa]=feval(func,axt);
-bxt=x_in+bx.*d_in;
-[fb]=feval(func,bxt);
-
-if fb > fa 
-  dum=ax;
-  ax=bx;
-  bx=dum;
-  dum=fb;
-  fb=fa;
-  fa=dum;
-end
-
-%first guess for c
-cx=bx+GOLD.*(bx-ax);
-cxt=x_in+cx.*d_in;
-[fc]=feval(func,cxt);
-
-while fb >= fc
-
-     r=(bx-ax).*(fb-fc);
-     q=(bx-cx).*(fb-fa);
-     u=bx-((bx-cx).*q-(bx-ax).*r)./(2.*abs(max(abs(q-r),TINY)).*sign(q-r));
-     
-     if (2.*abs(max(abs(q-r),TINY)).*sign(q-r))==0
-  %       3.134
-     end
-     ulim=bx+GLIMIT.*(cx-bx);
-     if (bx-u).*(u-cx) > 0. 
-        ut=x_in+u.*d_in;
-        [fu]=feval(func,ut);
-        if fu < fc  
-           ax=bx;
-           fa=fb;
-           bx=u;
-           fb=fu;
-           break;
-        elseif fu > fb 
-           cx=u;
-           fc=fu;
-           break;
-        end
-        u=cx+GOLD.*(cx-bx);
-        ut=x_in+u.*d_in;
-        [fu]=feval(func,ut);
-     elseif (cx-u).*(u-ulim) > 0. 
-        ut=x_in+u.*d_in; 
-        [fu]=feval(func,ut);
-        if fu < fc 
-           bx=cx;
-           cx=u;
-           u=cx+GOLD.*(cx-bx);
-           fb=fc;
-           fc=fu;
-           ut=x_in+u.*d_in;
-           [fu]=feval(func,ut);
-        end
-     elseif (u-ulim).*(ulim-cx) >= 0 
-           u=ulim;
-           ut=x_in+u.*d_in;
-           [fu]=feval(func,ut);
-     else
-            u=cx+GOLD.*(cx-bx);
-            ut=x_in+u.*d_in;
-            [fu]=feval(func,ut);
-     end
-     ax=bx;
-     bx=cx;
-     cx=u;
-     fa=fb;
-     fb=fc;
-     fc=fu;
-end    
\ No newline at end of file
diff --git a/Generator/library/func_object_move.m b/Generator/library/func_object_move.m
deleted file mode 100644
index de3bb29..0000000
--- a/Generator/library/func_object_move.m
+++ /dev/null
@@ -1,36 +0,0 @@
-function fval = func_object_move(x,fx,ft,mask)
-
-% fval = func_object_move(x,fx,ft)
-% 
-% x  = parameters
-% fx = object 
-% ft = truth object 
-%
-
-ft=ft./sum(ft(:));
-fx=fx./sum(fx(:));
-FX=fft2(fx);
-mdim = size(FX,1);
-icen = mdim/2+1;
-
-
-fval    = 0;
-im      = zeros(mdim,mdim,2);
-xx      = reshape(x,[2 1]);
-
-dr=xx(1);
-dc=xx(2);
- 
-for r=1:mdim
-    for c=1:mdim
-        im(r,c,1) = -(2*pi*(dc*(c-icen))/mdim);
-        im(r,c,2) = -(2*pi*(dr*(r-icen))/mdim);  
-    end
-end
-cexp    = ifftshift(complex(cos(im(:,:,1)+im(:,:,2)),sin(im(:,:,1)+im(:,:,2))));
-
-FXp     = FX.*cexp;
-fxp      = real(ifft2(FXp));
-
-res     = (fxp-ft).*mask;
-fval    = fval + sum(res(:).^2);
diff --git a/Generator/library/gamrnd.m b/Generator/library/gamrnd.m
deleted file mode 100644
index 1f98ecf..0000000
--- a/Generator/library/gamrnd.m
+++ /dev/null
@@ -1,149 +0,0 @@
-function r = gamrnd(a,b,m,n);
-%GAMRND Random matrices from gamma distribution.
-%   R = GAMRND(A,B) returns a matrix of random numbers chosen   
-%   from the gamma distribution with parameters A and B.
-%   The size of R is the common size of A and B if both are matrices.
-%   If either parameter is a scalar, the size of R is the size of the other
-%   parameter. Alternatively, R = GAMRND(A,B,M,N) returns an M by N matrix. 
-%
-%   Some references refer to the gamma distribution
-%   with a single parameter. This corresponds to GAMRND
-%   with B = 1. (See Devroye, pages 401-402.)
-
-%   GAMRND uses a rejection or an inversion method depending on the
-%   value of A. 
-
-%   References:
-%      [1]  L. Devroye, "Non-Uniform Random Variate Generation", 
-%      Springer-Verlag, 1986
-
-%   B.A. Jones 2-1-93
-%   Copyright (c) 1993-98 by The MathWorks, Inc.
-%   $Revision: 2.6 $  $Date: 1997/11/29 01:45:28 $
-
-if nargin < 2, 
-   error('Requires at least two input arguments.'); 
-end
-
-
-if nargin == 2
-   [errorcode rows columns] = rndcheck(2,2,a,b);
-end
-
-if nargin == 3
-   [errorcode rows columns] = rndcheck(3,2,a,b,m);
-end
-
-if nargin == 4
-   [errorcode rows columns] = rndcheck(4,2,a,b,m,n);
-end
-
-if errorcode > 0
-   error('Size information is inconsistent.');
-end
-
-% Initialize R to zero.
-lth = rows*columns;
-r = zeros(lth,1);
-a = a(:); b = b(:);
-
-scalara = (length(a) == 1);
-if scalara 
-   a = a*ones(lth,1);
-end
-
-scalarb = (length(b) == 1);
-if scalarb 
-   b = b*ones(lth);
-end
-
-% If a == 1, then gamma is exponential. (Devroye, page 405).
-k = find(a == 1);
-if any(k)
-   r(k) = -b(k) .* log(rand(size(k)));
-end 
-
-
-k = find(a < 1 & a > 0);
-% (Devroye, page 418 Johnk's generator)
-if any(k)
-	c = zeros(lth,1);
-	d = zeros(lth,1);
-   c(k) = 1 ./ a(k);
-   d(k) = 1 ./ (1 - a(k));
-   accept = k;
-   while(length(accept)>0),
-      u = rand(size(accept));
-      v = rand(size(accept));
-      x = u .^ c(accept);
-      y = v .^ d(accept);
-      k1 = find((x + y) <= 1); 
-      if ~isempty(k1)
-	      e = -log(rand(size(k1))); 
-   	   r(accept(k1)) = e .* x(k1) ./ (x(k1) + y(k1));
-         accept(k1) = [];
-      end
-   end
-   r(k) = r(k) .* b(k);
-end
-
-% Use a rejection method for A > 1.
-k = find(a > 1);
-% (Devroye, page 410 Best's algorithm)
-bb = zeros(size(a));
-c  = bb;
-if any(k)
-   bb(k) = a(k) - 1;
-   c(k) = 3 * a(k) - 3/4;
-   accept = k; 
-   count = 1;
-   while(length(accept)>0);
-      m = length(accept);
-      u = rand(m,1);
-      v = rand(m,1);
-      w = u .* (1 - u);
-      y = sqrt(c(accept) ./ w) .* (u - 0.5);
-      x = bb(accept) + y;
-      k1 = find(x >= 0);
-      if ~isempty(k1)
-	 z = 64 * (w .^ 3) .* (v .^ 2);
-         k2 = (z(k1) <= (1 - 2 * (y(k1) .^2) ./ x(k1)));
-         k3 = find(k2);
-         k3 = k1(k3);
-	 r(accept(k3)) = x(k3); 
-         k4 = find(~k2);
-         k4 = k1(k4);
-	 k5 = k4(find(log(z(k4)) <= (2*(bb(accept(k4)).*log(x(k4)./bb(accept(k4)))-y(k4)))));
-         r(accept(k5)) = x(k5);
-         omit = [k3; k5];
-         accept(omit) = [];
-      end
-   end
-   r(k) = r(k) .* b(k);
-end
-
-% Return NaN if b is not positive.
-if any(any(b <= 0));
-   if prod(size(b) == 1)
-      tmp = NaN;
-      r = tmp(ones(rows,columns));
-   else
-      k = find(b <= 0);
-      tmp = NaN;
-      r(k) = tmp(ones(size(k)));
-   end
-end
-
-% Return NaN if a is not positive.
-if any(any(a <= 0));
-   if prod(size(a) == 1)
-      tmp = NaN;
-      r = tmp(ones(rows,columns));
-   else
-      k = find(a <= 0);
-      tmp = NaN;
-      r(k) = tmp(ones(size(k)));
-   end
-end
-
-r = reshape(r,rows,columns);
diff --git a/Generator/library/gauss3filter.m b/Generator/library/gauss3filter.m
deleted file mode 100755
index 331c93d..0000000
--- a/Generator/library/gauss3filter.m
+++ /dev/null
@@ -1,136 +0,0 @@
-% Perform three-dimensional Gaussian smoothing in the frequency domain.
-% This is achieved by replacing the spatial domain convolution with 
-% Fourier coefficient multiplication.
-% R = gauss3filter(I);
-% R = gauss3filter(I, sigma);
-% R = gauss3filter(I, sigma, pixelspacing);
-% In a spatial domain representation, R = convn(I, f(x,y,z));
-% The Gaussian kernel f(x,y,z) is different depending on the function 
-% inputs, see the description below. No image padding is provided, pay
-% attention to the Fourier wrap-around artifacts.
-%
-% Anisotropic smoothing is partly supported, anisotropic voxel size is 
-% fully supported. Suband_1.5 frequency oversampling is employed to reduce 
-% numerical erros when sigma is less than the voxel length. Please refer to 
-% following paper for the Subband_x frequency oversampling technique:
-%   Max W. K. Law and Albert C. S. Chung, "Efficient Implementation for Spherical Flux Computation and Its Application to Vascular Segmentation",
-%   IEEE Transactions on Image Processing, 2009, Volume 18(3), 596V612
-%
-%
-%   R = gauss3filter(I);
-%   Smooth the image using isotropic smoothing with sigma = 1 voxel-length,
-%       f(x,y,z) = (2*pi)^(-3/2) * exp(-(x.^2/2 - y.^2/2 - z.^2/2));
-%
-%   R = gauss3filter(I, sigma);
-%   If sigma is a scalar, it smooths the image using isotropic smoothing with
-%   sigma voxel-length,
-%       f(x,y,z) = (2*pi)^(-3/2)/(sigma^3) * exp(-(x.^2/sigma^2/2 - y.^2/sigma^2/2 - z.^2/sigma^2/2));
-%   If sigma is a 3D vector, i.e. sigma = [sigma_x sigma_y sigma_z], it 
-%   smooths the image using anisotropic smoothing (oriented anisotropic 
-%   Gaussian is not supported),
-%       f(x,y,z) = (2*pi)^(-3/2)/sigma(1)/sigma(2)/sigma(3) * exp(-(x.^2/sigma(1)^2/2 - y.^2/sigma(2)^2/2 - z.^2/sigma(3)^2/2));
-%
-%   R = gauss3filter(I, sigma, pixelspacing);
-%   If sigma is a scalar, smooth the image using isotropic smoothing with
-%   sigma physical-length. pixelspacing is a 3D vector. It defines the size 
-%   of a voxel in physical-length,
-%       f(x,y,z) = (2*pi)^(-3/2)/(sigma^3) * exp(-((x*pixelspacing(1)).^2/sigma^2/2 - (y*pixelspacing(2)).^2/sigma^2/2 - (z*pixelspacing(3)).^2/sigma^2/2));
-%   If sigma is a 3D vector, sigma = [sigma_x sigma_y sigma_z],
-%       f(x,y,z) = (2*pi)^(-3/2)/sigma(1)/sigma(2)/sigma(3) * exp(-((x*pixelspacing(1)).^2/sigma(1)^2/2 - (y*pixelspacing(2)).^2/sigma(2)^2/2 - (z*pixelspacing(3)).^2/sigma(3)^2/2));
-%
-% Remarks
-%   The outputs of gauss3filter(I), gauss3filter(I, 1) and
-%   gauss3filter(I, 1, [1 1 1]) are identical.
-% 
-%   To enable GPU computation (Matlab 2012a or later, CUDA 1.3 GPU are required), use
-%   R = gauss3filter(gpuArray(I), sigma, pixelspacing).
-%
-%   The Gaussian kernel in the frequency domain is
-%   exp(-2*pi*pi* (u.^2 *sigma1 + v.^2 *sigma2 + w.^2 * sigma3));
-%
-%   Please kindly cite the following paper if you use this program, or any code 
-%   extended from this program.
-%       Max W. K. Law and Albert C. S. Chung, "Efficient Implementation for Spherical Flux Computation and Its Application to Vascular Segmentation,
-%       IEEE Transactions on Image Processing, 2009, Volume 18(3), 596V612
-%
-% Author: Max W.K. Law
-% Email:  max.w.k.law@gmail.com
-% Page:   http://www.cse.ust.hk/~maxlawwk/
-
-
-
-function result=gauss3filter(image, sigma, pixelspacing)
-    if exist('pixelspacing', 'var')~=1
-        pixelspacing=[1 1 1];
-    end
-
-    if exist('sigma', 'var')~=1
-        sigma=1;
-    end
-    
-    %imgfreq=fftn(image);
-    if (size(sigma)==1)
-        sigma1=sigma;
-        sigma2=sigma;
-        sigma3=sigma;
-    else
-        sigma1=sigma(1);
-        sigma2=sigma(2);
-        sigma3=sigma(3);
-    end
-
-    sigma1=sigma1^2;
-    sigma2=sigma2^2;
-    sigma3=sigma3^2;    
-    
-    [u,v,w] = ifftshiftedcoormatrix3(size(image) );
-    
-% The term "image*0" forces x, y and z to have the type as "image". They
-% are thus authomatically moved to GPU if "image" is an GPU array.
-    u=image*0 + u/size(image,1)/pixelspacing(1);    
-    v=image*0 + v/size(image,2)/pixelspacing(2);
-    w=image*0 + w/size(image,3)/pixelspacing(3);
-
-% Original Gaussian kernel    
-    fil = GaussianKernel(u, v, w, sigma1, sigma2, sigma3);
-% Subband_1.5 frequency oversampling component. Comment the following
-% section to disable the Subband_1.5 technique.
-    fil = fil + GaussianKernel(u+1/pixelspacing(1), v, w, sigma1, sigma2, sigma3);
-    fil = fil + GaussianKernel(u-1/pixelspacing(1), v, w, sigma1, sigma2, sigma3);
-    fil = fil + GaussianKernel(u, v+1/pixelspacing(2), w, sigma1, sigma2, sigma3);
-    fil = fil + GaussianKernel(u, v-1/pixelspacing(2), w, sigma1, sigma2, sigma3);
-    fil = fil + GaussianKernel(u, v, w+1/pixelspacing(3), sigma1, sigma2, sigma3);
-    fil = fil + GaussianKernel(u, v, w-1/pixelspacing(3), sigma1, sigma2, sigma3);
-
-   
-    fil = fil / max(fil(:)); % Normalization improves accuracy when sigma is small (e.g. sigma<0.8 voxel length)
-% End of Subband_1.5 frequency oversampling component
-
-% MatLab has a weird memory management for the complex->real transform.
-% If you are experiencing memory errors, replace the following line with 
-% result = real(ifftn(fil.*fftn(image));
-    result = ifftn(fil.*fftn(image), 'symmetric');
-
-    
-end
-
-function output=GaussianKernel(u, v, w, sigma1, sigma2, sigma3)
-    output = exp(-2*pi*pi* (u.^2 *sigma1 + v.^2 *sigma2 + w.^2 * sigma3));
-end
-
-% This function gives the ifftshifted coordinates in the frequency domain
-function varargout=ifftshiftedcoormatrix3(dimension)
-dim=length(dimension);
-p = floor(dimension/2);
-
-    for i=1:3
-        a=single([p(i)+1:dimension(i) 1:p(i)])-p(i)-1;
-        reshapepara=ones(1,dim, 'single');
-        reshapepara(i)=dimension(i);
-        A=reshape(a, reshapepara);
-        repmatpara=dimension;
-        repmatpara(i)=1;
-        varargout{i}=repmat(A, repmatpara);
-    end
-
-end
\ No newline at end of file
diff --git a/Generator/library/gaussian_kernel.m b/Generator/library/gaussian_kernel.m
deleted file mode 100644
index 2e4525b..0000000
--- a/Generator/library/gaussian_kernel.m
+++ /dev/null
@@ -1,7 +0,0 @@
-function h = gaussian_kernel(sigx,sz)
-
-% h = gaussian_kernel(sigx,sz)
-
-[x,y]   = meshgrid(-(sz/2):1:(sz/2)-1,-(sz/2):1:(sz/2)-1);
-rad2    = x.^2+y.^2;
-h       = exp(-rad2./(2*sigx^2))./(2*pi*sigx^2);
diff --git a/Generator/library/hsymmetry.m b/Generator/library/hsymmetry.m
deleted file mode 100755
index a90065e..0000000
--- a/Generator/library/hsymmetry.m
+++ /dev/null
@@ -1,26 +0,0 @@
-function cout = hsymmetry( cin )
-
-% use Hermitian symmetry ( for real signal ) to compute the full spectrum
-% from the half spectrum - assumes DC is centered !
-
-mdim = size(cin,2);
-icen=mdim/2 + 1;
-
-cout = cin;
-
-
-%** conjugate the zero frequencies change
-cout(icen,icen+1:mdim) = conj(cout(icen,(icen-1):-1:2));
-cout(icen+1:mdim,icen) = conj(cout((icen-1):-1:2,icen));
-
-
-% stripe the high frequencies 
-cout(icen+1:mdim,1) = conj(cout(icen-1:-1:2,1));
-
-
-%** fill in other 2 quadrants 
-cout((icen+1):mdim,(icen+1):mdim) = conj(cout((icen-1):-1:2,(icen-1):-1:2));
-cout((icen+1):1:mdim,(icen-1):-1:2) = conj(cout((icen-1):-1:2,(icen+1):1:mdim));
-
-cout  = fftshift(cout);
-
diff --git a/Generator/library/image_com.m b/Generator/library/image_com.m
deleted file mode 100644
index ebceda6..0000000
--- a/Generator/library/image_com.m
+++ /dev/null
@@ -1,31 +0,0 @@
-function [vecs,phase0] = image_com(im)
-
-% c = image_com(im)
-%    Computes the centroid of 2D array im with respect to the center
-%    of the array
-
-v = zeros(2,size(im,3));
-s = size(im(:,:,1));   
-[x y] = meshgrid(1:s(2),1:s(1));
-
-mdim    = size(im,1);
-icen    = mdim/2+1;
-
-%** calculate the centroids 
-pix_num  = -mdim/2:1:(mdim-1)/2; 
-vecs = zeros(2,size(im,3));
-
-phase0 = zeros(size(im));
-for k=1:size(im,3)
-    img1_sum = sum(im(:,:,k),1);
-    img2_sum = sum(im(:,:,k),2);
-    c(1) = sum(pix_num(:).*img1_sum(:))/sum(img1_sum);
-    c(2) = sum(pix_num(:).*img2_sum(:))/sum(img2_sum);
-    vecs(:,k) = [ c(1) c(2) ]';
-    [x,y]=meshgrid(-mdim/2:1:mdim/2-1,-mdim/2:1:mdim/2-1);
-    im1 = (2*pi*((vecs(1,k).*x))/mdim);
-    im2 = (2*pi*((vecs(2,k).*y))/mdim);
-    phase0(:,:,k) = -(im1+im2);
-       
-end
-
diff --git a/Generator/library/image_rmse.m b/Generator/library/image_rmse.m
deleted file mode 100644
index d95f38a..0000000
--- a/Generator/library/image_rmse.m
+++ /dev/null
@@ -1,68 +0,0 @@
-function results = image_rmse(fx,ft,center_image,mask_fourier,mask_image)
-
-%% results = image_rmse(estimate,truth,center_image,mask_fourier)
-
-% computes the RMSE in the image/Fourier domains when the truth object is
-% known
-%
-% >> results = image_rmse(estimate,truth)
-%
-% results = 
-% 
-%           rmse_fourier: [51,512 double]
-%             rmse_image: [512x512 double]
-%     rmse_fourier_total: 0.3649
-%       rmse_image_total: 0.3649
-%     
-%
-
-if nargin == 4
-    mask = ones(size(ft));
-end
-      
-mdim = size(ft,1);
-icen = mdim/2+1;
-if nargin < 4 
-    mask_fourier = ones(mdim);
-end
-
-if center_image 
-
-    % line search to find image shift required to align with truth 
-    FX =fft2(fx);    
-    options = optimset;options = optimset(options,'Display','iter');
-    options = optimset;options = optimset(options,'Display','none','TolFun',1e-6,'TolX',1e-6);    
-    x0=rand(2,1);
-    [xx,fval,exitflag,output]=fminsearch(@func_object_move,x0(:),options,fx,ft,mask_image);
-    dr=xx(1);
-    dc=xx(2);
-
-    for r=1:mdim
-        for c=1:mdim
-            im(r,c,1) = -(2*pi*(dc*(c-icen))/mdim);
-            im(r,c,2) = -(2*pi*(dr*(r-icen))/mdim);  
-        end
-    end
-    cexp    = ifftshift(complex(cos(im(:,:,1)+im(:,:,2)),sin(im(:,:,1)+im(:,:,2))));
-else   
-    FX =fft2(fx);
-    cexp = ones(mdim);
-end
-FXp      = FX.*cexp;
-fxp      = real(ifft2(FXp));
-
-FT = fft2(ft);
-results.rmse_fourier = mask_fourier.*fftshift(sqrt( abs(FXp - FT).^2./abs(FT).^2));
-
-results.dr = dr;
-results.dc = dc;
-results.mean_rmse_fourier = sum(results.rmse_fourier(find(mask_fourier==1)))./length(find(mask_fourier==1));
-results.rmse_image   = (fxp - ft).^2./ft.^2;
-results.rmse_fourier_total =  sqrt(sum(sum(abs(FXp - FT).^2))./sum(sum(abs(FT).^2)));
-results.rmse_image_total   =  sqrt(sum(sum( (fxp - ft).^2))./sum(sum(ft.^2)));
-results.fx_input   = fx;
-results.fx_aligned =  fxp;
-results.ft = ft;
-results.azi_avg = azi_avg(results.rmse_fourier,ones(size(fx)));
-
-
diff --git a/Generator/library/imnoisex.m b/Generator/library/imnoisex.m
deleted file mode 100644
index 5878f35..0000000
--- a/Generator/library/imnoisex.m
+++ /dev/null
@@ -1,431 +0,0 @@
-function b = imnoise(varargin)
-%IMNOISE Add noise to image.
-%   J = IMNOISE(I,TYPE,...) Add noise of a given TYPE to the intensity image
-%   I. TYPE is a string that can have one of these values:
-%
-%       'gaussian'       Gaussian white noise with constant
-%                        mean and variance
-%
-%       'localvar'       Zero-mean Gaussian white noise 
-%                        with an intensity-dependent variance
-%
-%       'poisson'        Poisson noise
-%
-%       'salt & pepper'  "On and Off" pixels
-%
-%       'speckle'        Multiplicative noise
-%
-%   Depending on TYPE, you can specify additional parameters to IMNOISE. All
-%   numerical parameters are normalized; they correspond to operations with
-%   images with intensities ranging from 0 to 1.
-%   
-%   J = IMNOISE(I,'gaussian',M,V) adds Gaussian white noise of mean M and
-%   variance V to the image I. When unspecified, M and V default to 0 and
-%   0.01 respectively.
-%   
-%   J = imnoise(I,'localvar',V) adds zero-mean, Gaussian white noise of
-%   local variance, V, to the image I.  V is an array of the same size as I.
-%
-%   J = imnoise(I,'localvar',IMAGE_INTENSITY,VAR) adds zero-mean, Gaussian
-%   noise to an image, I, where the local variance of the noise is a
-%   function of the image intensity values in I.  IMAGE_INTENSITY and VAR
-%   are vectors of the same size, and PLOT(IMAGE_INTENSITY,VAR) plots the
-%   functional relationship between noise variance and image intensity.
-%   IMAGE_INTENSITY must contain normalized intensity values ranging from 0
-%   to 1.
-%
-%   J = IMNOISE(I,'poisson') generates Poisson noise from the data instead
-%   of adding artificial noise to the data. In order to respect Poisson
-%   statistics, the intensities of uint8 and uint16 images must correspond
-%   to the number of photons (or any other quanta of information).
-%   Double-precision images are used when the number of photons per pixel
-%   can be much larger than 65535 (but less than 10^12); the intensities
-%   values vary between 0 and 1 and correspond to the number of photons
-%   divided by 10^12.
-%
-%   J = IMNOISE(I,'salt & pepper',D) adds "salt and pepper" noise to the
-%   image I, where D is the noise density.  This affects approximately
-%   D*numel(I) pixels. The default for D is 0.05.
-%   
-%   J = IMNOISE(I,'speckle',V) adds multiplicative noise to the image I,
-%   using the equation J = I + n*I, where n is uniformly distributed random
-%   noise with mean 0 and variance V. The default for V is 0.04.
-%
-%   Note
-%   ----
-%   The mean and variance parameters for 'gaussian', 'localvar', and
-%   'speckle' noise types are always specified as if for a double image
-%   in the range [0, 1].  If the input image is of class uint8 or uint16,
-%   the imnoise function converts the image to double, adds noise
-%   according to the specified type and parameters, and then converts the
-%   noisy image back to the same class as the input.
-%   
-%   Class Support
-%   -------------
-%   I can be of class uint8, uint16, or double. The output image J is of
-%   the same class as I.  If I has more than two dimensions it is treated
-%   as a multidimensional intensity image and not as an RGB image.
-%
-%   Example
-%   -------
-%        I = imread('eight.tif');
-%        J = imnoise(I,'salt & pepper', 0.02);
-%        imview(I), imview(J)
-%
-%   See also IMNSTATS, RAND, RANDN.
-
-%   Copyright 1993-2003 The MathWorks, Inc.  
-%   $Revision: 5.20.4.3 $  $Date: 2003/08/01 18:09:05 $
-
-  [a, code, classIn, classChanged, p3, p4] = ParseInputs(varargin{:});
-
-  clear varargin;
-  sizeA = size(a);
-
-  switch code
-   case 'gaussian' % Gaussian white noise
-    b = a + sqrt(p4)*randn(sizeA) + p3;
-    
-   case 'localvar_1' % Gaussian white noise with variance varying locally
-                     % imnoise(a,'localvar',v)
-                     % v is local variance array
-    b = a + sqrt(p3).*randn(sizeA); % Use a local variance array
-    
-   case 'localvar_2' % Gaussian white noise with variance varying locally
-                     % Use an empirical intensity-variance relation
-    intensity = p3(:); % Use an empirical intensity-variance relation
-    var       = p4(:);
-    minI  = min(intensity);
-    maxI  = max(intensity);
-    b     = min(max(a,minI),maxI);
-    b     = reshape(interp1(intensity,var,b(:)),sizeA);
-    b     = a + sqrt(b).*randn(sizeA);
-    
-   case 'poisson' % Poisson noise
-    switch classIn
-     case 'uint8'
-      a = round(a*255); 
-     case 'uint16'
-      a = round(a*65535);
-     case 'double'
-      a = round(a*10^12); % Recalibration
-    end
-    
-    a = a(:);
-
-    %  (Monte-Carlo Rejection Method) Ref. Numerical 
-    %  Recipes in C, 2nd Edition, Press, Teukolsky, 
-    %  Vetterling, Flannery (Cambridge Press)
-    
-    b=zeros(size(a));
-    idx1=find(a<50); % Cases where pixel intensities are less than 50 units
-    if (~isempty(idx1))
-      g=exp(-a(idx1));
-      em=-ones(size(g));
-      t=ones(size(g));
-      idx2= (1:length(idx1))';
-      while ~isempty(idx2)
-        em(idx2)=em(idx2)+1;
-        t(idx2)=t(idx2).*rand(size(idx2));
-        idx2 = idx2(t(idx2) > g(idx2));
-      end
-      b(idx1)=em;
-    end
-
-    % For large pixel intensities the Poisson pdf becomes 
-    % very similar to a Gaussian pdf of mean and of variance
-    % equal to the local pixel intensities. Ref. Mathematical Methods
-    % of Physics, 2nd Edition, Mathews, Walker (Addison Wesley)
-    idx1=find(a>=50); % Cases where pixel intensities are more than 49 units
-    if (~isempty(idx1))
-      b(idx1)=round(a(idx1)+sqrt(a(idx1)).*randn(size(idx1)));
-    end
-    
-    b = reshape(b,sizeA);
-    
-   case 'salt & pepper' % Salt & pepper noise
-    b = a;
-    x = rand(sizeA);
-    d = find(x < p3/2);
-    b(d) = 0; % Minimum value
-    d = find(x >= p3/2 & x < p3);
-    b(d) = 1; % Maximum (saturated) value
-    
-   case 'speckle' % Speckle (multiplicative) noise
-    b = a + sqrt(12*p3)*a.*(rand(sizeA)-.5);
-    
-  end
-
-  % Truncate the output array data if necessary
-  if strcmp(code,{'poisson'})
-    switch classIn
-     case 'uint8'
-      b = uint8(b); 
-     case 'uint16'
-      b = uint16(b);
-     case 'double'
-      b = min(b/10^12,1); 
-    end
-  else    
-    b = max(0,min(b,1));
-    % The output class should be the same as the input class
-    if classChanged,
-      b = changeclass(classIn, b);
-    end
-  end
-
-
-%%%
-%%% ParseInputs
-%%%
-function [a, code, classIn, classChanged, p3, p4, msg] = ParseInputs(varargin)
-
-% Initialization
-a            = [];
-code         = 'gaussian';
-classIn      = '';
-classChanged = [];
-p3           = [];
-p4           = [];
-msg = '';
-
-% Check the number of input arguments.
-
-% checknargin(1,4,nargin,mfilename);
-
-% Check the input-array type.
-a = varargin{1};
-% checkinput(a, {'uint8','uint16','double'}, '', mfilename, 'I', 1);
-
-% Change class to double
-classIn = class(a);
-classChanged = 0;
-if ~isa(a, 'double')
-  a = im2double(a);
-  classChanged = 1;
-else
-  % Check for valid image I
-  if ~(isNonnegativeReal(a(:)) && all(a(:)<=1))
-    eid = sprintf('Images:%s:invalidDoubleImage',mfilename);
-    msg = 'A valid double image must have values between zero and one.';
-    error(eid,'%s',msg);
-  end
-end
-
-% Check the noise type.
-if nargin > 1
-  if ~ischar(varargin{2})
-    eid = sprintf('Images:%s:invalidNoiseType',mfilename);
-    msg = 'TYPE must be a character string.';
-    error(eid,'%s',msg);
-  end
-  
-  % Preprocess noise type string to detect abbreviations.
-  allStrings = {'gaussian', 'salt & pepper', 'speckle',...
-                'poisson','localvar'};
-  idx = strmatch(lower(varargin{2}), allStrings);
-  switch length(idx)
-   case 0
-    eid = sprintf('Images:%s:unknownNoiseType',mfilename);
-    msg = sprintf('Unknown noise type: ''%s''.', varargin{2});
-    error(eid,'%s',msg);
-   case 1
-    code = allStrings{idx};
-   otherwise
-    eid = sprintf('Images:%s:ambiguousNoiseType',mfilename); 
-    msg = sprintf('Ambiguous noise type: ''%s''.', varargin{2});
-    error(eid,'%s',msg); 
-  end
-else
-  code = 'gaussian';  % default noise type
-end 
-
-switch code
- case 'poisson'
-  if nargin > 2
-    eid = sprintf('Images:%s:tooManyPoissonInputs',mfilename);
-    msg = 'Too many inputs for ''poisson'' noise.';
-    error(eid,'%s',msg);
-  end
-  
- case 'gaussian'
-  p3 = 0;     % default mean
-  p4 = 0.01;  % default variance
-  
-  if nargin > 2
-    p3 = varargin{3};
-    if ~isRealScalar(p3)
-      eid = sprintf('Images:%s:invalidMean',mfilename);
-      msg = 'For ''gaussian'' noise, M must be a real scalar.';
-      error(eid,'%s',msg);
-    end
-  end
-  
-  if nargin > 3
-    p4 = varargin{4};
-    if ~isNonnegativeRealScalar(p4)
-      eid = sprintf('Images:%s:invalidVariance',mfilename);      
-      msg = 'For ''gaussian'' noise, V must be a real nonnegative scalar.';
-      error(eid,'%s',msg); 
-    end
-  end
-  
-  if nargin > 4
-    eid = sprintf('Images:%s:tooManyGaussianInputs',mfilename);      
-    msg = 'Too many inputs for ''gaussian'' noise.';
-    error(eid,'%s',msg); 
-    return;
-  end
-  
- case 'salt & pepper'
-  p3 = 0.05;   % default density
-  
-  if nargin > 2
-    p3 = varargin{3};
-    if ~isNonnegativeRealScalar(p3) || (p3 > 1)
-      eid = sprintf('Images:%s:invalidNoiseDensity',mfilename);            
-      msg1 = 'For ''salt & pepper'' noise, D must be a real nonnegative ';
-      msg2 = 'scalar less than or equal to 1.';
-      msg = sprintf('%s\n%s',msg1,msg2);
-      error(eid,'%s',msg);
-    end
-    
-    if nargin > 3
-      eid = sprintf('Images:%s:tooManySaltAndPepperInputs',mfilename);      
-      msg = 'Too many inputs for ''salt & pepper'' noise.';
-      error(eid,'%s',msg);
-    end
-  end
-  
- case 'speckle'
-  p3 = 0.05;    % default variance
-  
-  if nargin > 2
-    p3 = varargin{3};
-    if ~isNonnegativeRealScalar(p3)
-      eid = sprintf('Images:%s:invalidVariance',mfilename);
-      msg = 'For ''speckle'' noise, V must be a nonnegative real scalar.';
-      error(eid,'%s',msg);
-    end
-  end
-  
-  if nargin > 3
-    eid = sprintf('Images:%s:tooManySpeckleInputs',mfilename);
-    msg = 'Too many inputs for ''speckle'' noise.';
-    error(eid,'%s',msg);
-  end
-  
- case 'localvar'
-  if nargin < 3
-    eid = sprintf('Images:%s:toofewLocalVarInputs',mfilename);
-    msg = 'Too few inputs for ''localvar'' noise.';
-    error(eid,'%s',msg);
-    
-  elseif nargin == 3
-    % IMNOISE(a,'localvar',v)
-    code = 'localvar_1';
-    p3 = varargin{3};
-    if ~isNonnegativeReal(p3) || ~isequal(size(p3),size(a))
-      eid = sprintf('Images:%s:invalidLocalVariance',mfilename);
-      msg1 = 'For the ''localvar'' noise syntax, V must contain ';
-      msg2 = 'only nonnegative real values and be the same size as A.';
-      msg = sprintf('%s\n%s',msg1,msg2);
-      error(eid,'%s',msg);
-    end
-    
-  elseif nargin == 4
-    % IMNOISE(a,'localvar',IMAGE_INTENSITY,NOISE_VARIANCE)
-    code = 'localvar_2';
-    p3 = varargin{3};
-    p4 = varargin{4};
-    
-    if ~isNonnegativeRealVector(p3) || (any(p3) > 1)
-      eid = sprintf('Images:%s:invalidImageIntensity',mfilename);
-      msg1 = 'For ''localvar'' noise, IMAGE_INTENSITY must be a ';
-      msg2 = 'nonnegative real vector less than or equal to 1.';
-      msg = sprintf('%s\n%s',msg1,msg2);
-      error(eid,'%s',msg);
-    end
-    
-    if ~isNonnegativeRealVector(p4)
-      eid = sprintf('Images:%s:invalidLocalVariance',mfilename);
-      msg1 = 'For ''localvar'' noise, NOISE_VARIANCE must be a ';
-      msg2 = 'nonnegative real vector.';
-      msg = sprintf('%s\n%s',msg1,msg2);
-      error(eid,'%s',msg);
-    end
-    
-    if ~isequal(size(p3),size(p4))
-      eid = sprintf('Images:%s:invalidSize',mfilename);
-      msg1 = 'For ''localvar'' noise, IMAGE_INTENSITY and '; 
-      msg2 = 'NOISE_VARIANCE must be the same size.';
-      msg = sprintf('%s\n%s',msg1,msg2);
-      error(eid,'%s',msg);
-    end
-    
-  else
-    eid = sprintf('Images:%s:tooManyLocalVarInputs',mfilename);
-    msg = 'Too many inputs for ''localvar'' noise.';
-    error(eid,'%s',msg);
-  end
-  
-end
-
-%%%
-%%% isReal
-%%%
-function t = isReal(P)
-%   isReal(P) returns 1 if P contains only real  
-%   numbers and returns 0 otherwise.
-%
-  isFinite  = all(isfinite(P(:)));
-  t = isreal(P) && isFinite && ~isempty(P);
-
-
-%%%
-%%% isNonnegativeReal
-%%%
-function t = isNonnegativeReal(P)
-%   isNonnegativeReal(P) returns 1 if P contains only real  
-%   numbers greater than or equal to 0 and returns 0 otherwise.
-%
-  t = isReal(P) && all(P(:)>=0);
-
-
-%%%
-%%% isRealScalar
-%%%
-function t = isRealScalar(P)
-%   isRealScalar(P) returns 1 if P is a real, 
-%   scalar number and returns 0 otherwise.
-%
-  t = isReal(P) && (numel(P)==1);
-
-
-%%%
-%%% isNonnegativeRealScalar
-%%%
-function t = isNonnegativeRealScalar(P)
-%   isNonnegativeRealScalar(P) returns 1 if P is a real, 
-%   scalar number greater than 0 and returns 0 otherwise.
-%
-  t = isReal(P) && all(P(:)>=0) && (numel(P)==1);
-
-
-%%%
-%%% isVector
-%%%
-function t = isVector(P)
-%   isVector(P) returns 1 if P is a vector and returns 0 otherwise.
-%
-  t = ((numel(P) >= 2) && ((size(P,1) == 1) || (size(P,2) == 1)));
-
-
-%%%
-%%% isNonnegativeRealVector
-%%%
-function t = isNonnegativeRealVector(P)
-%   isNonnegativeRealVector(P) returns 1 if P is a real, 
-%   vector greater than 0 and returns 0 otherwise.
-%
-  t = isReal(P) && all(P(:)>=0) && isVector(P);
\ No newline at end of file
diff --git a/Generator/library/k_padarray.m b/Generator/library/k_padarray.m
deleted file mode 100755
index 3bcfcf2..0000000
--- a/Generator/library/k_padarray.m
+++ /dev/null
@@ -1,29 +0,0 @@
-function [ out_arr ] = padarray(arr,pad_dim,where,where2)
-
-if  nargin > 3 | strcmpi(where,'both')
-    nslices = size(arr,3);
-    ndim = pad_dim(1) + size(arr,1) + pad_dim(2);
-    ndim2 = size(arr,1);
-    out_arr = zeros(ndim,ndim,nslices);
-    for kk=1:nslices
-        out_arr(pad_dim(1)+1:(pad_dim(1)+1 + ndim2-1),pad_dim(1)+1:(pad_dim(1)+1 + ndim2-1),kk) = arr(:,:,kk);
-    end
-end
-%  phasek_pad = padarray(padarray(phasek, pad_size_pre, 'pre'), pad_size_post, 'post');
-nslices = size(arr,3);
-if strcmpi(where,'pre')   
-        out_arr = zeros( size(arr,1) + pad_dim(1),size(arr,2) + pad_dim(2),nslices);
-        for kk=1:nslices
-            out_arr(pad_dim+1:end,pad_dim+1:end,kk) = arr(:,:,kk);
-        end        
-end
-if strcmpi(where,'post')
-    out_arr = zeros( size(arr,1) + pad_dim(1),size(arr,2) + pad_dim(2),nslices);
-    for kk=1:nslices 
-        out_arr(1:size(arr,1),1:size(arr,2),kk) = arr(:,:,kk);
-    end
-end
-
-
-end
-
diff --git a/Generator/library/make_circle_mask.m b/Generator/library/make_circle_mask.m
deleted file mode 100644
index 439a7c7..0000000
--- a/Generator/library/make_circle_mask.m
+++ /dev/null
@@ -1,19 +0,0 @@
-function mask = make_circle_mask(sz,rad)
-
-% mask = dora_make_mask(sz,rad)
-
-c1 = -((sz-1)/2);
-c2 = sz+c1-1;
-
-[x,y]   = meshgrid([c1:c2],[c1:c2]);
-rho     = sqrt(x.*x+y.*y);
-
-
-
-theta = atan2(y,x);
-
-mask=circle(sz,sz,[(sz+1)/2 (sz+1)/2]);
-mask(rho>rad)=0.0;
-
-
-
diff --git a/Generator/library/model_polychromatic_psf.m b/Generator/library/model_polychromatic_psf.m
deleted file mode 100755
index 939de11..0000000
--- a/Generator/library/model_polychromatic_psf.m
+++ /dev/null
@@ -1,51 +0,0 @@
-function psfs_poly  = model_polychromatic_psf(phase, pupil_poly, uber_cfg )
-
-
-if uber_cfg.dlambda>0
-    pupil_max = (1 + uber_cfg.dlambda/(2*uber_cfg.lambda))*uber_cfg.pdim;
-    pupil_max = 2*round(pupil_max/2);
-
-    pupil_min = (1 - uber_cfg.dlambda/(2*uber_cfg.lambda))*uber_cfg.pdim;
-    pupil_min = 2*round(pupil_min/2);
-
-    %pupild = pupil_min:2:pupil_max;uber
-    pupild = pupil_min:pupil_max;
-
-    idx0 = find(pupild == uber_cfg.pdim);
-
-    idx = round(linspace(1, length(pupild), uber_cfg.color_planes));
-    if ~any(idx(:) == idx0)
-      %  In this case, the pupil diameter spacing strange -- trying to fix
-      %  I'm not sure if this conditional statement is needede.  Might be
-      %  good to remove.
-    %  idx(round(length(idx)/2)) = idx0;
-    end
-    pupild = pupild(idx);
-else     
-    pupild = uber_cfg.pdim; 
-end
-
-
-
-h = zeros(uber_cfg.mdim,uber_cfg.mdim, size(phase,3), length(pupild));
-for k = 1:length(pupild)
-  poly_scale = uber_cfg.pdim/pupild(k);
-  for j = 1:size(phase,3)
-    phi  = phase(:,:,j)./poly_scale;
-    P    = pupil_poly.*exp(sqrt(-1)*phi);
-    psf1 = ifftshift(abs(ifft2(P)).^2);
-    %
-    % The next function does an interpolation.  Since we always use
-    % 'same' in the original code, I've changed this to eliminate the
-    % input variable 'same'.
-    %
-    % psf1 = ImgScale(psf1, poly_scale, 'same');
-    psf1 = p_ImgScale(psf1, poly_scale);
-    h(:,:,j,k) = psf1;
-  end        
-end
-psfs_poly = squeeze(mean(h,4));
-for j=1:size(psfs_poly,3)
-    frm = psfs_poly(:,:,j);frm = ifftshift(frm);
-    psfs_poly(:,:,j) = frm./sum(frm(:));
-end
diff --git a/Generator/library/movingmean.m b/Generator/library/movingmean.m
deleted file mode 100755
index a0e750d..0000000
--- a/Generator/library/movingmean.m
+++ /dev/null
@@ -1,403 +0,0 @@
-function result=movingmean(data,window,dim,option)
-%Calculates the centered moving average of an n-dimensional matrix in any direction. 
-%   result=movingmean(data,window,dim,option)
-
-%   Inputs: 
-%   1)  data = The matrix to be averaged. 
-%   2)  window = The window size.  This works best as an odd number.  If an even 
-%       number is entered then it is rounded down to the next odd number.  
-%   3)  dim = The dimension in which you would like do the moving average.
-%       This is an optional input.  To leave blank use [] place holder in
-%       function call.  Defaults to 1.
-%   4)  option = which solution algorithm to use.  The default option works
-%       best in most situations, but option 2 works better for wide
-%       matrices (i.e. 1000000 x 1 or 10 x 1000 x 1000) when solved in the
-%       shorter dimension.  Data size where option 2 is more efficient will 
-%       vary from computer to computre.This is an optional input.  To leave  
-%       blank use [] place holder in function call.  Defaults to 1.
-% 
-%   Example:  
-%   Calculate column moving average of 10000 x 10 matrix with a window size 
-%   of 5 in the 1st dimension using algorithm option 1.
-%   d=rand(10000,10);
-%   dd=movingmean(d,5,1,1);
-%           or
-%   dd=movingmean(d,5,[],1);
-%           or
-%   dd=movingmean(d,5,1,[]);
-%           or
-%   dd=movingmean(d,5,1);
-%           or
-%   dd=movingmean(d,5,[],[]);
-%           or
-%   dd=movingmean(d,5);
-%
-%   Moving mean for each element uses data centered on that element and
-%   incorporates (window-1)/2 elements before and after the element.
-%
-%   Function is broken into two parts.  The 1d-2d solution, and the
-%   n-dimensional solution.  The 1d-2d solution is the fastest that I have 
-%   been able to come up with, whereas the n-dimensional solution trades
-%   speed for versatility.
-%
-%   Function includes some code at the end so that the user can do their
-%   own speed testing using the TIMEIT function.
-%
-%   Has been heavily tested in 1d-2d case, and lightly tested in 3d case.
-%   Should work in n-dimensional space, but has not been tested in more 
-%   than 3 dimensions other than to make sure it does not return an error.
-%   Has not been tested for complex inputs.
-
-
-%errors for leaving out data or window inputs
-if ~nargin
-    error('no input data')
-end
-
-if nargin<2
-    error('no window size specified')
-end
-
-%defaults the dimension and option to 1 if it is not specified
-if nargin<3 || isempty(dim)
-    dim=1;
-end
-
-if nargin<4 || isempty(option)
-    option=1;
-end
-
-
-%rounds even window sizes down to next lowest odd number
-if mod(window,2)==0
-    window=window-1;
-end
-
-%Calculates the number of elements in before and after the central element
-%to incorporate in the moving mean.  Round command is just present to deal
-%with the potential problem of division leaving a very small decimal, ie.
-%2.000000000001.
-halfspace=round((window-1)/2);
-
-%calculates the size of the input data set
-n=size(data);
-
-%returns error messages for incorrect inputs
-if mod(dim,1)
-    error('dimension number must be integer')
-end
-
-if ((ndims(data)<=2 && (option<1 || option>3)) || (ndims(data)>=3 && (option<1 ||option>2))) ...
-       || mod(option,1)
-    error('invalid algorithm option')
-end
-
-if mod(window,1)
-    error('window size must be integer')
-end
-
-if dim>ndims(data)
-    error('dimension number exceeds number of dimensions in input matrix')
-end
-
-if dim<1
-    error('dimension number must be >=1')
-end
-
-if n(dim)<window
-    error('window is too large')
-end
-
-
-if ndims(data)<=2
-    %Solution for 1d-2d situation.  Uses vector operations to optimize
-    %solution speed.
-    
-    %To simplify algorithm the problem is always solved with dim=1.
-    %If user input is dim=2 then the data is transposed to calculate the
-    %solution in dim=1
-    if dim==2
-        data=data';
-    end
-  
-    
-    %The three best solutions I came up to for the 1d-2d problem.  I kept
-    %them in here to preserve the code incase I want to use some of it
-    %again.  I have found that option 1 is consistenetly the fastest.
-    %option=1;
-    switch option
-        case 1
-            %option 1, works best for most data sets
-            
-            %Computes the beginning and ending column for each moving
-            %average compuation.  Divide is the number of elements that are
-            %incorporated in each moving average.
-            start=[ones(1,halfspace+1) 2:(n(dim)-halfspace)];
-            stop=[(1+halfspace):n(dim) ones(1,halfspace)*n(dim)];
-            divide=stop-start+1;
-     
-            %Calculates the moving average by calculating the sum of elements
-            %from the start row to the stop row for each central element,
-            %and then dividing by the number of elements used in that sum
-            %to get the average for that central element.
-            %Implemented by calculating the moving sum of the full data
-            %set.  Cumulative sum for each central element is calculated by
-            %subtracting the cumulative sum for the row before the start row
-            %from the cumulative sum for the stop row.  Row references are
-            %adusted to take into account the fact that you can now
-            %reference a row<1.  Divides the series of cumulative sums for
-            %by the number of elements in each sum to get the moving
-            %average.
-            CumulativeSum=cumsum(data);
-            temp_sum=CumulativeSum(stop,:)-CumulativeSum(max(start-1,1),:);
-            temp_sum((start==1),:)=bsxfun(@plus,temp_sum((start==1),:),data(1,:));
-            result=bsxfun(@rdivide,temp_sum,divide');
-            
-        case 2
-            %option 2, Can be faster than option 1 in very wide matrices
-            %(i.e. 100 x 1000 or l000 x 10000) when solving in the shorter
-            %dimension, but in general it is slower than option 1.
-            %Uses a for loop to calculate the data from the start row to
-            %the stop row, and then divides by the number of rows
-            %incorporated.
-            
-            result=zeros(size(data));
-            for i=1:n(dim)
-                start=max(1,i-halfspace);
-                stop=min(i+halfspace,n(dim));
-                result(i,:)=sum(data(start:stop,:),1)/(stop-start+1);
-            end
-            
-        case 3
-            %option 3, Creates a sparse matrix to indicate which rows to include
-            %data from for the moving average for each central element.
-            %Uses matrix multiplication to calculte the cumulative sum for 
-            %each central element.  Then divides by the number of elements
-            %used in each cumulative sum to get the average for each
-            %central element.
-            %Elegant but slow.  I think this is because bsxfun has to do
-            %a lot of matrix replication.  Also, it is easy for the use matrix to
-            %exceed the maximum matrix dimensions for MATLAB.
-     
-            start=[ones(1,halfspace+1) 2:(n(dim)-halfspace)];
-            start=start';
-     
-            stop=[(1+halfspace):n(dim) ones(1,halfspace)*n(dim)];
-            stop=stop';
-     
-            divide=stop-start+1;
-    
-            baseline=1:n(dim);
-     
-            use=sparse(n(dim),n(dim),n(dim)*max(divide));
-            use=(bsxfun(@ge,baseline,start) & bsxfun(@le,baseline,stop));
-     
-            %uses matrix multiplication instead of repmat or bsxfun, slower than
-            %using bsxfun
-            %baseline_mat=ones(n(dim),1)*baseline;
-            %start_mat=start*ones(1,n(dim));
-            %stop_mat=stop*ones(1,n(dim));
-        
-            %use=(baseline_mat>=start_mat & baseline_mat<=stop_mat);
-            %use=sparse(use);
-    
-            result=bsxfun(@rdivide,use*data,divide);
-    end
-
-    %Transposes the matrix if the problem was solved in dimension=2 so that
-    %the ouput is correctly oriented. Undoes the initial transposition.
-    if dim==2
-        result=result';
-    end
-else
-    %Solution of the n-dimensional problem.  This solution is 
-    %slower than the 1d-2d solution in a 1d-2d problem, but depending on the
-    %dimensions of the input array can be faster for the same number of
-    %elements in a 3d+ problem (ie. 1000000 x 1 vs 100 x 100 x 100).  
-    %Either way it is much more versatile.  The algorithm can solve for a 
-    %moving average in any dimension of an n-dimension input matrix.
-    
-    %Two solutions of the problem.  In general option 1 is faster than
-    %option 2, but I think that for some matrix sizes option 2 will be
-    %faster.  
-    %option=1;
-    switch option
- 
-        case 1
-            %Option 1 is based on option 1 for the 1d-2d solution.  In
-            %general this is the faster solution.  For a more extensive
-            %explanation of the code see option 1 in the 1d-2d section.
-            
-            %Calculates the start and stop positions, and creates a vector
-            %of how many elements are in each moving sum.
-            start=[ones(1,halfspace+1) 2:(n(dim)-halfspace)];
-            stop=[(1+halfspace):n(dim) ones(1,halfspace)*n(dim)];
-            divide=stop-start+1;
-            
-            %Reorients the start, stop, and divide vectors in the direction
-            %of the specified dimension.
-            %Creates a vector to use to reshape the start, stop, and divide
-            %vectors.  Puts one in for the each dimension excpet for the
-            %specified dimension, which is set to the size of the input
-            %matrix in that direction.  ex. [1 1 100 1] for a 
-            %100 x 100 x 100 x 100 input matrix, solving in the 3rd
-            %dimension.
-            temp_dims=ones(size(n));
-            temp_dims(dim)=n(dim);
-            
-            %inv_temp_dims=n;
-            %inv_temp_dims(dim)=1;
-            
-            %Uses the vector created above to reorient the start, stop, and
-            %divide vectors in the correct direction.
-            start=reshape(start,temp_dims);
-            stop=reshape(stop,temp_dims);
-            divide=reshape(divide,temp_dims);
-            
-            %Calculates the cumulative sum of the data in the specified
-            %direction.
-            CumulativeSum=cumsum(data,dim);
-            
-            %I have found the most versatile way of writing an algorithm
-            %that will solve in any dimension of an unknown dimensional
-            %input matrix is to built some functions with text that is
-            %based on the input parameters.
-            
-            %This text builds the function that subtracts the cumulative
-            %sum at the stop position from the cumulative sum at one
-            %element before the start position for each central element.
-            %Compensates for not have an index less than 1.
-            function_text=['@(CumulativeSum,start,stop) CumulativeSum(' repmat(':,',1,dim-1) 'stop,' repmat(':,',1,ndims(data)-dim)];
-            function_text=function_text(1,1:end-1);
-            function_text=[function_text ')-CumulativeSum(' repmat(':,',1,dim-1) 'max(1,start-1),' repmat(':,',1,ndims(data)-dim)];
-            function_text=function_text(1,1:end-1);
-            function_text=[function_text ')'];
-            
-            %Converts the string above into an anonymous function with the
-            %handle "difference".
-            difference=str2func(function_text);
-            
-            %Runs the function built above to determine the cumulative sum
-            %between start and stop.
-            temp_sum=difference(CumulativeSum,start,stop);
-            
-            %Text to make a function that corrects for the fact that the
-            %cumulative sum for moving sums that start at position 1 have
-            %the first data position subtracted out.  This is becasue you
-            %can not have a matrix index less than 1.  Uses bsxfun to
-            %multiply start==1 by the first plane of data (in the
-            %appropriate dimension) and then adding that to temp_sum.  Need
-            %to do it this way vs using something based on reshaping
-            %data(repmat(start,inv_temp_dims)==1) because the correction
-            %needs to be the same size as temp_sum.  This is needed b/c I
-            %do not know how to use text to set the variable elements that
-            %will accept the addition (i.e.
-            %temp_sum(:,:,1:sum(start==1))=).
-            correction_text=['@(temp_sum,start,data) temp_sum+bsxfun(@times,start==1,data(' repmat(':,',1,dim-1) '1,' repmat(':,',1,ndims(data)-dim)];
-            correction_text=correction_text(1,1:end-1);
-            correction_text=[correction_text '))'];
-            
-            %Converts the above text into a function.
-            correction=str2func(correction_text);
-            
-            %Applies the correction describe previously to the temp_sum
-            %matrix
-            temp_sum=correction(temp_sum,start,data);
-            
-            %Divides the temp_sum matrix by the divide vector to
-            %calculate the moving average for each central elemant.
-            result=bsxfun(@rdivide,temp_sum,divide);
-        
-        case 2
-            %An older solution to the n-dimensional moving average problem.
-            
-            %Based on the approach in option 2 in the 1d-2d solution.
-            %Depending on matrix dimensions this might be faster than
-            %option 1 in certain situations (ex input matrix size is 10 x
-            %1000 x 1000 and the average is done in dimension 1).
-            
-            %Builds a string for the function used in the for loop.
-            %Basiscally it builds something like sum(data(:,:,start:stop,:),3) but
-            %is able to work in any dimensions and have start:stop be in
-            %any of those dimensions.
-            function_text='@(start,stop,dim) sum(data(';
-            for i=1:ndims(data)
-                if i==dim 
-                    if i~=1
-                        function_text=[function_text ',start:stop'];
-                    else
-                        function_text=[function_text 'start:stop'];
-                    end
-                else
-                    if i~=1
-                        function_text=[function_text ',:'];
-                    else
-                        function_text=[function_text ':'];
-                    end
-                end 
-            end       
-       
-            function_text=[function_text '),dim)'];
-            
-            %Converts the text above into a function
-            moving_sum=str2func(function_text);
-                  
-            %For loop determines the start position, stop position, and
-            %number of elements for the moving average of each central
-            %element.  Calculates the moving sum for each central element
-            %in that position, and divides by the number of elements to get
-            %the moving average.  
-            for i=1:n(dim)
-                start=max(1,i-halfspace);
-                stop=min(i+halfspace,n(dim));
-                
-                temp_m=moving_sum(start,stop,dim)/(stop-start+1);
-        
-                %This was the most versatile way of reassembling all of the
-                %moving average matrices back into the final output matrix,
-                %although it is slow b/c the result matrix keeps resizing.
-                if i==1
-                    result=temp_m;
-                else
-                    result=cat(dim,result,temp_m);
-                end
-            end
-        
-         
-            
-    end
-end
-
-
-%code for speed testing
-%generates a series of random vectors with 10 to 10000000 cells and then
-%times the moving average at each size.  Time for each input size is
-%stored.
-
-%1d-2d timer test
-%data_power=[1 2 3 4 5 6 7];
-%data_size=10.^data_power;
-%window=5;
-%dim=1;
-%time=zeros(size(data_size));
-
-%for i=1:size(data_size,2)
-%   data=rand(data_size(i),1);
-%   f=@() movingmean(data,window,dim);
-%   time(i)=timeit(f,1);
-%end
-
-
-%3d timer test
-%data_power=[1 2 3];
-%data_size=10.^data_power;
-%window=5;
-%dim=1;
-%time=zeros(size(data_size));
-
-%for i=1:size(data_size,2)
-%   data=rand(data_size(i),100,100);
-%   f=@() movingmean(data,window,dim);
-%   time(i)=timeit(f,1);
-%end
-end
diff --git a/Generator/library/objectDL_start_ovar2.m b/Generator/library/objectDL_start_ovar2.m
deleted file mode 100644
index afdfc88..0000000
--- a/Generator/library/objectDL_start_ovar2.m
+++ /dev/null
@@ -1,33 +0,0 @@
-function fx = objectDL_start_ovar2( fx, pa  ) 
-
-tflux = sum(fx(:));
-if size(pa,3)>1
-
-    % Potentially this is a DAD run so find pupil with greatest extent
-    pixel_ct = zeros(size(pa,3),1);
-    for k=1:size(pa,3)
-        frm1 = pa(:,:,k);
-        frm1 = frm1./max(frm1(:));
-        pixel_ct(k) = sum(sum(frm1(:)));
-    end
-    kk = find( pixel_ct == max(pixel_ct(:)));
-    pa1 = pa(:,:,kk(1));
-else
-    pa1 = pa;
-end
-a = ifft2(pa1);h=abs(a).^2;h=h./sum(h(:));
-Hmodsq  = abs(fftshift(fft2(h))).^2;
-idx     = find(Hmodsq > 1e-5);
-mmask   = zeros(size(Hmodsq));
-mmask(idx) = 1.0;
-mmask = ifftshift(mmask);
-
-
-for j=1:100
-    fx_nn   = abs(fx);
-    FX_NN   = fft2(fx_nn);
-    FX_NN   = FX_NN.*mmask;
-    fx      = real(ifft2(FX_NN));
-end
-fx = abs(fx);
-fx = fx.*tflux;
\ No newline at end of file
diff --git a/Generator/library/p_GetPupilDiams.m b/Generator/library/p_GetPupilDiams.m
deleted file mode 100644
index 2f803bf..0000000
--- a/Generator/library/p_GetPupilDiams.m
+++ /dev/null
@@ -1,47 +0,0 @@
-function pupild = p_GetPupilDiams(lambda0, dlambda, pupil0, nColors)
-%
-%  When building a PSF, we need the pupil aperture function.  In the case 
-%  of a polychromatic PSF, the pupil aperture size (i.e., its diameter)
-%  depends on the wavelength.  This function gets the pupil diameters for
-%  the different wavelengths.
-%
-%  Input:  lambda0 = starting wavelength of observation in microns 
-%                    (wavelength of phvars)
-%                    For example, 0.750
-%          dlambda = optical bandwidth
-%                    For example, 0.3
-%          pupil0  = diameter of pupil at wavelength lambda0
-%                    For example, 192
-%          nColors = number of wavelengths.
-%                    For example, 13
-%
-%  Output:  pupild = vector of length nColors containing the pupil
-%                    diameters.
-%
-
-if dlambda>0
-    pupil_max = (1 + dlambda/(2*lambda0))*pupil0;
-    pupil_max = 2*round(pupil_max/2);
-
-    pupil_min = (1 - dlambda/(2*lambda0))*pupil0;
-    pupil_min = 2*round(pupil_min/2);
-
-    %pupild = pupil_min:2:pupil_max;
-    pupild = pupil_min:pupil_max;
-
-    idx0 = find(pupild == pupil0);
-
-    idx = round(linspace(1, length(pupild), nColors));
-    if ~any(idx(:) == idx0)
-      %  In this case, the pupil diameter spacing strange -- trying to fix
-      %  I'm not sure if this conditional statement is needede.  Might be
-      %  good to remove.
-    %  idx(round(length(idx)/2)) = idx0;
-    end
-    pupild = pupild(idx);
-else     
-    pupild = pupil0;
-end
-
-
-
diff --git a/Generator/library/p_ImgScale.m b/Generator/library/p_ImgScale.m
deleted file mode 100755
index 2c94e0d..0000000
--- a/Generator/library/p_ImgScale.m
+++ /dev/null
@@ -1,51 +0,0 @@
-function imOut = p_ImgScale(imIn, scale)
-% 
-%  This function scales an image about its central pixel using a sinc 
-%  interpolator.  
-%
-%  Input:
-%     imIn - input image
-%     scale - scale parameter
-%
-%  Note that the original version of this had a third optional input
-%  that gave an option for "size" of the output array.  But we were
-%  always using "same", so the other options were removed.
-%
-%  Also, let's assume the size of imIn is square, to simplify stuff.
-%    
-
-n = size(imIn,1);
-n2 = n/2;
-n2f = floor(n2);
-
-kvec = (1:n)';
-vone = ones(n,1);
-scalei = 1/scale;
-scalei2 = scalei*scalei;
-
-s = kvec - n2f;
-c = scalei*(kvec - n2);
-sincy = p_Sinc(pi*(c*vone' - vone*s'));
-sincx = p_Sinc(pi*(vone*c' - s*vone'));
-
-imOut = scalei2*sincy*imIn*sincx;
-
-return
-
-imOut = zeros(size(imIn));
-
-s1 = [1:size(imIn,1)]-floor(size(imIn,1)/2);
-s2 = [1:size(imIn,2)]-floor(size(imIn,2)/2);
-% Make the sinc interpolators
-sincy = zeros(size(imOut,1),size(imIn,1));
-sincx = zeros(size(imIn,2),size(imOut,2));
-for k = 1:size(imOut,1)
-   sincy(k,:) = p_Sinc(pi*((k-size(imOut,1)/2)/scale-s1));
-end
-for k = 1:size(imOut,2)
-   sincx(:,k) = p_Sinc(pi*((k-size(imOut,2)/2)/scale-s2));
-end
-
-% Do the interpolation, and normalize to keep data volume the same
-imOut = sincy*imIn*sincx/scale^2;
-
diff --git a/Generator/library/p_Sinc.m b/Generator/library/p_Sinc.m
deleted file mode 100755
index faaf2bb..0000000
--- a/Generator/library/p_Sinc.m
+++ /dev/null
@@ -1,11 +0,0 @@
-function y = p_Sinc(x)
-%
-% This simple function just evaluates 
-%
-%   y = sinc(x) = / sin(x)/x, if x ~= 0
-%                 \ 1,        if x == 0
-%
-% at an array of x-values.  
-%
-y = ones(size(x));
-y(x~=0) = sin(x(x~=0))./x(x~=0);
diff --git a/Generator/library/p_dora_color_psf.m b/Generator/library/p_dora_color_psf.m
deleted file mode 100644
index 1d94eaf..0000000
--- a/Generator/library/p_dora_color_psf.m
+++ /dev/null
@@ -1,37 +0,0 @@
-function psfs_poly  = p_dora_color_psf(phase, PSF_params)
-%
-%  This function constructs a polychromatic PSF, which is an average of
-%  monochromatic PSFs at a given set of wavelengths.  Each of the 
-%  monchformatic PSFs uses the standard Fourier optics model:
-%
-%        PSF(lambda) = ifft2(pupil*exp(i*phase))
-%
-%  05/29/2017 - The phase argument are the phases in a FFM
-
-color_planes = PSF_params.color_planes;
-wavelength   = PSF_params.wavelength;
-bandwidth    = PSF_params.bandwidth;
-PupilDiam    = PSF_params.PupilDiam;
-n_obj        = PSF_params.n_obj;
-pupil_poly   = PSF_params.pupil_amp;
-
-pupild = p_GetPupilDiams(wavelength, bandwidth, PupilDiam, color_planes);
-
-h = zeros(n_obj, n_obj, size(phase,3), length(pupild));
-for k = 1:length(pupild)
-  poly_scale = PupilDiam/pupild(k);
-  for j = 1:size(phase,3)
-    phi  = phase(:,:,j)./poly_scale;
-    P    = pupil_poly.*exp(sqrt(-1)*phi);
-    psf1 = ifftshift(abs(ifft2(P)).^2);
-    %
-    % The next function does an interpolation.  Since we always use
-    % 'same' in the original code, I've changed this to eliminate the
-    % input variable 'same'.
-    %
-    % psf1 = ImgScale(psf1, poly_scale, 'same');
-    psf1 = p_ImgScale(psf1, poly_scale);
-    h(:,:,j,k) = psf1;
-  end        
-end
-psfs_poly = squeeze(mean(h,3));
diff --git a/Generator/library/pad_arrayX.m b/Generator/library/pad_arrayX.m
deleted file mode 100755
index 09f7531..0000000
--- a/Generator/library/pad_arrayX.m
+++ /dev/null
@@ -1,13 +0,0 @@
-function [ out_arr ] = padarray(arr,v_dim,value,cwhat)
-
-% padarray(z_poly(:,:,q),[xdim xdim],0,'both');
-%
-% 11/4/14 - fixed to pad a cube instead of just a single frame 
-%
-out_arr=zeros(size(arr,1)+2*v_dim(1),size(arr,2)+2*v_dim(2),size(arr,3));
-out_arr(v_dim(1)+1:v_dim(1)+size(arr,1),v_dim(2)+1:v_dim(2)+size(arr,2),:)=arr;
-
-
-
-end
-
diff --git a/Generator/library/padarray2.m b/Generator/library/padarray2.m
deleted file mode 100755
index 09f7531..0000000
--- a/Generator/library/padarray2.m
+++ /dev/null
@@ -1,13 +0,0 @@
-function [ out_arr ] = padarray(arr,v_dim,value,cwhat)
-
-% padarray(z_poly(:,:,q),[xdim xdim],0,'both');
-%
-% 11/4/14 - fixed to pad a cube instead of just a single frame 
-%
-out_arr=zeros(size(arr,1)+2*v_dim(1),size(arr,2)+2*v_dim(2),size(arr,3));
-out_arr(v_dim(1)+1:v_dim(1)+size(arr,1),v_dim(2)+1:v_dim(2)+size(arr,2),:)=arr;
-
-
-
-end
-
diff --git a/Generator/library/phases_from_image_com.m b/Generator/library/phases_from_image_com.m
deleted file mode 100644
index 7c6ed7a..0000000
--- a/Generator/library/phases_from_image_com.m
+++ /dev/null
@@ -1,20 +0,0 @@
-function phases = phases_from_image_com( images )
-
-% phases = phases_from_image_com( images )
-%    
-mdim = size(images,1);
-icen = mdim/2 + 1;
-
-for k=1:size(images,3)
-    xx = image_com(images(:,:,k));
-    dr=xx(1);
-    dc=xx(2);
-
-    for r=1:mdim
-        for c=1:mdim
-            im(r,c,1) = -(2*pi*(dc*(c-icen))/mdim);
-            im(r,c,2) = -(2*pi*(dr*(r-icen))/mdim);  
-        end
-    end
-    phases(:,:,k) = im(:,:,1)+im(:,:,2);
-end
diff --git a/Generator/library/poissrndX.m b/Generator/library/poissrndX.m
deleted file mode 100644
index 9958a5b..0000000
--- a/Generator/library/poissrndX.m
+++ /dev/null
@@ -1,205 +0,0 @@
-function r = poissrndX(lambda,m,n,state,method)
-%POISSRND Random matrices from Poisson distribution.
-%	R = POISSRND(LAMBDA) returns a matrix of random numbers chosen   
-%	from the Poisson distribution with parameter LAMBDA.
-%
-%	The size of R is the size of LAMBDA. Alternatively, 
-%	R = POISSRND(LAMBDA,M,N) returns an M by N matrix. 
-%
-%	Use R = POISSRND(LAMBDA,M,N,STATE) to initialise the random
-%	number generator with STATE. Use R = POISSRND(LAMBDA,[],[],STATE)
-%	when M and N are not given and POISSRND([],[],[],STATE) when
-%	only the random number generator needs to be initialised.
-%	POISSRND([],[],[],0) resets the generator to its initial state.
-%	POISSRND([],[],[],J), for integer J, resets the generator to its J-th state.
-%	POISSRND([],[],[],sum(100*clock)) resets it to a different state each time.
-%	Note: POISSRND actually initialises RAND and RANDN.
-%
-%	Use R = POISSRND(LAMBDA,M,N,STATE,METHOD) to determine the method.
-%	METHOD='normal' (default) uses a waiting time method.
-%	METHOD='fast' uses a waiting time method at lambda<1000 and
-%			normal distribution with mean and variance equal to lambda
-%			at labda>=1000.
-%	METHOD=value equal to 'fast' but with the border set at value
-%  		instead of 1000.
-%	Use R = POISSRND(LAMBDA,[],[],[],METHOD) when M, N and STATE are
-%	not given.
-%
-%	For more information see the M-file.
-
-%  Addition 1 (12-3-1999):  
-%	This version of POISSRND has been improved in performance
-%	by Mischa Tolsma, MMR-TN TU Delft. It removes elements of
-%   which the result already has been found from the search matrix.
-%	It's major speedup occurs when lambda contains a lot of 
-%	small elements with just a few large ones.
-%	
-%	Speed up factors:
-%	0.1 % large elements: 10
-%	100 % large elements: 1.3 both at an array of 1000
-%
-%  Addition 2 (14-7-2000):
-%  This version of POISSRND allows the use of normal distribution as an
-%  approximation of the Poisson distribution at large values of lambda.
-%  The Poisson distribution resembles a normal distribution with mean
-%  lambda and variance lambda when lambda is large. But the standard 
-%  version of POISSRND needs a large amount of time for large values
-%  of lambda.
-%  Indication of speed up factor: 80 at lambda=10,000 and array of 100.
-
-%  Addition 3 (7-12-2000):
-%  The new version of POISSRND of release has been improved in speed
-%  and has become faster starting from lambda = 15. These improvements
-%  are therefore incorporated into this version.
-%  For large lambda (between 15 and 1000), use the method of Ahrens 
-%  and Dieter as described in Knuth, Volume 2, 1998 edition.
-%  note: this version calls the GAMRND and the BINORND functions.
-
-%	References:
-%	   [1]  L. Devroye, "Non-Uniform Random Variate Generation", 
-%	   Springer-Verlag, 1986 page 504.
-
-
-%   Based on poissrnd.
-%   M.F.P. Tolsma, Signals, Systems and Control Group, Applied Physics, TU Delft
-%   http://www.tn.tudelft.nl/mmr
-%   copyright remains with author
-
-%   $Revision: 1.2 $  $Date: 2000/12/07 11:45:00 $
-
-
-%------------------------------Input argument verification
-if nargin <  1, 
-    error('Requires at least one input argument.'); 
-end
-
-if nargin > 3
-    %random seed
-    if ~isempty(state)
-        rand('state',state)
-        randn('state',state)
-        if isempty(lambda)
-            return
-        end
-    end
-end
-
-[rows columns] = size(lambda);
-
-if nargin==2
-    if ~isempty(m)
-        if rows*columns>1
-            error('Lambda should be a scalar.');
-        else
-            rows=m;
-        end
-    end
-end
-
-if nargin>2
-    if ~isempty(n)
-        if rows*columns>1
-            error('Lambda should be a scalar.');
-        else
-            if ~isempty(m)
-                rows=m;
-            end
-            columns=n;
-        end
-    end
-end
-
-if prod(size(lambda))==1
-    lambda=lambda*ones(rows,columns);
-end
-
-if nargin==5
-    if ~isempty(findstr(method,'normal'))
-        method=0;
-    elseif ~isempty(findstr(method,'fast'))
-        method=1000;
-    elseif isempty(method)
-        method=0;
-    end
-else
-    method=0;
-end
-
-
-%Initialize r to zero.
-
-r = zeros(rows, columns);
-index = [1:rows]'*ones(1,columns)+rows*ones(rows,1)*[0:columns-1];
-
-% Return NaN if LAMBDA is not positive.
-if any(any(lambda <= 0));
-    if prod(size(lambda) == 1)
-        r = NaN * ones(rows,columns);
-        lambda=[];
-    else
-        k = find(lambda <= 0);
-        r(k) = NaN * ones(size(k));
-        
-        k = find(lambda > 0);
-        lambda=lambda(k);			 % Remove elements for which a result has been calculated.
-        index=index(k);
-    end
-end
-
-%values larger then 'method' are randomised using a discrete normal distribution.
-%This is approximatly equal to the poisson distribution.
-if method>0
-    k = find(lambda>=method);         % The lambda's larger than method
-    if ~isempty(k)
-        r(index(k))=round(lambda(k)+sqrt(lambda(k)).*randn(size(lambda(k))));
-        
-        k = find(lambda<method);		    % The lambda's smaller than method
-        lambda=lambda(k);			        % Remove elements for which a result has been calculated.
-        index=index(k);
-    end
-end
-
-%values larger (or equal to 15 are randomised using the method of Ahrens and Dieter
-k = find(lambda >= 15);
-if ~isempty(k)
-    alpha = 7/8;
-    lk=lambda(k);
-    m = floor(alpha * lk);
-    
-    % Generate m waiting times, all at once
-    x = gamrnd(m,1);
-    k2= find(x <= lk);
-    
-    if ~isempty(k2)
-        % If we did not overshoot, then the number of additional times
-        % has a Poisson distribution with a smaller mean.
-        r(index(k(k2))) = m(k2) + poissrndX(lk(k2)-x(k2));
-    end
-    
-    k2= find(x > lk);
-    if ~isempty(k2)
-        % If we did overshoot, then the times up to m-1 are uniformly
-        % distributed on the interval to x, so the count of times less
-        % than lambda has a binomial distribution.
-        r(index(k(k2))) = binornd(m(k2)-1, lk(k2)./x(k2));
-    end
-    
-    k = find(lambda<15);
-    lambda=lambda(k);
-    index=index(k);
-end
-
-kt=0;
-p=zeros(size(index));
-while ~isempty(index)
-    p = p - log(rand(size(p)));
-    k = find(p >= lambda);      % The r's larger than border
-    r(index(k))=kt;
-    
-    k = find(p < lambda); 		% The r's for which the border hasn't been reached.
-    lambda=lambda(k);			% Remove elements for which a result has been calculated.
-    p=p(k);
-    index=index(k);
-    
-    kt=kt+1;    
-end
diff --git a/Generator/library/pupil2otfmask.m b/Generator/library/pupil2otfmask.m
deleted file mode 100644
index 8b49d68..0000000
--- a/Generator/library/pupil2otfmask.m
+++ /dev/null
@@ -1,6 +0,0 @@
-function mask = pupil2otfmask( pa )
-
-a=ifft2(pa);h=abs(a).^2;H=abs(fft2(h)).^2;
-idx = H>1e-5;
-mask = zeros(size(pa));
-mask(idx)=1.0;
\ No newline at end of file
diff --git a/Generator/library/randraw/._license.txt b/Generator/library/randraw/._license.txt
deleted file mode 100644
index 281e2d9..0000000
Binary files a/Generator/library/randraw/._license.txt and /dev/null differ
diff --git a/Generator/library/randraw/._randraw.m b/Generator/library/randraw/._randraw.m
deleted file mode 100644
index 281e2d9..0000000
Binary files a/Generator/library/randraw/._randraw.m and /dev/null differ
diff --git a/Generator/library/randraw/license.txt b/Generator/library/randraw/license.txt
deleted file mode 100644
index ee2b52a..0000000
--- a/Generator/library/randraw/license.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-Copyright (c) 2005, Alex Bar-Guy
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the distribution
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
diff --git a/Generator/library/randraw/randraw.m b/Generator/library/randraw/randraw.m
deleted file mode 100644
index 4d0b79a..0000000
--- a/Generator/library/randraw/randraw.m
+++ /dev/null
@@ -1,4431 +0,0 @@
-function varargout = randraw(distribName, distribParams, varargin)
-%
-%   EFFICIENT RANDOM VARIATES GENERATOR
-% 
-% See alphabetical list of the supported distributions below (over 50 distributions)
-% 
-% 1)  randraw 
-%           presents general help.
-% 2)  randraw( distribName ) 
-%           presents help for the specific distribution defined 
-%           by usage string distribName (see table below).
-% 3)  Y = randraw( distribName, distribParams, sampleSize );
-%           returns array Y of size = sampleSize of random variates from distribName  
-%           distribution with parameters distribParams
-%
-%               ALPHABETICAL LIST OF THE SUPPORTED DISTRIBUTIONS:
-%  ____________________________________________________________________
-% |      DISTRIBUTION NAME                    |   USAGE STRING         |
-% |___________________________________________|________________________|
-% |        Alpha                              |    'alpha'             |
-% |        Anglit                             |    'anglit'            |
-% |        Antilognormal                      |    'lognorm'           |
-% |        Arcsin                             |    'arcsin'            |
-% |        Bernoulli                          |    'bern'              |
-% |        Bessel                             |    'bessel'            |
-% |        Beta                               |    'beta'              |
-% |        Binomial                           |    'binom'             |
-% |        Bradford                           |    'bradford'          |
-% |        Burr                               |    'burr'              |
-% |        Cauchy                             |    'cauchy'            |
-% |        Chi                                |    'chi'               |
-% |        Chi-Square (Non-Central)           |    'chisqnc'           |
-% |        Chi-Square (Central)               |    'chisq'             |
-% |        Cobb-Douglas                       |    'lognorm'           |
-% |        Cosine                             |    'cosine'            |
-% |        Double-Exponential                 |    'laplace'           |
-% |        Erlang                             |    'erlang'            |
-% |        Exponential                        |    'exp'               |
-% |        Extreme-Value                      |    'extrval'           |
-% |        F (Central)                        |    'f'                 |
-% |        F (Non-Central)                    |    'fnc'               |
-% |        Fisher-Tippett                     |    'extrval'           |
-% |        Fisk                               |    'fisk'              |
-% |        Frechet                            |    'frechet'           |
-% |        Furry                              |    'furry'             |
-% |        Gamma                              |    'gamma'             |
-% |        Generalized Inverse Gaussian       |    'gig'               |
-% |        Generalized Hyperbolic             |    'gh'                |
-% |        Geometric                          |    'geom'              |
-% |        Gompertz                           |    'gompertz'          |
-% |        Gumbel                             |    'gumbel'            |
-% |        Half-Cosine                        |    'hcos'              |
-% |        Hyperbolic Secant                  |    'hsec'              |
-% |        Hypergeometric                     |    'hypergeom'         |
-% |        Inverse Gaussian                   |    'ig'                |
-% |        Laplace                            |    'laplace'           |
-% |        Logistic                           |    'logistic'          |
-% |        Lognormal                          |    'lognorm'           |
-% |        Lomax                              |    'lomax'             |
-% |        Lorentz                            |    'lorentz'           |
-% |        Maxwell                            |    'maxwell'           |
-% |        Nakagami                           |    'nakagami'          |
-% |        Negative Binomial                  |    'negbinom'          |
-% |        Normal                             |    'norm'              |
-% |        Normal-Inverse-Gaussian (NIG)      |    'nig'               |
-% |        Pareto                             |    'pareto'            |
-% |        Pareto2                            |    'pareto2'           |
-% |        Pascal                             |    'pascal'            |
-% |        Planck                             |    'planck'            |
-% |        Poisson                            |    'po'                |
-% |        Quadratic                          |    'quadr'             |
-% |        Rademacher                         |    'rademacher'        |
-% |        Rayleigh                           |    'rayl'              |
-% |        Rice                               |    'rice'              |
-% |        Semicircle                         |    'semicirc'          |
-% |        Skellam                            |    'skellam'           |
-% |        Student's-t                        |    't'                 |
-% |        Triangular                         |    'tri'               |
-% |        Truncated Normal                   |    'normaltrunc'       |
-% |        Tukey-Lambda                       |    'tukeylambda'       |
-% |        U-shape                            |    'u'                 |
-% |        Uniform (continuous)               |    'uniform'           |
-% |        Von Mises                          |    'vonmises'          |
-% |        Wald                               |    'wald'              |
-% |        Weibull                            |    'weibull'           |
-% |        Wigner Semicircle                  |    'wigner'            |
-% |        Yule                               |    'yule'              |
-% |        Zeta                               |    'zeta'              |
-% |        Zipf                               |    'zipf'              |
-% |___________________________________________|________________________|
-
-%  Version 2.0 - August 2007
-%         1) New distributions support: Nakagami and Rician !
-%         2) Small typo corrections in comments
-%  Version 1.8 - February 2007
-%         GIG distribution (thanks to Mr. Demetris Lamnisos)
-%           Computational exceptions in the reparameterized GIG generation were fixed
-%  Version 1.7 - December 2006
-%         GIG distribution (thanks to Dr. Junbin Gao)
-%           Computational exceptions in the reparameterized GIG generation were fixed
-%  Version 1.6 - September 2006
-%         Exception handling: BINOMIAL distribution - special case for n*p~=0 
-%         Geometric distibution: additional note in help section 
-%  Version 1.5 - December 2005
-%        'true' and 'false' functions were replased by ones and zeros to support Matlab releases 
-%         below 6.5
-%  Version 1.4 - September 2005 -
-%      Bugs fix:
-%        1) GAMMA distribution (thanks to Earl Lawrence):
-%             special case for a<1
-%        2) GIG distribution (thanks to Panagiotis Braimakis):
-%            typo in help 
-%            code adjustment to overcome possible computational overflows
-%        3) CHI SQUARE distribution
-%            typo in help
-%  Version 1.3 - July 2005 -
-%      Bug fix:
-%         Typo in GIG distribution generation:
-%         should be 'out' instead of 'x' in lines 1852 and 1858 
-%  Version 1.2 - May 2005  -   
-%      Bugs fix: 
-%        1) Poisson distribution did not work for lambda < 21.4. Typo ( ti instead of t )
-%        2) GIG distribution:  support to chi=0 or psi=0 cases
-%        3) Beta distribution: column sampleSize 
-%        4) Cauchy distribution: typo in example
-%        5) Chi distribution:   typo in example
-%        6) Non-central F distribution:  number of input parameters
-%        7) INVERSE GAUSSIAN (IG) distribution: typo in example
-%
-%  Version 1.1 - April 2005 -  Bug fix:   Generation from binomial distribution using only 'binomial'
-%                                   usage string was changed to 'binom' ( 'binomial' works too ).
-%  Version 1.0 - March 2005 -  Initial version
-%  Alex Bar Guy  &  Alexander Podgaetsky
-%    alex.barguy@gmail.com
-
-% Copyright (c) 2005, Alex Bar-Guy
-% All rights reserved.
-%
-% Redistribution and use in source and binary forms, with or without
-% modification, are permitted provided that the following conditions are
-% met:
-%
-% * Redistributions of source code must retain the above copyright
-% notice, this list of conditions and the following disclaimer.
-% * Redistributions in binary form must reproduce the above copyright
-% notice, this list of conditions and the following disclaimer in
-% the documentation and/or other materials provided with the distribution
-%
-% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-%                       SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-%                       INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-% POSSIBILITY OF SUCH DAMAGE.
-
-% Any comments and suggestions please send to:
-%    alex.barguy@gmail.com
-
-% Reference links:
-%   1) http://mathworld.wolfram.com/topics/StatisticalDistributions.html
-%   2) http://en.wikipedia.org/wiki/Category:Probability_distributions
-%   3) http://www.brighton-webs.co.uk/index.asp
-%   4) http://www.jstatsoft.org/v11/i03/v11i03.pdf
-%   5) http://www.quantlet.com/mdstat/scripts/csa/html/node236.html
-
-funcName = mfilename;
-
-if nargin == 0
-     help(funcName);
-     return;
-elseif nargin == 1
-     runMode = 'distribHelp';
-elseif nargin == 2
-     runMode = 'genRun';
-     sampleSize = [1 1];
-else
-     runMode = 'genRun';
-     sampleSize = [varargin{1:end}];
-end
-
-distribNameInner = lower( distribName( ~isspace( distribName ) ) );
-
-if strcmp(runMode, 'distribHelp')
-     fid = fopen( [ funcName '.m' ], 'r' );
-     printHelpFlag = 0;
-     while 1
-          tline = fgetl( fid );
-          if ~ischar( tline )
-               fprintf( '\n Unknown distribution name ''%s''.\n', distribName );
-               break;
-          end
-          if ~isempty( strfind( tline, [ 'END ', distribNameInner,' HELP' ] ) )
-               printHelpFlag = 0;
-               break;
-          end
-          if printHelpFlag
-               startPosition = strfind( tline, ' % ' ) + 3;
-               printLine = tline( startPosition : end );
-               if ~strcmp( funcName, 'randraw' )
-                    indxs = strfind( printLine, 'randraw' );
-                    while ~isempty( indxs )
-                         headLine = printLine( 1:indxs(1)-1 );
-                         tailLine = printLine( indxs(1)+7:end );
-                         printLine = [ headLine, funcName, tailLine ];
-                         indxs = strfind( printLine, 'randraw' );
-                    end
-               end
-               pause(0.02);
-               fprintf( '\n%s', printLine );
-          end
-          if ~isempty( strfind( tline, [ 'START ', distribNameInner,' HELP' ] ) )
-               printHelpFlag = 1;
-          end
-     end
-     fprintf( '\n\n' );
-     fclose( fid );
-     if nargout > 0
-          varargout{1} = [];
-     end
-     return;
-end
-
-if length(sampleSize) == 1
-     sampleSize = [ sampleSize, 1 ];
-end
-
-if strcmp(runMode, 'genRun')
-     runExample = 0;
-     plotFlag = 0;
-
-     dbclear if warning;
-     out = [];
-     if prod(sampleSize) > 0
-          switch lower( distribNameInner )
-               case {'alpha'}
-                    % START alpha HELP
-                    % THE ALPHA DISTRIBUTION
-                    %
-                    % pdf(y) = b*normpdf(a-b./y) ./ (y.^2*normcdf(a)); y>0; a>0; b>0;
-                    % cdf(y) = normcdf(a-b./y)/normcdf(a); y>0; a>0; b>0;
-                    %   where normpdf(x) = 1/sqrt(2*pi) * exp(-1/2*x.^2); is the standard normal PDF
-                    %         normcdf(x) = 0.5*(1+erf(y/sqrt(2))); is the standard normal CDF
-                    %
-                    % PARAMETERS:
-                    %   a - shape parameter (a>0)
-                    %   b - shape parameter (b>0)
-                    %
-                    % SUPPORT:
-                    %   y,  y>0
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % USAGE:
-                    %   randraw('alpha', [], sampleSize) - generate sampleSize number
-                    %         of variates from Alpha distribution with shape parameters a and b;
-                    %   randraw('alpha') - help for Alpha distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('alpha', [1 2], [1 1e5]);
-                    %  2.   y = randraw('alpha', [2 3], 1, 1e5);
-                    %  3.   y = randraw('alpha', [10 50], 1e5 );
-                    %  4.   y = randraw('alpha', [20.5 30.5], [1e5 1] );
-                    %  5.   randraw('alpha');
-                    % END alpha HELP
-
-                    % References:
-                    % 1. doc erf
-
-                    checkParamsNum(funcName, 'Alpha', 'alpha', distribParams, [2]);
-                    a  = distribParams(1);
-                    b  = distribParams(2);
-                    validateParam(funcName, 'Alpha', 'alpha', '[a, b]', 'a', a, {'> 0'});
-                    validateParam(funcName, 'Alpha', 'alpha', '[a, b]', 'b', b, {'> 0'});
-
-                    out = b ./ ( a - norminv(normcdf(a)*rand(sampleSize)) );
-
-               case {'anglit'}
-                    % START anglit HELP
-                    % THE ANGLIT DISTRIBUTION
-                    %
-                    % Standard form of anglit distribution:
-                    %   pdf(y) = sin(2*y+pi/2);  -pi/4 <= y <= pi/4;
-                    %   cdf(y) = sin(y+pi/4).^2; -pi/4 <= y <= pi/4;
-                    %
-                    %   Mean = Median = Mode = 0;
-                    %   Variance = (pi/4)^2 - 0.5;
-                    %
-                    % General form of anglit distribution:
-                    %   pdf(y) = sin(pi/2*(y-t)/s+pi/2);  t-s <= y <= t+s; s>0
-                    %   cdf(y) = sin(pi/4*(y-t)/s+pi/4).^2;  t-s <= y <= t+s; s>0
-                    %
-                    %   Mean = Median = Mode = t;
-                    %   Variance = ???????;
-                    %
-                    % PARAMETERS:
-                    %   t - location
-                    %   s -scale; s>0
-                    %
-                    % SUPPORT:
-                    %   y,   -pi/4 <= y <= pi.4   - standard Anglit distribution
-                    %    or
-                    %   y,   t-s <= y <= t+s  - generalized Anglit distribution
-                    %
-                    % CLASS:
-                    %   Continuous distributions
-                    %
-                    % USAGE:
-                    %   randraw('anglit', [], sampleSize) - generate sampleSize number
-                    %         of variates from standard Anglit distribution;
-                    %   randraw('anglit', [t, s], sampleSize) - generate sampleSize number
-                    %         of variates from generalized Anglit distribution
-                    %         with location parameter 't' and scale parameter 's';
-                    %   randraw('anglit') - help for Anglit distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('anglit', [], [1 1e5]);
-                    %  2.   y = randraw('anglit', [], 1, 1e5);
-                    %  3.   y = randraw('anglit', [], 1e5 );
-                    %  4.   y = randraw('anglit', [10 3], [1e5 1] );
-                    %  5.   randraw('anglit');
-                    %
-                    % END anglit HELP
-
-                    checkParamsNum(funcName, 'Anglit', 'anglit', distribParams, [0, 2]);
-                    if numel(distribParams)==2
-                         t  = distribParams(1);
-                         s  = distribParams(2);
-                         validateParam(funcName, 'Anglit', 'anglit', '[t, s]', 's', s, {'> 0'});
-                    else
-                         t = 0;
-                         s = pi/4;
-                    end
-
-                    out = t + s * (4/pi*asin(sqrt(rand(sampleSize)))-1);
-
-               case {'arcsin'}
-                    % START arcsin HELP
-                    % THE ARC-SINE DISTRIBUTION
-                    %
-                    % pdf(y) = 1 ./ (pi*sqrt(y.*(1-y))); 0<y<1;
-                    % cdf(y) = 2*asin(sqrt(y))/pi; 0<y<1;
-                    %
-                    % Mean = 0.5;
-                    % Variance = 0.125;
-                    %
-                    % PARAMETERS:
-                    %  None
-                    %
-                    % SUPPORT:
-                    %  y,    0<y<1
-                    %
-                    % CLASS:
-                    %   Continuous symmetric distributions
-                    % NOTES:
-                    %  The arc-sine distribution is a special case of the beta distribution
-                    %  with both parameters equal to 1/2. The generalized arc-sine distribution
-                    %  is the special case of the beta distribution where the two parameters sum
-                    %  to 1 but are not necessarily equal to 1/2.
-                    %
-                    % USAGE:
-                    %   randraw('arcsin', [], sampleSize) - generate sampleSize number
-                    %         of variates from the Arc-sine distribution;
-                    %   randraw('arcsin') - help for the Arc-sine distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('arcsin', [], [1 1e5]);
-                    %  2.   y = randraw('arcsin', [], 1, 1e5);
-                    %  3.   y = randraw('arcsin', [], 1e5 );
-                    %  4.   randraw('arcsin');                    
-                    %  SEE ALSO:
-                    %    U distribution
-                    % END arcsin HELP
-
-                    checkParamsNum(funcName, 'Arcsin', 'arcsin', distribParams, 0);
-                    out = sin( rand(sampleSize)*pi/2 ).^2;
-
-               case {'bernoulli', 'bern'}
-                    % START bernoulli HELP START bern HELP
-                    % THE BERNOULLI DISTRIBUTION
-                    %
-                    % pdf(y) = p.^y .* (1-p).^(1-y);
-                    % cdf(y) = (y==0)*(1-p) + (y==1)*1;
-                    %
-                    % PARAMETERS:
-                    %    p is a probability of success; (0<p<1)
-                    %
-                    % SUPPORT:
-                    %     y = [0 1];
-                    %
-                    % CLASS:
-                    %   Discrete distributions
-                    %
-                    % USAGE:
-                    %   randraw('bern', p, sampleSize) - generate sampleSize number
-                    %         of variates from the Bernoulli distribution with probability of success p
-                    %   randraw('bern') - help for the Bernoulli distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('bern', 0.5, [1 1e5]);
-                    %  2.   y = randraw('bern', 0.1, 1, 1e5);
-                    %  3.   y = randraw('bern', 0.9, 1e5 );
-                    %  4.   randraw('bern');                     
-                    % END bernoulli HELP END bern HELP
-
-                    checkParamsNum(funcName, 'Bernoulli', 'bernoulli', distribParams, 1);
-                    validateParam(funcName, 'Bernoulli', 'bernoulli', 'p', 'p', distribParams(1), {'>=0','<=1'});
-
-                    out = double( rand(  sampleSize  ) < distribParams );
-
-               case {'beta', 'powerfunction', 'powerfunc'}
-                    % START beta HELP
-                    %  THE BETA DISTRIBUTION
-                    % 
-                    %  ( sometimes: Power Function distribution )
-                    %
-                    % Standard form of the Beta distribution:
-                    %  pdf(y) = y.^(a-1).*(1-y).^(b-1) / beta(a, b);
-                    %  cdf(y) = betainc(y,a,b), if (y>=0 & y<=1); 0, if x<0; 1, if x>1
-                    %
-                    %  Mean = a/(a+b);
-                    %  Variance = (a*b)/((a+b)^2*(a+b+1));
-                    %
-                    % General form of the Beta distribution:
-                    %  pdf(y) = (y-m).^(a-1).*(n-y).^(b-1) / (beta(a, b)*(n-m)^(a+b-1));
-                    %  cdf(y) = betainc((y-m)/(n-m),a,b), if (y>=m & y<=n); 0, if x<m; 1, if x>n
-                    %
-                    %  Mean = (n*a + m*b)/(a+b);
-                    %  Variance = (a*b)*(n-m)^2/((a+b)^2*(a+b+1));
-                    %
-                    % PARAMETERS:
-                    %   a>0 - shape parameter
-                    %   b>0 - shape parameter
-                    %   m - location
-                    %   n -scale (upper bound); n>=m
-                    %
-                    % SUPPORT:
-                    %   y,   0<=y<=1 - standard beta distribution
-                    %    or
-                    %   y,   m<=y<=n - generalized beta distribution
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % USAGE:
-                    %   randraw('beta', [a, b], sampleSize) - generate sampleSize number
-                    %         of variates from standard beta distribution with shape parameters
-                    %         'a' and 'b'
-                    %   randraw('beta', [m, n, a, b], sampleSize) - generate sampleSize number
-                    %         of variates from generalized beta distribution on the interval [m, n]
-                    %         with shape parameters 'a' and 'b';
-                    %   randraw('beta') - help for the Beta distribution;
-                    % EXAMPLES:
-                    %  1.   y = randraw('beta', [0.2 0.9], [1 1e5]);
-                    %  2.   y = randraw('beta', [0.6 3.2], 1, 1e5);
-                    %  3.   y = randraw('beta', [-10 20 3.1 6.2], 1e5 );
-                    %  4.   y = randraw('beta', [3 4 5.3 0.7], [1e5 1] );
-                    %  5.   randraw('beta');                    
-                    % END beta HELP
-
-                    % Refernce:
-                    %      Dagpunar, John.
-                    %      Principles of Random Variate Generation.
-                    %      Oxford University Press, 1988.
-                    %
-                    %  max_ab < 0.5            Joehnk's algorithm
-                    %  1 < min_ab              Cheng's algortihm BB
-                    %  min_ab <= 1 <= max_ab   Atkinson's switching algorithm
-                    %  0.5<= max_ab < 1        Atkinson's switching algorithm
-
-
-                    checkParamsNum(funcName, 'Beta', 'beta', distribParams, [2, 4]);
-
-                    if numel(distribParams) == 2
-                         a = distribParams(1);
-                         b = distribParams(2);
-                         m = 0;
-                         n = 1;
-                         validateParam(funcName, 'Beta', 'beta', '[a, b]', 'a', a, {'> 0'});
-                         validateParam(funcName, 'Beta', 'beta', '[a, b]', 'b', b, {'> 0'});
-                    else
-                         m = distribParams(1);
-                         n = distribParams(2);
-                         a = distribParams(3);
-                         b = distribParams(4);
-                         validateParam(funcName, 'Beta', 'beta', '[m, n, a, b]', 'n-m', n-m, {'>= 0'});
-                         validateParam(funcName, 'Beta', 'beta', '[m, n, a, b]', 'a', a, {'> 0'});
-                         validateParam(funcName, 'Beta', 'beta', '[m, n, a, b]', 'b', b, {'> 0'});
-
-                    end
-
-                    sampleSizeIn = sampleSize;
-                    sampleSize = [ 1, prod( sampleSizeIn ) ];
-                    
-                    max_ab = max( a, b );
-                    min_ab = min( a, b );
-                    if max_ab < 0.5
-                         %  Use log(u1^a) and log(u2^b), rather than a and b, to avoid
-                         %  underflow for very small a or b.
-
-                         loga = log(rand( sampleSize ))/a;
-                         logb = log(rand( sampleSize ))/b;
-                         logsum = (loga>logb).*(loga + log(1+ exp(logb-loga))) + ...
-                              (loga<=logb).*(logb + log(1+ exp(loga-logb)));
-                         out = exp(loga - logsum);
-
-                         indxs = find( logsum > 0);
-
-                         while ~isempty( indxs )
-                              indxsSize = size( indxs );
-                              loga = log(rand( indxsSize ))/a;
-                              logb = log(rand( indxsSize ))/b;
-                              logsum = (loga>logb).*(loga + log(1+ exp(logb-loga))) + ...
-                                   (loga<=logb).*(logb + log(1+ exp(loga-logb)));
-
-                              l = (logsum <= 0);
-                              out( indxs( l ) ) = exp(loga(l) - logsum(l));
-                              indxs = indxs( ~l );
-                         end
-
-                    elseif min_ab > 1
-                         % Algorithm BB
-
-                         sum_ab = a + b;
-                         lambda = sqrt((sum_ab-2)/(2*a*b-sum_ab));
-                         c = min_ab+1/lambda;
-
-                         u1 = rand( sampleSize );
-                         u2 = rand( sampleSize );
-                         v = lambda*log(u1./(1-u1));
-                         z = u1.*u1.*u2;
-                         clear('u1'); clear('u2');
-                         w = min_ab*exp(v);
-                         r = c*v-1.38629436112;
-                         clear('v');
-                         s = min_ab+r-w;
-                         if a == min_ab
-                              out = w./(max_ab+w);
-                         else
-                              out = max_ab./(max_ab+w);
-                         end
-
-                         t = log(z);
-                         indxs = find( (s+2.609438 < 5*z) & (r+sum_ab*log(sum_ab./(max_ab+w)) < t) );
-
-                         clear('v');
-                         clear('z');
-                         clear('w');
-                         clear('r');
-                         while ~isempty( indxs )
-                              indxsSize = size( indxs );
-
-                              u1 = rand( indxsSize );
-                              u2 = rand( indxsSize );
-                              v = lambda*log(u1./(1-u1));
-                              z = u1.*u1.*u2;
-                              clear('u1'); clear('u2');
-                              w = min_ab*exp(v);
-                              r = c*v-1.38629436112;
-                              clear('v');
-                              s = min_ab+r-w;
-                              t = log(z);
-
-                              l = (s+2.609438 >= 5*z) | (r+sum_ab*log(sum_ab./(max_ab+w)) >= t);
-                              if a == min_ab
-                                   out( indxs( l ) ) = w(l)./(max_ab+w(l));
-                              else
-                                   out( indxs( l ) ) = max_ab./(max_ab+w(l));
-                              end
-                              indxs = indxs( ~l );
-
-                         end
-
-                    elseif min_ab < 1 & max_ab > 1
-                         %  Atkinson's switching method
-
-                         t = (1-min_ab)/(1+max_ab - min_ab);
-                         r = max_ab*t/(max_ab*t + min_ab*(1-t)^max_ab);
-
-                         u1 = rand( sampleSize );
-                         w = zeros( sampleSize );
-                         l = u1 < r;
-                         w( l ) =  t*(u1( l )/r).^(1/min_ab);
-                         l = ~l;
-                         w( l ) =  1- (1-t)*((1-u1(l))/(1-r)).^(1/max_ab);
-                         if a == min_ab
-                              out = w;
-                         else
-                              out = 1 - w;
-                         end
-                         u2 = rand( sampleSize );
-
-                         indxs1 = find(u1 < r);
-                         indxs2 = find(u1 >= r);
-                         clear('u1');
-                         indxs = [ indxs1( log(u2(indxs1)) >= (max_ab-1)*log(1-w(indxs1)) ), ...
-                              indxs2( log(u2(indxs2)) >= (min_ab-1)*log(w(indxs2)/t) ) ];
-
-                         clear('u1');
-                         clear('u2');
-                         while ~isempty( indxs )
-                              indxsSize = size( indxs );
-                              u1 = rand( indxsSize );
-                              w  = zeros( indxsSize );
-                              l = u1 < r;
-                              w( l ) =  t*(u1( l )/r).^(1/min_ab);
-                              l = ~l;
-                              w( l ) =  1- (1-t)*((1-u1(l))/(1-r)).^(1/max_ab);
-
-                              u2 = rand( indxsSize );
-
-                              indxs1 = find(u1 < r);
-                              indxs2 = find(u1 >= r);
-                              clear('u1');
-                              l = logical( zeros( indxsSize ) );
-                              l( [ indxs1( log(u2(indxs1)) < (max_ab-1)*log(1-w(indxs1)) ), ...
-                                   indxs2( log(u2(indxs2)) < (min_ab-1)*log(w(indxs2)/t) ) ] ) = 1;
-
-                              clear('u1');
-                              clear('u2');
-                              if a == min_ab
-                                   out( indxs(l) ) = w(l);
-                              else
-                                   out( indxs(l) ) = 1 - w(l);
-                              end
-                              indxs = indxs( ~l );
-                         end
-
-                    else
-                         % Atkinson's Algorithm
-
-                         if min_ab == 1
-                              t = 0.5;
-                              r = 0.5;
-                         else
-                              t = 1/(1+sqrt(max_ab*(1-max_ab)/(min_ab*(1-min_ab))));
-                              r = max_ab*t / (max_ab*t + min_ab*(1-t));
-                         end
-
-                         u1 = rand( sampleSize );
-                         out = zeros( sampleSize );
-                         w  = zeros( sampleSize );
-                         l1 = u1 < r;
-                         w(l1) = t*(u1(l1)/r).^(1/min_ab);
-                         l2 = u1 >= r;
-                         w(l2) = 1 - (1-t)*((1-u1(l2))/(1-r)).^(1/max_ab);
-                         if a == min_ab
-                              out = w;
-                         else
-                              out = 1 - w;
-                         end
-
-                         u2 = rand( sampleSize );
-                         indxs1 = find(l1);
-                         indxs2 = find(l2);
-                         indxs = [ indxs1( log(u2(l1)) >= (max_ab -1)*log((1-w(l1))/(1-t)) ), ...
-                              indxs2( log(u2(l2)) >= (min_ab -1) * log(w(l2)/t) ) ];
-                         clear('u2');
-
-                         while ~isempty( indxs )
-                              indxsSize = size( indxs );
-                              u1 = rand( indxsSize );
-                              w  = zeros( indxsSize );
-
-                              l1 = u1 < r;
-                              w(l1) = t*(u1(l1)/r).^(1/min_ab);
-                              l2 = u1 >= r;
-                              w(l2) = 1 - (1-t)*((1-u1(l2))/(1-r)).^(1/max_ab);
-
-                              u2 = rand( indxsSize );
-
-                              indxs1 = find(l1);
-                              indxs2 = find(l2);
-                              clear('u1');
-                              l = logical( zeros( indxsSize ) );
-
-                              l( [ indxs1(log(u2(l1)) < (max_ab -1)*log((1-w(l1))/(1-t))), ...
-                                   indxs2(log(u2(l2))< (min_ab -1) * log(w(l2)/t)) ] ) = 1;
-
-                              if a == min_ab
-                                   out(indxs(l)) = w(l);
-                              else
-                                   out(indxs(l)) = 1 - w(l);
-                              end
-                              indxs = indxs( ~l );
-                         end
-
-                    end
-
-                    out = m + (n-m) * out;
-                    
-                    reshape( out, sampleSizeIn );
-                    
-               case {'bessel'}
-                    % START bessel HELP
-                    %  THE BESSEL DISTRIBUTION
-                    %
-                    %  Bessel distribution arises in the theory of stochastic processes.
-                    %  Bessel(nu,a) is a discrete distribution on the non-negative integers with
-                    %  parameters nu > -1 and a > 0.
-                    %
-                    % pdf(y) = (a/2).^(2*y+nu) ./ (besseli(nu,a).*factorial(y).*gamma(y+nu+1));
-                    %
-                    % PARAMETERS: 
-                    %   nu > -1, a > 0
-                    % SUPPORT:     
-                    %   y = 0, 1, 2, 3, ...
-                    % CLASS:
-                    %   Discrete distributions
-                    %
-                    % USAGE:
-                    %   randraw('bessel', [nu, a], sampleSize) - generate sampleSize number
-                    %         of variates from the Bessel distribution with parameters
-                    %         'nu' and 'a'
-                    %   randraw('bessel') - help for the Bessel distribution;
-                    % EXAMPLES:
-                    %  1.   y = randraw('bessel', [2 0.9], [1 1e5]);
-                    %  2.   y = randraw('bessel', [0.6 3.2], 1, 1e5);
-                    %  3.   y = randraw('bessel', [-0.2 8.1], 1e5 );
-                    %  4.   y = randraw('bessel', [4 5.3], [1e5 1] );
-                    %  5.   randraw('bessel');                      
-                    % END bessel HELP
-                    
-                    % Method:
-                    %
-                    % We implemented Condensed Table-Lookup method suggested in
-                    %    George Marsaglia, "Fast Generation Of Discrete Random Variables,"
-                    %    Journal of Statistical Software, July 2004, Volume 11, Issue 4
-                    %
-                    % Reference:
-                    % L. Devroye, "Simulating Bessel random variables,"
-                    %  Statistics and Probability Letters, vol. 57, pp. 249-257, 2002.
-                    %
-
-                    checkParamsNum(funcName, 'Bessel', 'bessel', distribParams, [2]);
-                    
-                    nu = distribParams(1);
-                    a = distribParams(2);
-                    
-                    validateParam(funcName, 'Bessel', 'bessel', '[nu, a]', 'nu', nu, {'> -1'});
-                    validateParam(funcName, 'Bessel', 'bessel', '[nu, a]', 'a', a, {'> 0'});
-                    
-                    % mu = 0.5*a*besseli(nu+1,a)/besseli(nu,a);
-                    % chi2 = mu + 0.25*a^2*besseli(nu+1,a)/besseli(nu,a)*...
-                    %     (besseli(nu+2,a)/besseli(nu+1,a)-besseli(nu+1,a)/besseli(nu,a));
-
-                    besseliNuA =  besseli(nu, a);
-
-                    proceed = 1;
-                    if ~isfinite( besseliNuA )
-                         warnStr{1} = [upper(funcName), ' - Bessel Variates Generation: '];
-                         warnStr{2} = ['besseli(', num2str(nu), ', ' num2str(a), ') returns Inf.'];
-                         warnStr{3} = ['Unable to proceed, return zeros ...'];
-                         warning('%s\n  %s\n  %s',warnStr{1},warnStr{2},warnStr{3});
-
-                         %warning([upper(funcName), ' - Bessel Variates Generation: besseli(', num2str(nu), ', ' num2str(a), ') returns Inf. Unable to proceed, return zeros ...']);
-                         out = zeros( sampleSize );
-                         proceed = 0;
-                    end
-                    if besseliNuA == 0
-                         warnStr{1} = [upper(funcName), ' - Bessel Variates Generation: '];
-                         warnStr{2} = ['besseli(', num2str(nu), ', ' num2str(a), ') returns 0.'];
-                         warnStr{3} = ['Unable to proceed, return zeros ...'];
-                         warning('%s\n  %s\n  %s',warnStr{1},warnStr{2},warnStr{3});
-                         %warning([upper(funcName), '- Bessel Variates Generation: besseli(', num2str(nu), ', ' num2str(a), ') returns 0. Unable to proceed, return zeros ...']);
-                         out = zeros( sampleSize );
-                         proceed = 0;
-                    end
-
-                    if proceed
-                         p0 = exp( nu*log(a/2) - gammaln(nu+1) ) / besseliNuA;
-                         if p0 >= 5e-10
-                              t = p0;
-
-                              aa = (a/2)^2;
-                              nu1 = nu+1;
-                              i = 1;
-                              while t*2147483648 > 1
-                                   t = t * aa/((i)*(i+nu));
-                                   i = i + 1;
-                              end
-                              sizeP = i-1;
-                              offset = 0;
-
-                              P = round( 2^30*p0*cumprod([1, aa./((1:sizeP-1).*((1:sizeP-1)+nu))] ) );
-
-                         else % if p0 >= 5e-10
-                              m = floor(0.5*(sqrt(a^2+nu^2)-nu));
-                              pm = exp( (2*m+nu)*log(a/2) - log(besseliNuA) - ...
-                                   gammaln(m+1) - gammaln(m+nu+1) );
-
-                              aa = (a/2)^2;
-                              t = pm;
-                              i = m + 1;
-                              while t * 2147483648 > 1
-                                   t = t * aa/((i)*(i+nu));
-                                   i = i + 1;
-                              end
-                              last = i-2;
-
-                              t = pm;
-                              j = -1;
-                              for i = m-1:-1:0
-                                   t = t * (i+1)*(i+1+nu)/aa;
-                                   if t*2147483648 < 1
-                                        j=i;
-                                        break;
-                                   end
-                              end
-
-                              offset = j+1;
-                              sizeP = last-offset+1;
-
-                              P = zeros(1, sizeP);
-                              P(m-offset+1:last-offset+1) = ...
-                                   round( 2^30*pm*cumprod([1, aa./(((m+1):last).*(((m+1):last)+nu))] ) );
-                              P(m-offset:-1:1) = ...
-                                   round( 2^30*pm*cumprod((m:-1:(offset+1)).*((m:-1:(offset+1))+nu)/aa) );
-
-                         end % if p0 >= 5e-10, else ...
-
-
-                         out = randFrom5Tbls( P, offset, sampleSize);
-                         
-                    end % if proceed
-
-               case {'binom', 'binomial'}
-                    % START binom HELP START binomial HELP
-                    % THE BINOMIAL DISTRIBUTION
-                    %
-                    % pdf(y) = nchoosek(n,y)*p^y*(1-p)^(n-y) = ...
-                    %          exp( gammaln(n+1) - gammaln(n-y+1) - gammaln(y+1) + ...
-                    %               y*log(p) + (n-y)*log(1-p) );  0<p<1, n>1
-                    %
-                    %  Mean = n*p;
-                    %  Variance = n*p*(1-p);
-                    %  Mode = floor( (n+1)*p );
-                    %
-                    % PARAMETERS:
-                    %   p  - probability of success in a single trial; (0<p<1)
-                    %   n  - total number of trials; (n= 1, 2, 3, 4, ...)
-                    %
-                    % SUPPORT:
-                    %   y - number of success,  y = 0, 1, 2, 3 ...
-                    %
-                    % CLASS:
-                    %   Discrete distributions
-                    %
-                    % NOTES:
-                    %   Constructive definition:
-                    %    We consider a random experiment with n independent trials; in each trial
-                    %    a certain random event A can occur (the urn model with replacement is
-                    %    a special case of such an experiment). Let
-                    %      p  = probability of A in a single trial;
-                    %      n  = total number of trials;
-                    %      y  = number of successes (= number of trials where A occurs).
-                    %   
-                    % USAGE:
-                    %   randraw('binom', [n, p], sampleSize) - generate sampleSize number
-                    %         of variates from the Binomial distribution with total number of trials
-                    %         'n' and probability of success in a single trial 'p'
-                    %   randraw('binom') - help for the Binomial distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('binom', [10 0.9], [1 1e5]);
-                    %  2.   y = randraw('binom', [100 0.15], 1, 1e5);
-                    %  3.   y = randraw('binom', [5 0.5], 1e5 );
-                    %  4.   y = randraw('binom', [1000 0.02], [1e5 1] );
-                    %  5.   randraw('binom');                          
-                    % END binom HELP END binomial HELP
-                    
-                    % Method:
-                    %
-                    % We implemented Condensed Table-Lookup method suggested in
-                    %    George Marsaglia, "Fast Generation Of Discrete Random Variables,"
-                    %    Journal of Statistical Software, July 2004, Volume 11, Issue 4
-                    
-                    checkParamsNum(funcName, 'Binomial', 'binomial', distribParams, [2]);
-                    
-                    n = distribParams(1);
-                    p = distribParams(2);
-                    
-                    validateParam(funcName, 'Binomial', 'binomial', '[n, p]', 'n', n, {'> 0','==integer'});
-                    validateParam(funcName, 'Binomial', 'binomial', '[n, p]', 'p', p, {'> 0','< 1'});
-                    
-                    if n*p > 1e3 & n > 1e3
-
-                         out = round( n*p + sqrt(n*p*(1-p))*randn( sampleSize ) );
-
-                    elseif p<1e-4 & n*p > 1 & n*p < 100
-
-                         out = feval(funcName,'poisson',n*p, sampleSize);
-
-                    else
-
-                         % if n large and p near 1, generate j=Binom(n,1-p), return n-j
-                         switchFlag = 0;
-                         if n>100 & p>0.99
-                              p = 1-p;
-                              switchFlag = 1;
-                         end
-
-                         mode = floor( (n+1)*p );
-                         q = 1 - p;
-                         h = p/q;
-
-                         pmode = exp( gammaln(n+1) - gammaln(n-mode+1) - gammaln(mode+1) + ...
-                              mode*log(p) + (n-mode)*log(1-p) );
-
-                         if( 1-pmode < 5e-10 )
-                              % "Fast Generation of Discrete Random Variables", p.3  citation:
-                              % "For ... discrete variates with an infinite number of probabilities, we select only
-                              % those for which, for a sample of size 2^31(10^9.33), the expected number of occurences exceeds
-                              % 0.5. The other probabilities are assumed zero. For those unusual situations where occurrences
-                              % with probability less than 5  10^?10 must be accounted for, special tail-handling procedures
-                              % should be used."
-                              out = mode*ones( sampleSize );
-                              
-                         else
-
-                              i = mode + 1;
-                              t = pmode;
-                              while t*2147483648 > 1
-                                   t = t * h*(n-i+1)/i;
-                                   i = i + 1;
-                              end
-                              last = i - 2;
-
-                              t = pmode;
-                              j = -1;
-                              for i=mode-1:-1:0
-                                   t = t * (i+1)/h/(n-i);
-                                   if t*2147483648 < 1
-                                        j=i;
-                                        break;
-                                   end
-                              end
-                              offset=j+1;
-                              sizeP = last-offset+1;
-
-                              P = zeros(1, sizeP);
-
-                              P(mode-offset+1:last-offset+1) = ...
-                                   round( 2^30*pmode*cumprod([1, h*(n-(mode+1:last)+1)./(mode+1:last)] ) );
-                              P(mode-offset:-1:1) = ...
-                                   round( 2^30*pmode*cumprod( (mode:-1:offset+1)./(h*(n-(mode-1:-1:offset)))) );
-
-                              out = randFrom5Tbls( P, offset, sampleSize);
-                         end
-                    end
-                    if switchFlag
-                         out = n - out;
-                    end
-
-               case {'bradford'}
-                    % START bradford HELP
-                    %  THE BRADFORD DISTRIBUTION 
-                    %
-                    %  pdf(y) = b ./ ( log(1+b)*(1+b*y) ); 0<y<1
-                    %  cdf(y) = log(1+b*x) ./ log(1+b);
-                    %
-                    %  Mean = (b - log(1+b)) / (b*log(1+b));
-                    %  Variance = (b*(log(1+b)-2) + 2*log(1+b)) / (2*b*(log(1+b))^2); 
-                    %
-                    % PARAMETERS:
-                    %    b>-1,b~=0  - shape parameter;
-                    %
-                    % SUPPORT:
-                    %    0<y<1
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % USAGE:
-                    %   randraw('bradford', [b], sampleSize) - generate sampleSize number
-                    %         of variates from the Bradford distribution with parameter b;
-                    %   randraw('bradford') - help for the Bradford distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('bradford', 1, [1 1e5]);
-                    %  2.   y = randraw('bradford', 2.2, 1, 1e5);
-                    %  3.   y = randraw('bradford', -0.4, 1e5 );
-                    %  4.   y = randraw('bradford', 10, [1e5 1] );
-                    %  5.   randraw('bradford');                        
-                    % END bradford HELP
-                    
-                    checkParamsNum(funcName, 'Bradford', 'bradford', distribParams, [1]);                    
-                    b = distribParams(1);                    
-                    validateParam(funcName, 'Bradford', 'bradford', 'b', 'b', b, {'> -1','~=0'});                    
-                    
-                    out = ((1+b).^rand( sampleSize ) - 1)/b;
-                    
-               case {'burr', 'fisk'}
-                    % START burr HELP START fisk HELP
-                    % THE BURR DISTRIBUTION
-                    %  pdf(y) = c*d * y.^(-c-1) .* (1+y.^-c).^(-d-1);    y>0
-                    %  cdf(y) = (1 + y.^-c).^(-d);
-                    %
-                    % Mean = gamma(1-1/c)*gamma(1/c+d)/gamma(d);
-                    % Variance = COEF / gamma(d)^2;
-                    %    where  COEF = gamma(d)*gamma(1-2/c)*gamma(2/c+d) - gamma(1-1/c)^2*gamma(1/c+d)^2;
-                    %
-                    % PARAMETERS:
-                    %   c - shape parameter (c>0)
-                    %   d - shape parameter (d>0)
-                    %
-                    % SUPPORT:
-                    %   y>0
-                    % 
-                    % NOTES:                    
-                    %  The Burr distribution with d = 1, is often called the Fisk or 
-                    %  LogLogistic distribution
-                    %  The Burr distribution is a generalization of the Fisk distribution
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % USAGE:
-                    %   randraw('burr', [c d], sampleSize) - generate sampleSize number
-                    %         of variates from the Burr distribution with shape parameters 
-                    %         'c' and 'd';
-                    %   randraw('burr') - help for the Burr distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('burr', [1 2], [1 1e5]);
-                    %  2.   y = randraw('burr', [2 3], 1, 1e5);
-                    %  3.   y = randraw('burr', [1.5 0.2], 1e5 );
-                    %  4.   y = randraw('burr', [2 2], [1e5 1] );
-                    %  5.   randraw('burr');                        
-                    % END burr HELP END fisk HELP
-                    
-                    
-                    checkParamsNum(funcName, 'Burr', 'burr', distribParams, [2]);
-                    c = distribParams(1);
-                    d = distribParams(2);
-                    validateParam(funcName, 'Burr', 'burr', '[c, d]', 'c', c, {'> 0'});
-                    validateParam(funcName, 'Burr', 'burr', '[c, d]', 'd', d, {'> 0'});
-
-                    out = ( rand(sampleSize).^(-1/d) - 1).^(-1/c);
-                    
-               case {'cauchy', 'lorentz', 'caushy'}
-                    % START cauchy HELP  START lorentz HELP  START caushy HELP
-                    % THE CAUCHY DISTRIBUTION
-                    % (sometimes: Lorentz or Breit-Wigner distribution) 
-                    %
-                    %  The standard form of the Caushy distribution:
-                    %     pdf = 1 / ( pi*(1+y.^2) );
-                    %     cdf = 0.5 + atan(y)/pi;
-                    %
-                    %  The general form of the Cauchy distribution:
-                    %     pdf = s ./ (pi*(s^2+(y-t).^2));  s>0;
-                    %     cdf = 0.5 + atan((y-t)/s)/pi;
-                    %
-                    % The Cauchy distribution does not have a finite mean or 
-                    % standard deviation. 
-                    % Like the normal distribution, it is symmetric about its median, 
-                    %  but with longer and flatter tails.
-                    %
-                    % PARAMETERS:
-                    %   s>0 - scale parameter;
-                    %   t - loacation;
-                    %
-                    % SUPPORT;
-                    %    -Inf < y < Inf
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % USAGE:
-                    %    randraw('caushy',[],sampleSize) - generation array of sampleSize
-                    %         of variates from standard Cauchy distribution;
-                    %    randraw('caushy',[t, s],sampleSize) - generation array of sampleSize
-                    %         of variates from general form of Cauchy distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('cauchy', [], [1 1e5]);
-                    %  2.   y = randraw('cauchy', [10 1], 1, 1e5);
-                    %  3.   y = randraw('cauchy', [-10 1.5], 1e5 );
-                    %  4.   y = randraw('cauchy', [5.1 10.3], [1e5 1] );
-                    %  5.   randraw('cauchy');                       
-                    % END cauchy HELP  END lorentz HELP END caushy HELP
-                    
-                    checkParamsNum(funcName, 'Cauchy', 'cauchy', distribParams, [0, 2]);
-                    
-                    if numel(distribParams)==2
-                         t = distribParams(1);
-                         s = distribParams(2);
-
-                         validateParam(funcName, 'Cauchy', 'cauchy', '[t, s]', 's', s, {'> 0'});
-                    else
-                         t = 0;
-                         s = 1;
-                    end
-
-                    out = t + s * tan(pi*( rand( sampleSize ) - 0.5));
-
-               case {'chi'}
-                    % START chi HELP
-                    % THE CHI DISTRIBUTION
-                    %
-                    % The standard form of the Chi distribution:
-                    %
-                    %   pdf(y) = exp(-y.^2/2).*y.^(nu-1) / (2^(nu/2-1)*gamma(nu/2)); nu>0; y>0
-                    %   cdf(y) = gammainc(y.^2/2,nu/2);
-                    %
-                    %   Mean = sqrt(2)*gamma((nu+1)/2)/gamma(nu/2);
-                    %   Variance = nu - 2*gamma((nu+1)/2)^2/gamma(nu/2)^2;
-                    %
-                    % The general form of the Chi distribution:
-                    %
-                    %   pdf(y) = exp(-((y-a)/b).^2/2).*((y-a)/b).^(nu-1) / (2^(nu/2-1)*b*gamma(nu/2)); nu>0; y>a; b>0
-                    %   cdf(y) = gammainc(((y-a)/b).^2/2,nu/2);                    
-                    %
-                    %   Mean = a + sqrt(2)*b*gamma((nu+1)/2)/gamma(nu/2);
-                    %   Variance = b^2 * (nu-2*gamma((nu+1)/2)^2/gamma(nu/2)^2);
-                    %
-                    % PARAMETERS:
-                    %   a - location
-                    %   b > 0 - scale
-                    %   nu > 0 - shape (also, degrees of freedom)                    
-                    %
-                    % SUPPORT:
-                    %   y,   y>0 - standard Chi distribution
-                    %    or
-                    %   y,   y>a - generalized Chi distribution
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % NOTES:
-                    %  The chi-distribution includes several distributions as special cases. 
-                    %  If nu is 1, the chi-distribution reduces to the half-normal distribution.
-                    %  If nu is 2, the chi-distribution is a Rayleigh distribution. 
-                    %  If nu is 3, the chi-distribution is a Maxwell-Boltzmann distribution. 
-                    %  A generalized Rayleigh distribution is a chi-distribution with a scale parameter equal to 1.
-                    %
-                    % USAGE:
-                    %   randraw('chi', nu, sampleSize) - generate sampleSize number
-                    %         of variates from the standrad Chi distribution with shape parameter 'nu';
-                    %   randraw('chi', [a, b, nu], sampleSize) - generate sampleSize number
-                    %         of variates from the generalized Chi distribution with location parameter
-                    %         'a', scale parameter 'b' and shape parameter 'nu';                    
-                    %   randraw('chi') - help for the Chi distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('chi', [2], [1 1e5]);
-                    %  2.   y = randraw('chi', [3, 1, 5], 1, 1e5);
-                    %  3.   y = randraw('chi', [-10 1, 1], 1e5 );
-                    %  4.   y = randraw('chi', [-2.1  3.5 4], [1e5 1] );
-                    %  5.   randraw('chi');                    
-                    % END chi HELP
-                    
-                    checkParamsNum(funcName, 'Chi', 'chi', distribParams, [1, 3]);
-                    if numel(distribParams)==3
-                         a  = distribParams(1);
-                         b  = distribParams(2);
-                         nu = distribParams(3);   
-                         validateParam(funcName, 'Chi', 'chi', '[a, b, nu]', 'b', b, {'> 0'});
-                         validateParam(funcName, 'Chi', 'chi', '[a, b, nu]', 'nu', nu, {'> 0'});
-                    else
-                         a = 0;
-                         b = 1;
-                         nu = distribParams(1);
-                         validateParam(funcName, 'Chi', 'chi', 'nu', 'nu', nu, {'> 0'});                         
-                    end                    
-
-                    out = a + b*sqrt( feval(funcName, 'chisq', [nu], sampleSize) );
-                    
-               case {'chisquare', 'chisq', 'chi2'}
-                    % START chisquare HELP START chisq HELP START chi2 HELP
-                    % THE CHI SQUARE DISTRIBUTION (with r degrees of freedom) 
-                    %
-                    %  pdf(y) = y.^(r/2-1) .* exp(-y/2) / (gamma(r/2)*2^(r/2)); r >=1 (integer); y>0
-                    %  cdf(y) = gammainc(y/2, r/2); r >=1 (integer); y>0;
-                    %
-                    %  Mean = r;
-                    %  Variance = 2*r;
-                    %  Skewness = 2*sqrt(2/r);
-                    %  Kurtosis = 12/r;
-                    %
-                    % PARAMETERS:  
-                    %   r - degrees of freedom ( r = 1, 2, 3, ...)
-                    %
-                    % SUPPORT:      
-                    %   y,   y>0
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % NOTES:
-                    %   1. Chi square distribution with r degrees of freedom is sum of r squared i.i.d Normal 
-                    %      distributions with zero mean and variance equal to 1;
-                    %   2. It is a special case of the gamma distribution where:
-                    %       the scale parameter is 2 and the shape parameter has the value r/2;
-                    %
-                    % USAGE:
-                    %   randraw('chisq', r, sampleSize) - generate sampleSize number
-                    %         of variates from CHI SQUARE distribution with r degrees of freedom;
-                    %   randraw('chisq') - help for CHI SQUARE  distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('chisq', [2], [1 1e5]);
-                    %  2.   y = randraw('chisq', [3], 1, 1e5);
-                    %  3.   y = randraw('chisq', [4], 1e5 );
-                    %  4.   y = randraw('chisq', [5], [1e5 1] );
-                    %  5.   randraw('chisq');
-                    %
-                    % SEE ALSO:
-                    %  GAMMA, NON-CENTRAL CHI SQUARE distributions
-                    % END chisquare HELP END chisq HELP END chi2 HELP
-                    
-                    
-                    checkParamsNum(funcName, 'Chi Square', 'chisq', distribParams, [1]);  
-                    r  = distribParams(1);
-                    validateParam(funcName, 'Chi Square', 'chisq', 'r', 'r', r, {'> 0','==integer'});
- 
-                    if r > 1
-                         out = 2*randraw('gamma', 0.5*r, sampleSize);
-                    else
-                         out = randn(sampleSize).^2;
-                    end
-
-               case {'chisqnc','chisqnoncentral', 'chisqnoncentr','chi2noncentral'}
-                    % START chisqnc HELP START chisqnoncentral HELP START chisqnoncentr HELP START chi2noncentral HELP 
-                    % THE NON-CENTRAL CHI-SQUARE DISTRIBUTION (with non-centrality parameter lambda and
-                    %                                          r degrees of freedom)
-                    %
-                    %  The non-central chi-square distribution with degrees of freedom r and 
-                    %  non-centrality parameter lambda is the sum of r independent normal
-                    %  distributions with standard deviation 1. 
-                    %  The non-centrality parameter is one half the sum of squares of the normal 
-                    %  means.
-                    %
-                    %
-                    %  pdf(y) = exp(-(y+lambda)/2).*y.^((r-1)/2)./(2*(lambda*y).^(r/4)) .* ...
-                    %            besseli(r/2-1, sqrt(lambda*y)); lambda>=0; r=positive integer;
-                    %
-                    %   Mean = lambda+r;
-                    %   Variance = 2*(2*lambda+r);
-                    %   Skewness = 2*sqrt(2)*(3*lambda+r)/(2*lambda+r)^(3/2);
-                    %   Kurtosis = 12*(4*lambda+r)/(2*lambda+r)^2;
-                    %
-                    % PARAMETERS:  
-                    %   lambda - non-centrality parameter:  lambda>=0
-                    %   r - degrees of freedom ( r = 1, 2, 3, ...)
-                    %
-                    % SUPPORT:      
-                    %   y,   y>0
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % USAGE:
-                    %   randraw('chisqnoncentral', [lambda, r], sampleSize) - generate sampleSize number
-                    %         of variates from the NON CENTRAL CHI SQUARE distribution with 
-                    %         non-centrality parameter 'lambda ' and 'r' degrees of freedom;
-                    %   randraw('chisqnoncentral') - help for the NON CENTRAL CHI-SQUARE  distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('chisqnoncentral', [10 2], [1 1e5]);
-                    %  2.   y = randraw('chisqnoncentral', [20 3], 1, 1e5);
-                    %  3.   y = randraw('chisqnoncentral', [30 4], 1e5 );
-                    %  4.   y = randraw('chisqnoncentral', [40 5], [1e5 1] );
-                    %  5.   randraw('chisqnoncentral');
-                    %
-                    % SEE ALSO:
-                    %  CHI SQUARE distribution                    
-                    % END chisqnc HELP START END chisqnoncentral HELP END chisqnoncentr HELP END chi2noncentral HELP                    
-                    
-                    checkParamsNum(funcName, 'Non-Central Chi-Square', 'chisqnoncentral', distribParams, [2]);  
-                    lambda = distribParams(1);
-                    r = distribParams(2);
-                    validateParam(funcName, 'Non-Central Chi-Square', 'chisqnoncentral', 'r', 'r', r, {'> 0','==integer'});
-                    
-                    normalS = sqrt(lambda) + randn( sampleSize );
-                    out = feval(funcName, 'chisq', r-1, sampleSize);
-                    out = out + normalS.^2;
-                    
-               case {'cosine'}
-                    % START cosine HELP
-                    % THE COSINE DISTRIBUTION
-                    %
-                    % Standard form of the Cosine distribution:
-                    %   pdf(y) = (1+cos(y))/(2*pi);  -pi <= y <= pi;
-                    %   cdf(y) = (pi+y+sin(y))/(2*pi); -pi <= y <= pi;
-                    %
-                    %   Mean = Median = Mode = 0;
-                    %   Variance = pi^2/3-2;
-                    %
-                    % General form of the Cosine distribution:
-                    %   pdf(y) = (1+cos(pi*(y-t)/s))/(2*s);  t-s <= y <= t+s; s>0
-                    %   cdf(y) = (pi + pi*(y-t)/s + sin(pi*(y-t)/s))/(2*pi); t-s <= y <= t+s; s>0
-                    %
-                    %   Mean = Median = Mode = t;
-                    %   Variance = (pi^2/3-2)*(s/pi)^2;
-                    %
-                    % PARAMETERS:  
-                    %   t - location
-                    %   s -scale; s>0
-                    %
-                    % SUPPORT:      
-                    %   y,   -pi <= y <= pi   - standard Cosine distribution
-                    %    or
-                    %   y,   t-s <= y <= t+s  - generalized Cosine distribution
-                    %
-                    % CLASS:
-                    %   Continuous distributions
-                    %
-                    % USAGE:
-                    %   randraw('cosine', [], sampleSize) - generate sampleSize number
-                    %         of variates from the standard Cosine distribution;
-                    %   randraw('cosine', [t, s], sampleSize) - generate sampleSize number
-                    %         of variates from the generalized Cosine distribution
-                    %         with location parameter 't' and scale parameter 's';
-                    %   randraw('cosine') - help for the Cosine distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('cosine', [], [1 1e5]);
-                    %  2.   y = randraw('cosine', [], 1, 1e5);
-                    %  3.   y = randraw('cosine', [], 1e5 );
-                    %  4.   y = randraw('cosine', [10 3], [1e5 1] );
-                    %  5.   randraw('cosine');
-                    % END cosine HELP
-                    
-                    checkParamsNum(funcName, 'Cosine', 'cosine', distribParams, [0, 2]);  
-                    if numel(distribParams)==2
-                         t  = distribParams(1);
-                         s  = distribParams(2);  
-                         validateParam(funcName, 'Cosine', 'cosine', '[t, s]', 's', s, {'> 0'});
-                    else
-                         t = 0;
-                         s = pi;                        
-                    end   
-
-                    tol = 1e-9;
-                    
-                    coeff1 = 1/(2*pi);
-                    coeff2 = 1/(2*s);
-                    coeff3 = pi/s;
-                    
-                    
-                    u = 0.5 - rand(sampleSize);
-                    out = -u*s;
-                    outNext = out - (coeff1*sin(coeff3*out) + coeff2*out + u) ./ ...
-                         (coeff2*cos(coeff3*out)+coeff2);
-
-                    indxs = find(abs(outNext - out)>tol);
-                    outPrev = out(indxs);
-                    while ~isempty(indxs)
-
-                         outNext = outPrev - (coeff1*sin(coeff3*outPrev) + coeff2*outPrev + u(indxs)) ./ ...
-                              (coeff2*cos(coeff3*outPrev)+coeff2);
-                         l = (abs(outNext - outPrev)>tol);
-                         out(indxs(~l)) = outNext(~l);
-                         outPrev = outNext(l);
-                         indxs = indxs(l);
-                    end
-                     
-                    out = t + out;
-                    
-               case {'erlang'}
-                    % START erlang HELP
-                    % THE ERLANG DISTRIBUTION
-                    %
-                    %  pdf = (y/a).^(n-1) .* exp( -y/a ) / (a*gamma(n));
-                    %  cdf = gammainc( n, y/sacle );
-                    %
-                    %   Mean = a*n;
-                    %   Variance = a^2*n;
-                    %   Skewness = 2/sqrt(n);
-                    %   Kurtosis = 6/n;
-                    %   Mode = (a<1)*0 + (a>=1)*a*(n-1);
-                    %
-                    %  PARAMETERS:
-                    %    a - scale parameter (a>0)
-                    %    n - shape parameter (n = 1, 2, 3, ...)
-                    %
-                    %  SUPPORT:
-                    %    y,  y >= 0
-                    %
-                    %  CLASS:
-                    %    Continuous skewed distributions
-                    %
-                    %  NOTES:
-                    %    The Erlang distribution is a special case of the gamma distribution where 
-                    %    the shape parameter is an integer
-                    %
-                    % USAGE:
-                    %   randraw('erlang', [a, n], sampleSize) - generate sampleSize number
-                    %         of variates from the Erlang distribution
-                    %         with scale parameter 'a' and shape parameter 'n';
-                    %   randraw('erlang') - help for the Erlang distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('erlang', [1, 3], [1 1e5]);
-                    %  2.   y = randraw('erlang', [0.5, 5], 1, 1e5);
-                    %  3.   y = randraw('erlang', [10, 6], 1e5 );
-                    %  4.   y = randraw('erlang', [7, 4], [1e5 1] );
-                    %  5.   randraw('erlang');     
-                    %
-                    % SEE ALSO:
-                    %   GAMMA distribution
-                    % END erlang HELP
-                    
-                    %
-                    % Inverse CDF transformation method.
-                    %
-                   
-                    checkParamsNum(funcName, 'Erlang', 'erlang', distribParams, [2]);
-                    a = distribParams(1);
-                    n = distribParams(2);                    
-                    validateParam(funcName, 'Erlang', 'erlang', '[a, n]', 'a', a, {'> 0'});
-                    validateParam(funcName, 'Erlang', 'erlang', '[a, n]', 'n', n, {'> 0', '==integer'});
-                    
-                    out = feval(funcName, 'gamma', n, sampleSize);
-                    out = a * out;
-                    
-               case {'exp','exponential'}
-                    % START exp HELP START exponential HELP
-                    % THE EXPONENTIAL DISTRIBUTION
-                    %
-                    % pdf = lambda * exp( -lambda*y );
-                    % cdf = 1 - exp(-lambda*y);
-                    %
-                    %  Mean = 1/lambda;
-                    %  Variance = 1/lambda^2;
-                    %  Mode = lambda;
-                    %  Median = log(2)/lambda;
-                    %  Skewness = 2;
-                    %  Kurtosis = 6;
-                    %
-                    % PARAMETERS:
-                    %   lambda - inverse scale or rate (lambda>0)
-                    %
-                    % SUPPORT:
-                    %   y,  y>= 0
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % NOTES:
-                    %  The discrete version of the Exponential distribution is 
-                    %  the Geometric distribution.
-                    %
-                    % USAGE:
-                    %   randraw('exp', lambda, sampleSize) - generate sampleSize number
-                    %         of variates from the Exponential distribution
-                    %         with parameter 'lambda';
-                    %   randraw('exp') - help for the Exponential distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('exp', 1, [1 1e5]);
-                    %  2.   y = randraw('exp', 1.5, 1, 1e5);
-                    %  3.   y = randraw('exp', 2, 1e5 );
-                    %  4.   y = randraw('exp', 3, [1e5 1] );
-                    %  5.   randraw('exp');
-                    %
-                    % SEE ALSO:
-                    %   GEOMETRIC, GAMMA, POISSON, WEIBULL distributions
-                    % END exp HELP END exponential HELP
-                    
-                    checkParamsNum(funcName, 'Exponential', 'exp', distribParams, [1]);  
-                    lambda  = distribParams(1);
-                    validateParam(funcName, 'Exponential', 'exp', 'lambda', 'lambda', lambda, {'> 0'});
-                    
-                    out = -log( rand( sampleSize ) ) / lambda;
-               
-               case {'extrval', 'extremevalue', 'extrvalue', 'gumbel'}
-                    % START extrval HELP START extremevalue HELP START extrvalue HELP START gumbel HELP
-                    % THE EXTREME VALUE DISTRIBUTION
-                    %   Also known as the Fisher-Tippett distribution or log-Weibull distribution or Gumbel
-                    %   distribution
-                    %
-                    %  pdf(y) = 1/b * exp((mu-y)/b - exp((mu-y)/b)); -Inf<y<Inf; b>0
-                    %  cdf(y) = exp(-exp((mu-y)/b)); -Inf<y<Inf; b>0
-                    %
-                    %   Mean = mu + b*g; where g=5.772156649015329e-001; is the Euler-Mascheroni constant
-                    %   Variance = pi^2*b^2/6;
-                    %   Skewness = 12*sqrt(6)*zeta3/pi^3; where zeta3=1.20205690315732e+000; is Apery's constant
-                    %   Kurtosis = 12/5;
-                    %
-                    % PARAMETERS:  
-                    %   mu - location (-Inf<mu<inf)
-                    %   b  - scale (b>0)
-                    %
-                    % SUPPORT:      
-                    %   y,   -Inf<y<Inf
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % NOTES:
-                    %
-                    % USAGE:
-                    %   randraw('extrvalue', [mu b], sampleSize) - generate sampleSize number
-                    %         of variates from Extreme-Value distribution with location parameter mu 
-                    %         and scale parameter b;
-                    %   randraw('extrvalue') - help for Extreme-Value distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('extrvalue', [0 1], [1 1e5]);
-                    %  2.   y = randraw('extrvalue', [10 2], 1, 1e5);
-                    %  3.   y = randraw('extrvalue', [15.5 4], 1e5 );
-                    %  4.   y = randraw('extrvalue', [100 100], [1e5 1] );
-                    %  5.   randraw('extrvalue');
-                    %
-                    % SEE ALSO:
-                    %   GUMBEL, WEIBULL distributions
-                    % END extrval HELP END extremevalue HELP END extrvalue HELP END gumbel HELP
-                                        
-                    checkParamsNum(funcName, 'Extreme Value', 'extrvalue', distribParams, [2]);  
-                    mu  = distribParams(1);
-                    b  = distribParams(2);
-                    validateParam(funcName, 'Extreme Value', 'extrvalue', '[mu, b]', 'b', b, {'> 0'});
-
-                    out = mu - b * log(-log( rand( sampleSize )));
-
-               case {'f','fdistribution', 'fdistrib', 'fdistr', 'fdist', 'fdis' }
-                    % START f HELP START fdistribution HELP START fdistrib HELP START fdistr HELP START fdist HELP START fdis HELP
-                    % THE F-DISTRIBUTION (also Central F-distribution)
-                    %
-                    %     In statistics and probability, the F-distribution is a continuous
-                    %   probability distribution. It is also known as Snedecor's F distribution or
-                    %   the Fisher-Snedecor distribution (after Ronald Fisher and George W. Snedecor).
-                    %     A random variate of the F-distribution arises as the ratio of two chi-squared
-                    %   variates: (U1/d1)/(U2/d2), where U1 and U2 have chi-square distributions with 
-                    %   d1 and d2 degrees of freedom respectively, and U1 and U2 are independent.
-                    %    The F-distribution arises frequently as the null distribution of a test statistic,
-                    %   especially in likelihood-ratio tests, perhaps most notably in the analysis of 
-                    %   variance;
-                    %
-                    %   pdf(y) = 1/beta(d1/2,d2/2) * (d1*y./(d1*y+d2)).^(d1/2) .* (1 - d1*y./(d1*y+d2)).^(d2/2) ./ y;
-                    %   cdf(y) = beatinc(d1*y./(d1*y+d2), d1/2, d2/2);
-                    %
-                    %   Mean = d2/(d2-2), provided d2 > 2;
-                    %   Variance = 2*d2^2*(d1+d2-2)/(d1*(d2-2)^2*(d2-4)), provided d2>4;
-                    %   Skewness = (2*d1+d2-2)*sqrt(8*(d2-4))/((d2-6)*sqrt(d1*(d1+d2-2))), provided d2>6;
-                    %   Mode = (d1-2)/d1 * d2/(d2+2), provided d1>2;
-                    %
-                    % PARAMETERS:  
-                    %   d1 - positive integer
-                    %   d2 - positive integer
-                    %
-                    % SUPPORT:      
-                    %   y,   y>0
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % USAGE:
-                    %   randraw('f', [d1 d2], sampleSize) - generate sampleSize number
-                    %         of variates from F-distribution with parameters d1 and d2;
-                    %   randraw('f') - help for F-distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('f', [2 3], [1 1e5]);
-                    %  2.   y = randraw('f', [2 3], 1, 1e5);
-                    %  3.   y = randraw('f', [2 3], 1e5 );
-                    %  4.   y = randraw('f', [2 3], [1e5 1] );
-                    %  5.   randraw('f');
-                    % END f HELP END fdistribution HELP END fdistrib HELP END fdistr HELP END fdist HELP END fdis HELP
-
-                    checkParamsNum(funcName, 'F', 'f', distribParams, [2]);                    
-                    d1 = distribParams(1);
-                    d2 = distribParams(2);                    
-                    validateParam(funcName, 'F', 'f', '[d1, d2]', 'd1', d1, {'> 0','==integer'});
-                    validateParam(funcName, 'F', 'f', '[d1, d2]', 'd2', d2, {'> 0','==integer'});
-                    
-                    out = feval(funcName, 'beta', [0.5*d1 0.5*d2], sampleSize);
-                    out = d2*out ./ (d1*(1-out));
-              
-               case {'fnc', 'fnoncentral', 'fnoncentr'}
-                    % START fnc HELP START fnoncentral HELP START fnoncentr HELP
-                    % THE NONCENTRAL F-DISTRIBUTION
-                    %
-                    %  The central F distribution is the ratio of 2 central chi-square distributions with 
-                    %  d1 and d2 degrees of freedom respectively. The noncentral F distribution is the ratio 
-                    %  of a non-central chi-square distribution with d1 degrees of freedom and non-centrality 
-                    %  parameter lambda and a central chi-square distribution with degrees of freedom parameter 
-                    %  d2. 
-                    %  The non-centrality parameter should be non-negative, and both degrees of freedom parameters 
-                    %  should be positive.
-                    %  
-                    %    Mean = (d1+lambda)*d2/(d1*(d2-2)), provided d2 > 2;
-                    %    Variance = ( ( d1+lambda )^2 + 2*( d1+lambda )*d2^2 )/( (d2-2)*(d2-4)*d1^2 ) - ...
-                    %              (d1+lambda)^2*d2^2/((d2-2)^2*d1^2);  provided d2 > 4;
-                    % 
-                    % PARAMETERS:  
-                    %   lambda - non-centrality parameter (lambda>=0);
-                    %   d1     - positive integer
-                    %   d2     - positive integer
-                    %
-                    % SUPPORT:      
-                    %   y,   y>0
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % USAGE:
-                    %   randraw('fnoncentral', [lambda d1 d2], sampleSize) - generate sampleSize number
-                    %         of variates from noncentral F-distribution with parameters lambda, d1 and d2;
-                    %   randraw('fnoncentral') - help for noncentral F-distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('fnoncentral', [1 2 5], [1 1e5]);
-                    %  2.   y = randraw('fnoncentral', [2 3 5], 1, 1e5);
-                    %  3.   y = randraw('fnoncentral', [6 6 6], 1e5 );
-                    %  4.   y = randraw('fnoncentral', [1.1 8 9], [1e5 1] );
-                    %  5.   randraw('fnoncentral');
-                    %
-                    % SEE ALSO:
-                    %  F distribution
-                    % END fnc HELP END fnoncentral HELP END fnoncentr HELP                    
-                    
-                    checkParamsNum(funcName, 'noncentral F', 'fnoncentral', distribParams, [3]);
-                    
-                    lambda = distribParams(1);
-                    d1 = distribParams(2);
-                    d2 = distribParams(3);
-                    
-                    validateParam(funcName, 'noncentral F', 'fnoncentral', '[lambda, d1, d2]', 'lambda', lambda, {'>=0'});                    
-                    validateParam(funcName, 'noncentral F', 'fnoncentral', '[lambda, d1, d2]', 'd1', d1, {'> 0','==integer'});
-                    validateParam(funcName, 'noncentral F', 'fnoncentral', '[lambda, d1, d2]', 'd2', d2, {'> 0','==integer'});
-                    
-                    chisq1 = feval(funcName, 'chisqnoncentral', [lambda, d1], sampleSize);
-                    out = feval(funcName, 'chisq', d2, sampleSize);
-                    out = (chisq1/d1) ./ (out/d2);
-                    
-               case {'gamma'}
-                    % START gamma HELP START gama HELP
-                    % THE GAMMA DISTRIBUTION
-                    %
-                    % The standard form of the GAMMA distribution:
-                    %
-                    %   pdf(y) = y^(a-1)*exp(-y)/gamma(a);  y>=0, a>0
-                    %   cdf(y) = gammainc(y, a);
-                    %
-                    %   Mean = a;
-                    %   Variance = a;
-                    %   Skewness = 2/sqrt(a);
-                    %   Kurtosis = 6/a;
-                    %   Mode = a-1;
-                    %
-                    % The general form of the GAMMA distribution:
-                    %
-                    %   pdf(y) = ((y-m)/b).^(a-1) .* exp(-(y-m)/b)/ (b*gamma(a));  y>=m; a>0; b>0
-                    %   cdf(y) = gammainc((y-m)/b, a);  y>=m; a>0; b>0
-                    %
-                    %   Mean = m + a*b;
-                    %   Variance = a*b^2;
-                    %   Skewness = 2/sqrt(a);
-                    %   Kurtosis = 6/a;
-                    %   Mode = m + b*(a-1);
-                    %
-                    % PARAMETERS:  
-                    %   m - location
-                    %   b - scale; b>0
-                    %   a - shape; a>0
-                    %
-                    % SUPPORT:      
-                    %   y,   y>=0   - standard GAMMA distribution
-                    %    or
-                    %   y,   y>=m   - generalized GAMMA distribution
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % NOTES:
-                    % 1. The GAMMA distribution approaches a NORMAL distribution as a goes to Inf                    
-                    % 5. GAMMA(m, b, a), where a is an integer, is the Erlang distribution.
-                    % 6. GAMMA(m, b, 1) is the Exponential distribution.
-                    % 7. GAMMA(0, 2, nu/2) is the Chi-square distribution with nu degrees of freedom.
-                    %
-                    % USAGE:
-                    %   randraw('gamma', a, sampleSize) - generate sampleSize number
-                    %         of variates from standard GAMMA distribution with shape parameter 'a'; 
-                    %   randraw('gamma', [m, b, a], sampleSize) - generate sampleSize number
-                    %         of variates from generalized GAMMA distribution
-                    %         with location parameter 'm', scale parameter 'b' and shape parameter 'a';
-                    %   randraw('gamma') - help for GAMMA distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('gamma', [2], [1 1e5]);
-                    %  2.   y = randraw('gamma', [0 10 2], 1, 1e5);
-                    %  3.   y = randraw('gamma', [3], 1e5 );
-                    %  4.   y = randraw('gamma', [1/3], 1e5 );
-                    %  5.   y = randraw('gamma', [1 3 2], [1e5 1] );
-                    %  6.   randraw('gamma');
-                    %
-                    % END gamma HELP END gama HELP
-                    
-                    % Method:
-                    %
-                    % Reference:
-                    % George Marsaglia and Wai Wan Tsang, "A Simple Method for Generating Gamma
-                    %   Variables": ACM Transactions on Mathematical Software, Vol. 26, No. 3,
-                    %   September 2000, Pages 363-372
-                    
-                    checkParamsNum(funcName, 'Gamma', 'gamma', distribParams, [1, 3]);
-                    if numel(distribParams)==3
-                         m  = distribParams(1);
-                         b  = distribParams(2);
-                         a  = distribParams(3);
-                         validateParam(funcName, 'Gamma', 'gamma', '[m, b, a]', 'a', a, {'> 0'});
-                         validateParam(funcName, 'Gamma', 'gamma', '[m, b, a]', 'b', b, {'> 0'});
-                    else
-                         m = 0;
-                         b = 1;
-                         a  = distribParams(1);
-                         validateParam(funcName, 'Gamma', 'gamma', '[m, b, a]', 'a', a, {'> 0'});                         
-                    end
-                    
-                    if a < 1
-                         % If a<1, one can use GAMMA(a)=GAMMA(1+a)*UNIFORM(0,1)^(1/a);
-                         out = m + b*(feval(funcName, 'gamma', 1+a, sampleSize)).*(rand(sampleSize).^(1/a));                         
-                         
-                    else
-                         
-                         d = a - 1/3;
-                         c = 1/sqrt(9*d);
-                         
-                         x = randn( sampleSize );
-                         v = 1+c*x;
-                         
-                         indxs = find(v <= 0);
-                         while ~isempty(indxs)
-                              indxsSize = size( indxs );
-                              xNew = randn( indxsSize );
-                              vNew = a+c*xNew;
-                              
-                              l = (vNew > 0);
-                              v( indxs( l ) ) = vNew(l);
-                              x( indxs( l ) ) = xNew(l);
-                              indxs = indxs( ~l );
-                         end
-                         
-                         u = rand( sampleSize );
-                         v = v.^3;
-                         x2 = x.^2;
-                         out = d*v;
-                         
-                         indxs = find( (u>=1-0.0331*x2.^2) & (log(u)>=0.5*x2+d*(1-v+log(v))) );
-                         while ~isempty(indxs)
-                              indxsSize = size( indxs );
-                              
-                              x = randn( indxsSize );
-                              v = 1+c*x;
-                              indxs1 = find(v <= 0);
-                              while ~isempty(indxs1)
-                                   indxsSize1 = size( indxs1 );
-                                   xNew = randn( indxsSize1 );
-                                   vNew = a+c*xNew;
-                                   
-                                   l1 = (vNew > 0);
-                                   v( indxs1(l1) ) = vNew(l1);
-                                   x( indxs1(l1) ) = xNew(l1);
-                                   indxs1 = indxs1( ~l1 );
-                              end
-                              
-                              u = rand( indxsSize );
-                              v = v .* v .* v;
-                              x2 = x.*x;
-                              
-                              l = (u<1-0.0331*x2.*x2) | (log(u)<0.5*x2+d*(1-v+log(v)));
-                              out( indxs( l ) ) = d*v(l);
-                              indxs = indxs( ~l );
-                         end % while ~isempty(indxs)
-                         
-                         out = m + b*out;
-                         
-                    end % if a < 1, else ...
-               
-               case {'geometric', 'geom', 'furry'}
-                    % START geometric HELP START geom HELP START furry HELP
-                    % THE GEOMETRIC DISTRIBUTION
-                    %
-                    % pdf(n) = p*(1-p)^(n-1);
-                    % 
-                    % Mean = 1/p;
-                    % Variance = (1-p)/p^2;
-                    % Mode = 1;
-                    %
-                    % PARAMETERS:
-                    %    p - probability of success (0<p<1)
-                    %
-                    % SUPPORT:
-                    %   n,  n = 1, 2, 3, 4, ...
-                    %
-                    % CLASS:
-                    %   Discrete distributions
-                    %
-                    % NOTES:
-                    %  1. The Geometric distribution is the discrete version of 
-                    %     the Exponential distribution.
-                    %  2. The Geometric distribution is sometimes called 
-                    %     the Furry distribution.
-                    %  3. In a series of Bernoulli trials, with Prob(success) = p, 
-                    %     the number of trials required to realize the first 
-                    %     success is ~Geometric(p).
-                    %  4. For the k'th success, see the Negative Binomial distribution.
-                    %  5. There is another definition of Geometric distribution:
-                    %       In a series of Bernoulli trials, with Prob(success) = p, 
-                    %       it defines probability that there are n failures before first success.
-                    %       Then: 
-                    %        Pdf(n) = p*(1-p)^n; n = 0, 1, 2, 3 ...
-                    %        Mean = q/p;
-                    %        Var = q/p^2                    
-                    %       The only difference between two definitions is shift by one.
-                    %       To generate a random variable according to this definition run:
-                    %         y=randraw('geom', p, sampleSize) - 1;
-                    %
-                    % USAGE:
-                    %   randraw('geom', p, sampleSize) - generate sampleSize number
-                    %         of variates from the Geometric distribution with 
-                    %         probability of success 'p'
-                    %   randraw('geom') - help for the Geometric distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('geom', 0.1, [1 1e5]);
-                    %  2.   y = randraw('geom', 0.22, 1, 1e5);
-                    %  3.   y = randraw('geom', 0.5, 1e5 );
-                    %  4.   y = randraw('geom', 0.99, [1e5 1] );
-                    %  5.   randraw('geom');                          
-                    % END geometric HELP END geom HELP END furry HELP
-                    
-                    checkParamsNum(funcName, 'Geometric', 'geom', distribParams, [1]);  
-                    p  = distribParams(1);
-                    validateParam(funcName, 'Geometric', 'geom', 'p', 'p', p, {'> 0'});
-                    validateParam(funcName, 'Geometric', 'geom', 'p', 'p', p, {'< 1'});
-                    
-                    out = ceil( log( rand( sampleSize ) ) / log( 1 - p ) );
-                    
-               case {'gig'}
-                    % START gig HELP
-                    % THE GENERALIZED INVERSE GAUSSIAN DISTRIBUTION
-                    %     GIG(lam, chi, psi)
-                    %
-                    % pdf = (psi/chi)^(lam/2)*y.^(lam-1)/(2*besselk(lam, sqrt(chi*psi))) .* exp(-1/2*(chi./y + psi*y));  y > 0 
-                    %
-                    % Mean = sqrt( chi / psi ) * besselk(lam+1,sqrt(chi*psi),1)/besselk(lam,sqrt(chi*psi),1);
-                    % Variance = chi/psi * besselk(lam+2,sqrt(chi*psi),1)/besselk(lam,sqrt(chi*psi),1) - Mean^2;
-                    %
-                    % PARAMETERS:
-                    %   chi>0,  psi>=0  if lam<0;
-                    %   chi>0,  psi>0   if lam=0;
-                    %   chi>=0, psi>0   if lam>0;
-                    %
-                    % SUPPORT:
-                    %   y,  y >= 0
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % NOTES:
-                    %    1) GIG(lam, chi, psi) = 1/c * GIG(lam, chi*c, psi/c), for all c>=0
-                    %    2) GIG(lam, chi, psi) = sqrt(chi/psi) * GIG(lam, sqrt(psi*chi), sqrt(psi*chi));
-                    %    3) GIG(lam, chi, psi) = 1 / GIG(-lam, psi, chi);
-                    %   
-                    %   Special cases of GIG distribution are the gamma distribution (chi=0), the
-                    %     reciprocal gamma distribution (psi=0), the inverse Gaussian distribution
-                    %     (lam = -1/2), and the inverse Gaussian or random walk distribution (lam=1/2).
-                    %
-                    % USAGE:
-                    %   randraw('gig', [lam, chi, psi], sampleSize) - generate sampleSize number
-                    %         of variates from the Generalized Inverse Gaussian distribution with 
-                    %         parameters 'lam', 'chi' and 'psi'
-                    %   randraw('gig') - help for the Generalized Inverse Gaussian distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('gig', [-1, 2, 0], [1 1e5]);
-                    %  2.   y = randraw('gig', [2, 3, 4], 1, 1e5);
-                    %  3.   y = randraw('gig', [0, 1.1, 2.2], 1e5 );
-                    %  4.   y = randraw('gig', [2.5, 3.5, 4.5], [1e5 1] );
-                    %  5.   y = randraw('gig', [0.5, 0.6, 0.7], [1e5 1] );
-                    %  6.   y = randraw('gig', [0, 1.3718, 1], [1e5 1]);
-                    %  7.   randraw('gig');                       
-                    % END gig HELP
-                    
-                    % Reference:
-                    %  1. Dagpunar, J.S., "Principles of random variate generation,"
-                    %        Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9
-                    %  2. Dagpunar, J.S., "An easily implemented generalized inverse Gaussian generator,"
-                    %        Commun. Statist. Simul. 18(2), 1989, pp 703-710.
-                    
-                    checkParamsNum(funcName, 'Generalized Inverse Gaussian', 'gig', distribParams, [3]);
-                    lam = distribParams(1);
-                    chi = distribParams(2);
-                    psi = distribParams(3);
-                    
-                    if lam < 0,
-                         validateParam(funcName, 'Generalized Inverse Gaussian', 'gig', '[lambda, chi, psi]', 'chi', chi, {'> 0'});
-                         validateParam(funcName, 'Generalized Inverse Gaussian', 'gig', '[lambda, chi, psi]', 'psi', psi, {'>=0'});
-                    elseif lam > 0,
-                         validateParam(funcName, 'Generalized Inverse Gaussian', 'gig', '[lambda, chi, psi]', 'chi', chi, {'>=0'});
-                         validateParam(funcName, 'Generalized Inverse Gaussian', 'gig', '[lambda, chi, psi]', 'psi', psi, {'> 0'});
-                    else % lam==0
-                         validateParam(funcName, 'Generalized Inverse Gaussian', 'gig', '[lambda, chi, psi]', 'chi', chi, {'> 0'});
-                         validateParam(funcName, 'Generalized Inverse Gaussian', 'gig', '[lambda, chi, psi]', 'psi', psi, {'> 0'});                         
-                    end
-                    
-                    if chi == 0,
-                         % Gamma distribution: Gamma(m=0, b=2/psi, lam)
-                         out = feval(funcName, 'gamma', [0, 2/psi, lam], sampleSize);
-                         varargout{1} = out;
-                         return;
-                    end
-                    
-                    if psi == 0,
-                         % Reciprocal Gamma distribution: Gamma(m=0, b=2/chi, -lam)
-                         out = feval(funcName, 'gamma', [0, 2/chi, -lam], sampleSize);
-                         varargout{1} = 1./out;
-                         return;
-                    end
-                    
-                    h = lam;
-                    b = sqrt( chi * psi );
-                          
-                    m = ( h-1+sqrt((h-1)^2+b^2) ) / b;  % Mode
-                    log_1_over_pm = -(h-1)/2*log(m) + b/4*(m + (1/m));
-
-                    r = (6*m + 2*h*m - b*m^2 + b)/(4*m^2);
-                    s = (1 + h - b*m)/(2*m^2);
-                    p = (3*s - r^2)/3;
-                    q = (2*r^3)/27 - (r*s)/27 + b/(-4*m^2);
-                    eta = sqrt(-(p^3)/27);
-                         
-                    y1  = 2*exp(log(eta)/3) * cos(acos(-q/(2*eta))/3) - r/3;
-                    y2  = 2*exp(log(eta)/3) * cos(acos(-q/(2*eta))/3 + 2/3*pi) - r/3;
-                         
-                    if (h<=1 & b<=1) | abs(q/eta)>2 | y1<0 | y2>0
-                         % without shifting by m                        
-                                                 
-                         ym = (-h-1 + sqrt((h+1)^2 + b^2))/b;
-                        
-                         % a = vplus/uplus
-                         a = exp(-0.5*h*log(m*ym) + 0.5*log(m/ym) + b/4*(m + 1/m - ym - 1.0/ym));
-
-                         u = rand( sampleSize );
-                         v = rand( sampleSize );
-                         out = a * (v./u);
-                         indxs = find( log(u) > (h-1)/2*log(out) - b/4*(out + 1./out) + log_1_over_pm );
-                         while ~isempty( indxs )
-                              indxsSize = size( indxs );
-                              u = rand( indxsSize );
-                              v = rand( indxsSize );
-                              outNew = a * (v./u);
-                              l = log(u) <= (h-1)/2*log(outNew) - b/4*(outNew + 1./outNew) + log_1_over_pm;
-                              out( indxs( l ) ) = outNew(l);
-                              indxs = indxs( ~l );
-                         end                      
-
-                    else % if h<=1 & b<=1
-                         % with shifting by m                         
-                         
-                         vplus = exp( log_1_over_pm + log(1/y1) + (h-1)/2*log(1/y1 + m) - ...
-                              b/4*(1/y1 + m + 1/(1/y1 + m)) );
-                         vminus = -exp( log_1_over_pm + log(-1/y2) + (h-1)/2*log(1/y2 + m) - ...
-                              b/4*(1/y2 + m + 1/(1/y2 + m)) );  
-                         
-                         u = rand( sampleSize );
-                         v = vminus + (vplus - vminus) * rand( sampleSize );
-                         z = v ./ u;
-                         clear('v');
-                         indxs = find( z < -m );
-                         
-                         while ~isempty(indxs),
-                              indxsSize = size( indxs );
-                              uNew = rand( indxsSize );
-                              vNew = vminus + (vplus - vminus) * rand( indxsSize );
-                              zNew = vNew ./ uNew;
-                              l = (zNew >= -m);
-                              z( indxs( l ) ) = zNew(l);
-                              u( indxs( l ) ) = uNew(l);
-                              indxs = indxs( ~l );
-                         end
-                         
-                         out = z + m;
-                         indxs = find( log(u) > (log_1_over_pm + (h-1)/2*log(out) - b/4*(out + 1./out)) );
-                         
-                         while ~isempty(indxs),
-                              indxsSize = size( indxs );                             
-                              u = rand( indxsSize );
-                              v = vminus + (vplus - vminus) * rand( indxsSize );
-                              z = v ./ u;
-                              clear('v');
-                              indxs1 = find( z < -m );
-                              while ~isempty(indxs1),
-                                   indxsSize1 = size( indxs1 );
-                                   uNew = rand( indxsSize1 );
-                                   vNew = vminus + (vplus - vminus) * rand( indxsSize1 );
-                                   zNew = vNew ./ uNew;
-                                   l = (zNew >= -m);
-                                   z( indxs1( l ) ) = zNew(l);
-                                   u( indxs1( l ) ) = uNew(l);
-                                   indxs1 = indxs1( ~l );
-                              end
-                              
-                              outNew = z + m;
-                              l = ( log(u) <= (log_1_over_pm + (h-1)/2*log(outNew) - b/4*(outNew + 1./outNew)) );
-                              out( indxs(l) ) = outNew( l );
-                              indxs = indxs( ~l );
-                              
-                         end
-                         
-                    end %% if h<=1 & b<=1, else ...
- 
-                    out = sqrt( chi / psi ) * out;
-                    
-               case {'gh'}
-                    % START gh HELP
-                    % THE GENERALIZED HYPERBOLIC DISTRIBUTION
-                    %   GH(lam, alpha, beta, mu, delta)
-                    %
-                    %  pdf =  (alpha^2-beta^2)^(lam/2) / (sqrt(2*pi) * alpha^(lam-1/2) * delta^lam * ... 
-                    %                   besselk(lam, delta*sqrt(alpha^2-beta^2) ) ) * ...
-                    %            (delta^2 + (y-mu).^2).^(1/2*(lam-1/2)) .* ...
-                    %             besselk( lam-1/2, alpha*sqrt(delta^2 + (y-mu).^2) ) .* ...
-                    %             exp( beta*(y-mu) );
-                    %
-                    %  Mean = mu + beta*delta^2/(delta*sqrt(alpha^2-beta^2)) * besselk(lam+1, delta*sqrt(alpha^2-beta^2) ) / ...
-                    %           besselk(lam, delta*sqrt(alpha^2-beta^2) );                    
-                    %  Variance = delta^2 * ( besselk(lam+1, zeta)/(zeta*besselk(lam, zeta)) + ...
-                    %               beta^2*delta^2/zeta^2 * (besselk(lam+2, zeta)/besselk(lam, zeta) - ...
-                    %               (besselk(lam+1, zeta)/besselk(lam, zeta))^2) );
-                    %       where zeta = delta*sqrt(alpha^2-beta^2);
-                    %
-                    % PARAMETERS:
-                    %     lam,  -Inf < lam < Inf;
-                    %     alpha - shape parameter (alpha>0) (steepness)
-                    %     beta -  0 <= abs(beta) < alpha  (skewness)
-                    %     mu - location parameter (-Inf < mu < Inf)
-                    %     delta - scale parameter (delta > 0)       
-                    %
-                    % SUPPORT:
-                    %   y,  -Inf < y < Inf;
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % USAGE:
-                    %   randraw('gh', [lam, alpha, beta, mu, delta], sampleSize) - generate sampleSize number
-                    %         of variates from the Generalized Hyperbolic distribution with 
-                    %         parameters [lam, alpha, beta, mu, delta]
-                    %   randraw('gh') - help for the Generalized Hyperbolic distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('gh', [3, 4, 3, 7.5, 1.5], [1 1e5]);
-                    %  2.   y = randraw('gh', [3, 4, 3, 8.5, 1.5], 1, 1e5);
-                    %  3.   y = randraw('gh', [3, 4, 3, 9.5, 1.5], 1e5 );
-                    %  4.   y = randraw('gh', [3, 4, 3, 12.5, 1.5], [1e5 1] );
-                    %  5.   randraw('gh');                      
-                    % END gh HELP                    
-                    
-                    checkParamsNum(funcName, 'GH', 'gh', distribParams, [5]);
-                      
-                    lam   = distribParams(1);
-                    alpha = distribParams(2);
-                    beta  = distribParams(3);
-                    mu    = distribParams(4);
-                    delta = distribParams(5);
-                    
-                                        
-                    validateParam(funcName, 'GH', 'gh', '[lam, alpha, beta, mu, delta]', 'alpha', alpha, {'> 0'});
-                    validateParam(funcName, 'GH', 'gh', '[lam, alpha, beta, mu, delta]', 'delta', delta, {'> 0'});
-                    validateParam(funcName, 'GH', 'gh', '[lam, alpha, beta, mu, delta]', 'alpha-abs(beta)', alpha-abs(beta), {'> 0'});
-                    
-                    ygig = feval(funcName, 'gig', [lam, delta^2, alpha^2-beta^2], sampleSize);
-                    
-                    out = mu + beta*ygig + sqrt(ygig).*randn( sampleSize );
-                    
-               case {'gompertz'}
-                    % START gompertz HELP
-                    % THE GOMPERTZ DISTRIBUTION
-                    %
-                    %  pdf(y) = b * c.^y * exp(-b*(c.^y-1)/log(c)); y>=0; b>0; c>1
-                    %  cdf(y) = 1 - exp(-b*(c.^y-1)/log(c)); y>=0; b>0; c>1
-                    %
-                    %  Mean = exp(b/log(c)) * (-1/log(c)) * (-expint(b/log(c)));
-                    %  Variance = 
-                    %
-                    % PARAMETERS:  
-                    %   b - shape parameter (b>0)
-                    %   c - shape parameter (c>1)
-                    %
-                    % SUPPORT:      
-                    %   y,   y>=0
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % NOTES:
-                    %   There are several forms given for the Gompertz distribution in the literature.
-                    %   In particular, one common form uses the parameter alpha where alpha=log(c).
-                    %   
-                    %   The Gompertz distribution is frequently used by actuaries as a distribution 
-                    %   of length of life.
-                    %
-                    % USAGE:
-                    %   randraw('gompertz', [b, c], sampleSize) - generate sampleSize number
-                    %         of variates from Gompertz distribution with shape parameters 'b' 
-                    %         and 'c';
-                    %   randraw('gompertz') - help for Gompertz distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('gompertz', [1 2], [1 1e5]);
-                    %  2.   y = randraw('gompertz', [2 3], 1, 1e5);
-                    %  3.   y = randraw('gompertz', [1.1 5], 1e5 );
-                    %  4.   y = randraw('gompertz', [2.3 4.8], [1e5 1] );
-                    %  5.   randraw('gompertz');                    
-                    % END gompertz HELP    
-                    
-                    % Method:
-                    %
-                    % Inverse CDF transformation method.
-                    %
-                    % Reference:
-                    %   
-                    %  Dennis Kunimura, "The Compertz Distribution - Estimation of Parameters,"
-                    %    Actuarial Research Clearing House, 1998, Vol.2
-                    checkParamsNum(funcName, 'Gompertz', 'gompertz', distribParams, [2]);  
-                    b  = distribParams(1);
-                    c  = distribParams(2);
-                    validateParam(funcName, 'Gompertz', 'gompertz', '[b, c]', 'b', b, {'> 0'});
-                    validateParam(funcName, 'Gompertz', 'gompertz', '[b, c]', 'c', c, {'> 1'});
-                    
-                    out = log( 1 - log(1-rand(sampleSize))*log(c)/b ) / log(c);                    
-
-               case {'halfcosine', 'hcosine', 'hcos'}
-                    % START halfcosine HELP
-                    % THE HALF-COSINE DISTRIBUTION
-                    %
-                    % Standard Half-cosine distribution:
-                    %   pdf(y) = 1/4 * cos( y/2 );  -pi <= y <= pi
-                    %   cdf(y) = 1/2 * ( 1 + sin( y/2 ) );   -pi <= y <= pi
-                    %
-                    %  Mean = 0;
-                    %  Variance = pi^2-8;
-                    %
-                    % General half-cosine distribution:
-                    %   pdf(y) = pi/(4*a) * cos( pi*(y-t)/(2*s) );  t-s <= y <= t+s
-                    %   cdf(y) = 1/2 * ( 1 + sin( pi*(y-t)/(2*s) ) );   t-s <= y <= t+s
-                    %
-                    %  Mean = t;
-                    %  Variance = (1-8/pi^2)*s^2;
-                    %
-                    % PARAMETERS:  
-                    %   t - location
-                    %   s -scale; s>0
-                    %
-                    % SUPPORT:      
-                    %   y,   -pi <= y <= pi   - standard Half-cosine distribution
-                    %    or
-                    %   y,   t-s <= y <= t+s  - generalized Half-cosine distribution
-                    %
-                    % CLASS:
-                    %   Continuous distributions
-                    %
-                    % USAGE:
-                    %   randraw('halfcosine', [], sampleSize) - generate sampleSize number
-                    %         of variates from standard  Half-cosine distribution;
-                    %   randraw('halfcosine', [t, s], sampleSize) - generate sampleSize number
-                    %         of variates from generalized  Half-cosine distribution
-                    %         with location parameter 't' and scale parameter 's';
-                    %   randraw('halfcosine') - help for Half-cosine distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('halfcosine', [], [1 1e5]);
-                    %  2.   y = randraw('halfcosine', [], 1, 1e5);
-                    %  3.   y = randraw('halfcosine', [], 1e5 );
-                    %  4.   y = randraw('halfcosine', [10 3], [1e5 1] );
-                    %  5.   randraw('halfcosine');
-                    %
-                    % END halfcosine HELP
-                    
-                    checkParamsNum(funcName, 'Half-Cosine', 'halfcosine', distribParams, [0, 2]);  
-                    if numel(distribParams)==2
-                         t  = distribParams(1);
-                         s  = distribParams(2);  
-                         validateParam(funcName, 'Half-Cosine', 'halfcosine', '[t, s]', 's', s, {'> 0'});
-                    else
-                         t = 0;
-                         s = pi;                        
-                    end                       
-                    
-                    out = t + s*2/pi*asin(2*rand(sampleSize)-1);
-                    
-               case {'hyperbolicsecant', 'hsecant', 'hsec'}
-                    % START hsecant HELP START hsec HELP START hyperbolicsecant HELP
-                    % THE HYPERBOLIC SECANT DISTRIBUTION
-                    %
-                    %  Standard form of the Hyperbolic Secant distribution
-                    %    pdf(y) = sech(y)/pi;
-                    %    cdf(y) = 2*atan(exp(y))/pi; 
-                    %
-                    %    Mean = Median = Mode = 0;
-                    %    Variance = pi^2/4;
-                    %    Skewness = 0;
-                    %    Kurtosis = 2;
-                    %
-                    %  General form of the Hyperbolic Secant distribution
-                    %    pdf(y) = sech((y-a)/b)/(b*pi);
-                    %    cdf(y) = 2*atan(exp((y-a)/b))/pi;                    
-                    %
-                    %    Mean = Median = Mode = a;
-                    %    Variance = (pi*b)^2/4;
-                    %    Skewness = 0;
-                    %    Kurtosis = 2;
-                    %
-                    % PARAMETERS:  
-                    %    a - location;
-                    %    b - scale; (b>0)
-                    %                      
-                    % SUPPORT:      
-                    %   y,   -Inf < y < Inf 
-                    %
-                    % CLASS:
-                    %   Continuous symmetric distributions
-                    %
-                    % NOTES:
-                    %  1. The Hyperbolic Secant is related to the Logistic distribution.
-                    %  2. If Z ~Hyperbolic Secant, then W = exp(Z) ~Half Cauchy.
-                    %  3. The Hyperbolic Secant distribution is used in lifetime analysis.
-                    %
-                    % USAGE:
-                    %   randraw('hsecant', [], sampleSize) - generate sampleSize number
-                    %         of variates from standard Hyperbolic Secant distribution;                    
-                    %   randraw('hsecant', [a, b], sampleSize) - generate sampleSize number
-                    %         of variates from generalized Hyperbolic Secant distribution
-                    %         with location parameter 'a' and scale parameter 'b';
-                    %   randraw('hsecant') - help for Hyperbolic Secant distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('hsecant', [], [1 1e5]);
-                    %  2.   y = randraw('hsecant', [-1 4], 1, 1e5);
-                    %  3.   y = randraw('hsecant', [], 1e5 );
-                    %  4.   y = randraw('hsecant', [10.1 3.2], [1e5 1] );
-                    %  5.   randraw('hsecant');                    
-                    % END hsecant HELP END hsec HELP END hyperbolicsecant HELP
-                    
-                    checkParamsNum(funcName, 'Hyperbolic Secant', 'hsecant', distribParams, [0, 2]);  
-                    if numel(distribParams)==2
-                         a  = distribParams(1);
-                         b  = distribParams(2);  
-                         validateParam(funcName, 'Hyperbolic Secant', 'hsecant', '[a, b]', 'b', b, {'> 0'});
-                    else
-                         a = 0;
-                         b = 1;                        
-                    end   
-                    
-                    out = a + b* log(tan(pi/2*rand(sampleSize)));
-                    
-               case {'hypergeom', 'hypergeometric'}
-                    % START hypergeom HELP START hypergeometric HELP
-                    % THE HYPERGEOMETRIC DISTRIBUTION
-                    % If Y is the number of SUCCESSES in a completely random sample of size n drawn from
-                    % a population consisting of M SUCCESSES and (N-M) FAILURES, then Y distributed according
-                    %  to Hypergeometric distribution
-                    %
-                    % pdf(y) = nchoosek(M,y)*nchoosek(N-M,n-y) / nchoosek(N,n) = ...
-                    %          exp( gammaln(M+1) - gammaln(M-y+1) - gammaln(y+1) + ...
-                    %               gammaln(N-M+1) - gammaln(N-M-n+y+1) - gammaln(n-y+1) + ...
-                    %               gammaln(n+1) + gammaln(N-n+1) - gammaln(N+1) );
-                    %
-                    %    max(0, n-N+M) <= y <= min(n,M)
-                    %
-                    % Mean = n*(M/N);
-                    % Variance = (N-n)/(N-1)*n*M/N*(1-M/N);
-                    % Mode = floor( (M+1)*(n+1)/(N+2) );
-                    %
-                    % PARAMETERS:
-                    %   N,   N = 2, 3, 4, ...
-                    %   M,   0 < M < N
-                    %   n,   0 < n < N
-                    %
-                    % SUPPORT:
-                    %   y,  y is integer and  max(0, n-N+M) <= y <= min(n,M), 
-                    %
-                    % CLASS:
-                    %   Discrete distributions                    
-                    %
-                    % NOTES:
-                    %  1. In the urn model: 
-                    %     From an urn with white and black balls a random sample is drawn without
-                    %     replacement, then
-                    %     N = total number of balls in the urn;
-                    %     M = number of white balls in the urn;
-                    %     n = sample size (number of balls drawn without replacement);
-                    %     Y = number of white balls in the sample.
-                    %
-                    %  2. When the population size is large (i.e. N is large) the hypergeometric 
-                    %     distribution can be approximated reasonably well with a binomial 
-                    %     distribution with parameters n (number of trials) and p = M / N 
-                    %     (probability of success in a single trial).
-                    %
-                    % USAGE:
-                    %   randraw('hypergeom', [N, M, n], sampleSize) - generate sampleSize number
-                    %         of variates from the  Hypergeometric distribution
-                    %         with parameters N, M and n;
-                    %   randraw('hypergeom') - help for the  Hypergeometric distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('hypergeom', [20 13 17], [1 1e5]);
-                    %  2.   y = randraw('hypergeom', [30 22 14], 1, 1e5);
-                    %  3.   y = randraw('hypergeom', [50 3  22], 1e5 );
-                    %  4.   y = randraw('hypergeom', [33 32 10], [1e5 1] );
-                    %  5.   randraw('hypergeom');      
-                    % 
-                    % SEE ALSO:
-                    %  BINOMIAL distribution
-                    % END hypergeom HELP END hypergeometric HELP
-
-                    checkParamsNum(funcName, 'Hypergeometric', 'hypergeom', distribParams, [3]);
-                    N = distribParams(1);
-                    M = distribParams(2);
-                    n = distribParams(3);
-                    validateParam(funcName, 'Hypergeometric', 'hypergeom', '[N, M, n]', 'N', N, {'> 1', '==integer'});
-                    validateParam(funcName, 'Hypergeometric', 'hypergeom', '[N, M, n]', 'M', M, {'> 0', '==integer'});
-                    validateParam(funcName, 'Hypergeometric', 'hypergeom', '[N, M, n]', 'n', n, {'> 0', '==integer'});
-                    validateParam(funcName, 'Hypergeometric', 'hypergeom', '[N, M, n]', 'N-M', N-M, {'> 0'});
-                    validateParam(funcName, 'Hypergeometric', 'hypergeom', '[N, M, n]', 'N-n', N-n, {'> 0'});
-                                        
-                    mode = floor( (M+1)/(N+2)*(n+1) );
-                    if ~isfinite(mode)
-                         warning('Numeric Overflow !');
-                         varargout{1} = [];
-                         return;
-                    end
-                    pmode = exp( gammaln(M+1) - gammaln(M-mode+1) - gammaln(mode+1) + ...
-                         gammaln(N-M+1) - gammaln(N-M-n+mode+1) - gammaln(n-mode+1) + ...
-                         gammaln(n+1) + gammaln(N-n+1) - gammaln(N+1) );
-
-                    if pmode < 5e-10
-                         varargout{1} = repmat(mode, sampleSize);
-                         return;                         
-                    end
-                    
-                    if ~isfinite(pmode)
-                         varargout{1} = feval(funcName, 'binomial', [n M/N], sampleSize);
-                    end
-                    if pmode==1,
-                         varargout{1} = repmat(mode, sampleSize);
-                         return;
-                    end
-                    % nchoosek(M,y)*nchoosek(N-M,n-y) / nchoosek(N,n)
-                    t=pmode;
-                    ii = mode+1;
-                    while t*2147483648 > 1
-                         t = t * (M-ii+1)/(ii) *(n-ii+1)/(N-M-n+ii);
-                         ii = ii + 1;
-                    end 
-                    last=ii-2;
-                                   
-                    t=pmode;
-                    j=-1;
-                    for ii=mode-1:-1:0 
-                         t = t * (ii+1)/(M-ii) *(N-M-n+ii+1)/(n-ii);
-                         if t*2147483648 < 1
-                              j=ii;
-                              break;
-                         end
-                    end                    
-                    offset=j+1;
-                    sizeP=last-offset+1;
-
-                    P = zeros(1, sizeP);
-
-                    ii = (mode+1):last;
-                    P(mode-offset+1:last-offset+1) = round( 2^30*pmode*cumprod([1, (M-ii+1)./(ii).*(n-ii+1)./(N-M-n+ii)] ) );
-                    
-                    ii = (mode-1):-1:offset;
-                    P(mode-offset:-1:1) = round( 2^30*pmode*cumprod((ii+1)./(M-ii).*(N-M-n+ii+1)./(n-ii)) );
-                             
-                    out = randFrom5Tbls( P, offset, sampleSize);
-                       
-                                   
-               case {'ig', 'inversegauss', 'invgauss'}                   
-                    %
-                    % START ig HELP START inversegauss HELP  START invgauss HELP
-                    % THE INVERSE GAUSSIAN DISTRIBUTION
-                    %
-                    % The Inverse Gaussian distribution is left skewed distribution whose
-                    % location is set by the mean with the profile determined by the
-                    % scale factor.  The random variable can take a value between zero and
-                    % infinity.  The skewness increases rapidly with decreasing values of
-                    % the scale parameter.
-                    %
-                    %
-                    % pdf(y) = sqrt(chi/(2*pi*y^3)) * exp(-chi./(2*y).*(y/theta-1).^2);
-                    % cdf(y) = normcdf(sqrt(chi./y).*(y/theta-1)) + ...
-                    %            exp(2*chi/theta)*normcdf(sqrt(chi./y).*(-y/theta-1));
-                    %
-                    %   where  normcdf(x) = 0.5*(1+erf(y/sqrt(2))); is the standard normal CDF
-                    %         
-                    % Mean     = theta;
-                    % Variance = theta^3/chi;
-                    % Skewness = sqrt(9*theta/chi);
-                    % Kurtosis = 15*mean/scale;
-                    % Mode = theta/(2*chi)*(sqrt(9*theta^2+4*chi^2)-3*theta);
-                    %
-                    % PARAMETERS:
-                    %  theta - location; (theta>0)
-                    %  chi - scale; (chi>0)
-                    %
-                    % SUPPORT:
-                    %  y,  y>0
-                    %
-                    % CLASS:
-                    %   Continuous skewed distribution
-                    %
-                    % NOTES:
-                    %   1. There are several alternate forms for the PDF, 
-                    %      some of which have more than two parameters
-                    %   2. The Inverse Gaussian distribution is often called the Inverse Normal
-                    %   3. Wald distribution is a special case of The Inverse Gaussian distribution
-                    %      where the mean is a constant with the value one.
-                    %   4. The Inverse Gaussian distribution is a special case of The Generalized
-                    %        Hyperbolic Distribution
-                    %
-                    % USAGE:
-                    %   randraw('ig', [theta, chi], sampleSize) - generate sampleSize number
-                    %         of variates from the Inverse Gaussian distribution with 
-                    %         parameters theta and chi;
-                    %   randraw('ig') - help for the Inverse Gaussian distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('ig', [0.1, 1], [1 1e5]);
-                    %  2.   y = randraw('ig', [3.2, 10], 1, 1e5);
-                    %  3.   y = randraw('ig', [100.2, 6], 1e5 );
-                    %  4.   y = randraw('ig', [10, 10.5], [1e5 1] );
-                    %  5.   randraw('ig');
-                    % 
-                    % SEE ALSO:
-                    %   WALD distribution
-                    % END ig HELP END inversegauss HELP  END invgauss HELP 
-                    
-                    % Method:
-                    %
-                    % There is an efficient procedure that utilizes a transformation
-                    % yielding two roots.
-                    % If Y is Inverse Gauss random variable, then following to [1]
-                    % we can write:
-                    % V = chi*(Y-theta)^2/(Y*theta^2) ~ Chi-Square(1),
-                    %
-                    % i.e. V is distributed as a chi-square random variable with
-                    % one degree of freedom.
-                    % So it can be simply generated by taking a square of a
-                    % standard normal random number.
-                    % Solving this equation for Y yields two roots:
-                    %
-                    % y1 = theta + 0.5*theta/chi * ( theta*V - sqrt(4*theta*chi*V + ...
-                    %      theta^2*V.^2) );
-                    % and
-                    % y2 = theta^2/y1;
-                    %
-                    % In [2] showed that  Y can be simulated by choosing y1 with probability
-                    % theta/(theta+y1) and y2 with probability 1-theta/(theta+y1)
-                    %
-                    % References:
-                    % [1] Shuster, J. (1968). On the Inverse Gaussian Distribution Function,
-                    %         Journal of the American Statistical Association 63: 1514-1516.
-                    %
-                    % [2] Michael, J.R., Schucany, W.R. and Haas, R.W. (1976).
-                    %     Generating Random Variates Using Transformations with Multiple Roots,
-                    %     The American Statistician 30: 88-90.
-                    %
-                    %
-
-                    checkParamsNum(funcName, 'Inverse Gaussian', 'ig', distribParams, [2]);
-                    theta = distribParams(1);
-                    chi = distribParams(2);
-                    validateParam(funcName, 'Inverse Gaussian', 'ig', '[theta, chi]', 'theta', theta, {'> 0'});
-                    validateParam(funcName, 'Inverse Gaussian', 'ig', '[theta, chi]', 'chi', chi, {'> 0'});
-
-                    chisq1 = randn(sampleSize).^2;
-                    out = theta + 0.5*theta/chi * ( theta*chisq1 - ...
-                         sqrt(4*theta*chi*chisq1 + theta^2*chisq1.^2) );
-
-                    l = rand(sampleSize) >= theta./(theta+out);
-                    out( l ) = theta^2./out( l );
-
-               case {'laplace' 'doubleexponential', 'doubleexp', 'bilateralexponential', 'bilateralexp'}
-                    % START laplace HELP START doubleexponential HELP START doubleexp HELP START bilateralexponential HELP START bilateralexp HELP
-                    % THE LAPLACE DISTRIBUTION
-                    % (sometimes: double-exponential or bilateral exponential distribution)
-                    %
-                    % pdf = 1/(2*lam)*exp(-abs(y-theta)/lam);
-                    % cdf = (y<=theta) .* 1/2*exp((y-theta)/lam) + (y>theta) .* (1 - 1/2*exp((theta-y)/lam));
-                    %
-                    % Mean = Median = Mode = theta;
-                    % Variance = 2*lam^2;
-                    % Skewness = 0;
-                    % Kurtosis = 3;
-                    %
-                    % PARAMETERS:
-                    %   theta  - location
-                    %   lam   -  scale  (lam>0)
-                    %
-                    % SUPPORT:
-                    %   y ,   -Inf < y < Inf
-                    %
-                    % CLASS:
-                    %   Continuous symmetric distribution   
-                    %
-                    % USAGE:
-                    %   randraw('laplace', [], sampleSize) - generate sampleSize number
-                    %         of variates from the Laplace distribution with 
-                    %         loaction parameter theta=0 and scale parameter lam=1;                    
-                    %   randraw('laplace', [theta, lam], sampleSize) - generate sampleSize number
-                    %         of variates from the Laplace distribution with 
-                    %         loaction parameter theta and scale parameter lam;
-                    %   randraw('laplace') - help for the Laplace distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('laplace', [0, 1], [1 1e5]);
-                    %  2.   y = randraw('laplace', [3.2, 10], 1, 1e5);
-                    %  3.   y = randraw('laplace', [100.2, 6], 1e5 );
-                    %  4.   y = randraw('laplace', [10, 10.5], [1e5 1] );
-                    %  5.   randraw('laplace');                    
-                    % END laplace HELP END doubleexponential HELP END doubleexp HELP END bilateralexponential HELP END bilateralexp HELP
-
-                    checkParamsNum(funcName, 'Laplace', 'laplace', distribParams, [0, 2]);
-                    if numel(distribParams)==2
-                         theta  = distribParams(1);
-                         lam  = distribParams(2);
-                         validateParam(funcName, 'Laplace', 'laplace', '[theta, lam]', 'lam', lam, {'> 0'});
-                    else
-                         theta = 0;
-                         lam = 1;
-                    end
-                    
-                    u = rand( sampleSize );
-                    out = zeros( sampleSize );
-                    out(u<=0.5) = theta + lam*log(2*u(u<=0.5));
-                    out(u>0.5) = theta - lam*log(2*(1-u(u>0.5)));
-                    
-               case {'logistic'}
-                    % START logistic HELP
-                    % THE LOGISTIC DISTRIBUTION
-                    %   The logistic distribution is a symmetrical bell shaped distribution.
-                    %   One of its applications is an alternative to the Normal distribution
-                    %   when a higher proportion of the population being modeled is
-                    %   distributed in the tails.
-                    %
-                    %  pdf(y) = exp((y-a)/k)./(k*(1+exp((y-a)/k)).^2);
-                    %  cdf(y) = 1 ./ (1+exp(-(y-a)/k))
-                    %
-                    %  Mean = a;
-                    %  Variance = k^2*pi^2/3;
-                    %  Skewness = 0;
-                    %  Kurtosis = 1.2;
-                    %
-                    % PARAMETERS:
-                    %  a - location;
-                    %  k - scale (k>0);
-                    %
-                    % SUPPORT:
-                    %   y,  -Inf < y < Inf
-                    %
-                    % CLASS:
-                    %   Continuous symmetric distribution                      
-                    %
-                    % USAGE:
-                    %   randraw('logistic', [], sampleSize) - generate sampleSize number
-                    %         of variates from the standard Logistic distribution with 
-                    %         loaction parameter a=0 and scale parameter k=1;                    
-                    %   randraw('logistic', [a, k], sampleSize) - generate sampleSize number
-                    %         of variates from the Logistic distribution with 
-                    %         loaction parameter 'a' and scale parameter 'k';
-                    %   randraw('logistic') - help for the Logistic distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('logistic', [], [1 1e5]);
-                    %  2.   y = randraw('logistic', [0, 4], 1, 1e5);
-                    %  3.   y = randraw('logistic', [-1, 10.2], 1e5 );
-                    %  4.   y = randraw('logistic', [3.2, 0.3], [1e5 1] );
-                    %  5.   randraw('logistic');                       
-                    % END logistic HELP
-                    
-                    % Method:
-                    %
-                    % Inverse CDF transformation method.
-
-                    checkParamsNum(funcName, 'Logistic', 'logistic', distribParams, [0, 2]);
-                    if numel(distribParams)==2
-                         a  = distribParams(1);
-                         k  = distribParams(2);
-                         validateParam(funcName, 'Laplace', 'laplace', '[a, k]', 'k', k, {'> 0'});
-                    else
-                         a = 0;
-                         k = 1;
-                    end
-
-                    u1 = rand( sampleSize );
-                    out = a - k*log( 1./u1 - 1 );
-
-               case { 'lognorm', 'lognormal', 'cobbdouglas', 'antilognormal' }
-                    % START lognorm HELP START lognormal HELP START cobbdouglas HELP START antilognormal HELP
-                    % THE LOG-NORMAL DISTRIBUTION
-                    % (sometimes: Cobb-Douglas or antilognormal distribution)
-                    %
-                    % pdf = 1/(y*sigma*sqrt(2*pi)) * exp(-1/2*((log(y)-mu)/sigma)^2)
-                    % cdf = 1/2*(1 + erf((log(y)-mu)/(sigma*sqrt(2))));
-                    % 
-                    % Mean = exp( mu + sigma^2/2 );
-                    % Variance = exp(2*mu+sigma^2)*( exp(sigma^2)-1 );
-                    % Skewness = (exp(1)+2)*sqrt(exp(1)-1), for mu=0 and sigma=1;
-                    % Kurtosis = exp(4) + 2*exp(3) + 3*exp(2) - 6; for mu=0 and sigma=1;
-                    % Mode = exp(mu-sigma^2);
-                    %
-                    % PARAMETERS:
-                    %  mu - location
-                    %  sigma - scale (sigma>0)
-                    %
-                    % SUPPORT:
-                    %   y,  y>0
-                    %
-                    % CLASS:
-                    %   Continuous skewed distribution                      
-                    %
-                    % NOTES:
-                    %  1) The LogNormal distribution is always right-skewed
-                    %  2) Parameters mu and sigma are the mean and standard deviation 
-                    %     of y in (natural) log space.
-                    %  3) mu = log(mean(y)) - 1/2*log(1 + var(y)/(mean(y))^2);
-                    %  4) sigma = sqrt( log( 1 + var(y)/(mean(y))^2) );
-                    %
-                    % USAGE:
-                    %   randraw('lognorm', [], sampleSize) - generate sampleSize number
-                    %         of variates from the standard Lognormal distribution with 
-                    %         loaction parameter mu=0 and scale parameter sigma=1;                    
-                    %   randraw('lognorm', [mu, sigma], sampleSize) - generate sampleSize number
-                    %         of variates from the Lognormal distribution with 
-                    %         loaction parameter 'mu' and scale parameter 'sigma';
-                    %   randraw('lognorm') - help for the Lognormal distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('lognorm', [], [1 1e5]);
-                    %  2.   y = randraw('lognorm', [0, 4], 1, 1e5);
-                    %  3.   y = randraw('lognorm', [-1, 10.2], 1e5 );
-                    %  4.   y = randraw('lognorm', [3.2, 0.3], [1e5 1] );
-                    %  5.   randraw('lognorm');                                           
-                    %END lognorm HELP END lognormal HELP END cobbdouglas HELP END antilognormal HELP
-                    
-                    checkParamsNum(funcName, 'Lognormal', 'lognorm', distribParams, [0, 2]);
-                    if numel(distribParams)==2
-                         mu  = distribParams(1);
-                         sigma  = distribParams(2);
-                         validateParam(funcName, 'Lognormal', 'lognorm', '[mu, sigma]', 'sigma', sigma, {'> 0'});
-                    else
-                         mu = 0;
-                         sigma = 1;
-                    end
-
-                    out = exp( mu + sigma * randn( sampleSize ) );
-
-               case {'maxwell'}
-                    % START maxwell HELP
-                    % THE MAXWELL DISTRIBUTION
-                    %
-                    % pdf(y) = 1/a^3 * sqrt(2/pi) * y.^2 * exp(-y.^2/(2*a^2));  a > 0, y >= 0                    
-                    % cdf(y) = gammainc(3/2, y.^2/(2*a^2));
-                    %
-                    % Mean     = 2*a*sqrt(2/pi);
-                    % Variance = a^2*(3-8/pi);
-                    % Skewness = 2*(16/pi-5)*sqrt(2/pi) / (3-8/pi)^(3/2) = 0.48569282804959
-                    % Kurtosis = (15-8/pi)/(3-8/pi)^2 - 3 ???
-                    %
-                    % PARAMETERS:
-                    %   a - scale parameter (a > 0)
-                    %
-                    % SUPPORT:
-                    %   y, y >= 0
-                    %
-                    % CLASS:
-                    %   Continuous skewed distribution                      
-                    %
-                    % NOTES:
-                    %  The distribution of speeds of molecules in thermal equilibrium as given by
-                    %  statistical mechanics and named after the famous scottish physicist James
-                    %  Clerk Maxwell (1831-1879).
-                    %
-                    % USAGE:                 
-                    %   randraw('maxwell', a, sampleSize) - generate sampleSize number
-                    %         of variates from the Maxwell distribution with 
-                    %         scale parameter 'a';
-                    %   randraw('maxwell') - help for the Maxwell distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('maxwell', 1.1, [1 1e5]);
-                    %  2.   y = randraw('maxwell', 0.5, 1, 1e5);
-                    %  3.   y = randraw('maxwell', 10, 1e5 );
-                    %  4.   y = randraw('maxwell', 5.5, [1e5 1] );
-                    %  5.   randraw('maxwell');                       
-                    % END maxwell HELP
-                    
-                    checkParamsNum(funcName, 'Maxwell', 'maxwell', distribParams, [1]);
-                    a  = distribParams(1);
-                    validateParam(funcName, 'Maxwell', 'maxwell', 'a', 'a', a, {'> 0'});
-
-                    out = sqrt( randn(sampleSize).^2 + randn(sampleSize).^2 + ...
-                         randn(sampleSize).^2 ) * a;
-
-               case {'nakagamim', 'nakagami-m', 'nakagami'}
-                    % START nakagamim HELP START nakagami-m HELP START nakagami HELP                   
-                    % THE NAKAGAMI DISTRIBUTION
-                    %
-                    % ( sometimes: Nakagami-m distribution )
-                    %
-                    % pdf(y) = 2/gamma(m) * (m/omega)^m * y.^(2*m-1).*exp(-m*y.^2/omega); 
-                    % cdf(y) = gammainc(m/omega*y.^2, m);
-                    %
-                    % Mean     = gamma(m+0.5)/gamma(m)*(omega/m)^0.5;
-                    % Variance = omega*(1-1/m*(gamma(m+0.5)/gamma(m))^2);
-                    % Median = sqrt(omega);
-                    % Mode = sqrt(2)/2*((2*m-1)*omega/m)^0.5;
-                    %
-                    % PARAMETERS:
-                    %   m - shape parameter (m > 0)
-                    %   omega - spread parameter (omega>0)
-                    %
-                    % SUPPORT:
-                    %   y, y > 0
-                    %
-                    % CLASS:
-                    %   Continuous skewed distribution                      
-                    %
-                    % NOTES:
-                    %   1) Nakagami distribution is am important distribution in
-                    %      fading channel modeling in wireless communication.
-                    %   2) If Y has a Nakagami distributin with parameters 'm' and 
-                    %      'omega', then Y^2 has a gamma distribution with shape parameter
-                    %      'm' and scale parameter 'omega/m'
-                    %
-                    % USAGE:                 
-                    %   randraw('nakagami', m, sampleSize) - generate sampleSize number
-                    %         of variates from the Nakagami distribution with shape
-                    %         parameter 'm' and spread parameter omega=1;                    
-                    %   randraw('nakagami', [m, omega], sampleSize) - generate sampleSize number
-                    %         of variates from the Nakagami distribution with shape
-                    %         parameter 'm' and spread parameter 'omega';
-                    %   randraw('nakagami') - help for the Nakagami distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('nakagami', 1.1, [1 1e5]);
-                    %  2.   y = randraw('nakagami', [0.6, 2], 1, 1e5);
-                    %  3.   y = randraw('nakagami', [3, 2.5], 1e5 );
-                    %  4.   randraw('nakagami'); 
-                    % END nakagamim HELP END nakagami-m HELP END nakagami HELP
-                    
-                    checkParamsNum(funcName, 'Nakagami', 'nakagamim', distribParams, [1 2]);
-                    
-                    if numel(distribParams) == 2
-                         m = distribParams(1);
-                         omega = distribParams(2);
-                         validateParam(funcName, 'Nakagami', 'nakagamim', '[m, omega]', 'm', m, {'> 0'});
-                         validateParam(funcName, 'Nakagami', 'nakagamim', '[m, omega]', 'omega', omega, {'> 0'});
-                    else
-                         m = distribParams(1);
-                         omega = 1;
-                         validateParam(funcName, 'Nakagami', 'nakagamim', '[m, omega]', 'm', m, {'> 0'});
-                    end                    
-                    
-                    out = sqrt( randraw('gamma', [0, omega/m, m], sampleSize) );
- 
-               case {'negativebinomial', 'negbinomial', 'negbinom', 'pascal'}
-                    % START negbinom HELP START pascal HELP
-                    % THE NEGATIVE BINOMIAL DISTRIBUTION
-                    %  ( sometimes: Pascal distribution )
-                    %
-                    % Negative Binomial (also known as the Pascal or Polya) distribution
-                    % gives the probability of r-1 successes and y failures in y+r-1 trials
-                    % and success on the (y+r)'th trial (if r is positive integer )
-                    %
-                    %  pdf(y) = gamma(r+y)./(gamma(y+1)*gamma(r)) * p^r * (1-p)^y = ...
-                    %           exp( gammaln(r+y) - gammaln(y+1) - gammaln(r) + r*log(p) + y*log(1-p) );
-                    %              y>=0
-                    %
-                    %  Mode = (r>1)*floor( (r-1)*(1-p)/p ) + (r<=1)*0;
-                    %  Mean = r*(1-p)/p;
-                    %  Variance = r*(1-p)/p^2;
-                    %  Skewness = (2-p) / sqrt(r*(1-p));
-                    %  Kurtosis = (p^2-6*p+6)/(r*(1-p));
-                    %
-                    %  PARAMETERS: 
-                    %      r>0; 
-                    %      p - probability of success in a single trial ( 0< p <1 );
-                    % 
-                    %  SUPPORT: 
-                    %      y = 0, 1, 2, 3, ...
-                    %
-                    % CLASS:
-                    %   Discrete distribution  
-                    %
-                    % USAGE:                 
-                    %   randraw('negbinom', [r, p], sampleSize) - generate sampleSize number
-                    %         of variates from the Negative Binomial distribution with 
-                    %        parameters 'r' and 'p';
-                    %   randraw('negbinom') - help for the Negative Binomial distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('negbinom', [10 0.2], [1 1e5]);
-                    %  2.   y = randraw('negbinom', [100, 0.9], 1, 1e5);
-                    %  3.   y = randraw('negbinom', [20 0.1], 1e5 );
-                    %  4.   y = randraw('negbinom', [30 0.99], [1e5 1] );
-                    %  5.   randraw('negbinom');                       
-                    % END negbinom HELP END pascal HELP
-                    
-                    % Method:
-                    %
-                    % We implemented Condensed Table-Lookup method suggested in
-                    %    George Marsaglia, "Fast Generation Of Discrete Random Variables,"
-                    %    Journal of Statistical Software, July 2004, Volume 11, Issue 4
-                    
-                    % pdf = exp( gammaln(r+y) - gammaln(y+1) - gammaln(r) + r*log(p) + y*log(1-p) );
-
-                    checkParamsNum(funcName, 'Negative Binomial', 'negbinom', distribParams, [2]);                                        
-                    r = distribParams(1);
-                    validateParam(funcName, 'Negative Binomial', 'negbinom', '[r, p]', 'r', r, {'> 0'});
-                    p = distribParams(2);
-                    validateParam(funcName, 'Negative Binomial', 'negbinom', '[r, p]', 'p', p, {'> 0','< 1'});
-                    
-                    q = 1 - p;
-
-                    if r*q/p^2 > 1e8
-                         out = 1/p * feval(funcName, 'gamma', r*(1-p), sampleSize);
-                    else
-                         mode = (r>1)*floor( (r-1)*(1-p)/p ) + (r<=1)*0;
-                         pmode = exp( gammaln(r+mode) - gammaln(mode+1) - gammaln(r) + ...
-                              r*log(p) + mode*log(1-p) );
-
-                         t=pmode;
-                         ii = mode+1;
-                         while t*2147483648 > 1
-                              t = t * (r+ii-1)/ii * q;
-                              ii = ii + 1;
-                         end
-                         last=ii-2;
-
-                         t=pmode;
-                         j=-1;
-                         for ii=mode-1:-1:0
-                              t = t * (ii+1)/(r+ii)/q;
-                              if t*2147483648 < 1
-                                   j=ii;
-                                   break;
-                              end
-                         end
-                         offset=j+1;
-                         sizeP=last-offset+1;
-
-                         P = zeros(1, sizeP);
-
-                         ii = (mode+1):last;
-                         P(mode-offset+1:last-offset+1) = round( 2^30*pmode*cumprod([1, (r+ii-1)./ii * q] ) );
-
-                         ii = (mode-1):-1:offset;
-                         P(mode-offset:-1:1) = round( 2^30*pmode*cumprod((ii+1)./(r+ii)/q) );
-
-                         out = randFrom5Tbls( P, offset, sampleSize);                   
-                    end
-                    
-               case {'normal', 'gaussian', 'gauss', 'norm'} % Gaussian distribution
-                    % START normal HELP START gaussian HELP START gauss HELP START norm HELP
-                    % THE NORMAL DISTRIBUTION
-                    % Standard form of the Normal distribution:
-                    %   pdf(y) = 1/sqrt(2*pi) * exp(-1/2*y.^2);
-                    %   cdf(y) = 0.5*(1+erf(y/sqrt(2)));
-                    %
-                    % Mean = 0;
-                    % Variance = 1;
-                    %
-                    % General form of the Normal distribution:
-                    %   pdf(y) = 1/(sigma*sqrt(2*pi)) * exp(-1/2*((y-mu)/sigma).^2);
-                    %   cdf(y) = 1/2*(1+erf((y-mu)/(sigma*sqrt(2))));
-                    %
-                    % Mean = mu;
-                    % Variance = sigma^2;
-                    %
-                    % PARAMETERS:
-                    %  mu      - location (mean)
-                    %  sigma>0 - scale (std)
-                    %
-                    % SUPPORT:
-                    %  y,   -Inf < y < Inf
-                    %
-                    % CLASS:
-                    %   Continuous symmetric distributions
-                    %
-                    % USAGE:
-                    %   randraw('norm', [], sampleSize) - generate sampleSize number
-                    %         of variates from the standard Normal distribution;                  
-                    %   randraw('norm', [mu, sigma], sampleSize) - generate sampleSize number
-                    %         of variates from the Normal distribution with 
-                    %         mean 'mu' and std 'sigma';
-                    %   randraw('norm') - help for the Lognormal distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('norm', [], [1 1e5]);
-                    %  2.   y = randraw('norm', [0, 4], 1, 1e5);
-                    %  3.   y = randraw('norm', [-1, 10.2], 1e5 );
-                    %  4.   y = randraw('norm', [3.2, 0.3], [1e5 1] );
-                    %  5.   randraw('norm');    
-                    % END normal HELP END gaussian HELP END gauss HELP END norm HELP
-                    
-                    checkParamsNum(funcName, 'Normal', 'normal', distribParams, [0, 2]);
-                    
-                    if numel(distribParams)==2
-                         mu = distribParams(1);
-                         sigma = distribParams(2);
-                         validateParam(funcName, 'Normal', 'normal', '[mu, sigma]', 'sigma', sigma, {'> 0'});
-                    else
-                         mu = 0;
-                         sigma = 1;
-                    end
-
-                    out = mu + sigma * randn( sampleSize );
-
-               case {'normaltrunc', 'normaltruncated', 'gausstrunc'}
-                    % START normaltrunc HELP START normaltruncated HELP START gausstrunc HELP
-                    % THE TRUNCATED NORMAL DISTRIBUTION
-                    %
-                    %   pdf(y) = normpdf((y-mu)/sigma) / (sigma*(normcdf((b-mu)/sigma)-normcdf((a-mu)/sigma))); a<=y<=b; 
-                    %   cdf(y) = (normcdf((y-mu)/sigma)-normcdf((a-mu)/sigma)) / (normcdf((b-mu)/sigma)-normcdf((a-mu)/sigma)); a<=y<=b;
-                    %      where mu and sigma are the mean and standard deviation of the parent normal 
-                    %            distribution and a and b are the lower and upper truncation points. 
-                    %            normpdf and normcdf are the PDF and CDF for the standard normal distribution respectvely
-                    %            ( run randraw('normal') for help).
-                    %                                        
-                    %   Mean = mu - sigma*(normpdf((b-mu)/sigma)-normpdf((a-mu)/sigma))/(normcdf((b-mu)/sigma)-normcdf((a-mu)/sigma));
-                    %   Variance = sigma^2 * ( 1 - ((b-mu)/sigma*normpdf((b-mu)/sigma)-(a-mu)/sigma*normpdf((a-mu)/sigma))/(normcdf((b-mu)/sigma)-normcdf((a-mu)/sigma)) - ...
-                    %                           ((normpdf((b-mu)/sigma)-normpdf((a-mu)/sigma))/(normcdf((b-mu)/sigma)-normcdf((a-mu)/sigma)))^2 );
-                    %
-                    % PARAMETERS:  
-                    %   a  - lower truncation point;
-                    %   b  - upper truncation point; (b>=a)
-                    %   mu - Mean of the parent normal distribution
-                    %   sigma - standard deviation of the parent normal distribution (sigma>0)
-                    %   
-                    %
-                    % SUPPORT:      
-                    %   y,   a <= y <= b
-                    %
-                    % CLASS:
-                    %   Continuous distributions
-                    %
-                    % USAGE:
-                    %   randraw('normaltrunc', [a, b, mu, sigma], sampleSize) - generate sampleSize number
-                    %         of variates from Truncated Normal distribution on the interval (a, b) with
-                    %         parameters 'mu' and  'sigma';
-                    %   randraw('normaltrunc') - help for Truncated Normal distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('normaltrunc', [0, 1, 0, 1], [1 1e5]);
-                    %  2.   y = randraw('normaltrunc', [0, 1, 10, 3], 1, 1e5);
-                    %  3.   y = randraw('normaltrunc', [-10, 10, 0, 1], 1e5 );
-                    %  4.   y = randraw('normaltrunc', [-13.1, 15.2, 20.1, 3.3], [1e5 1] );
-                    %  5.   randraw('normaltrunc');                    
-                    % END normaltrunc HELP END normaltruncated HELP END gausstrunc HELP
-                    
-                    % See http://www.econ.umn.edu/~kortum/courses/fall02/lecture4k.pdf
-                    %     http://hydrology.ifas.ufl.edu/publications/jawitz_2004_AWR.pdf
-                    
-                    checkParamsNum(funcName, 'Truncated Normal', 'normaltrunc', distribParams, [4]);
-                    
-                    a = distribParams(1);
-                    b = distribParams(2);
-                    mu = distribParams(3);
-                    sigma = distribParams(4);
-                    validateParam(funcName, 'Truncated Normal', 'normaltrunc', '[a, b, mu, sigma]', 'b-a', b-a, {'>=0'});
-                    validateParam(funcName, 'Truncated Normal', 'normaltrunc', '[a, b, mu, sigma]', 'sigma', sigma, {'> 0'});
-
-                    PHIl = normcdf((a-mu)/sigma);
-                    PHIr = normcdf((b-mu)/sigma);
-                    
-                    out = mu + sigma*( sqrt(2)*erfinv(2*(PHIl+(PHIr-PHIl)*rand(sampleSize))-1) );
-                    
-               case {'nig'}
-                    % START nig HELP
-                    % THE NORMAL INVERSE GAUSSIAN (NIG) DISTRIBUTION 
-                    %  NIG(alpha, beta, mu, delta)
-                    %
-                    %  Heavy-tailed distributions such as the normal inverse Gauss distribution
-                    %  (NIG) play a prominent role in the statistical analysis of economic time-series.
-                    %  A number of empirical studies have shown that the marginal distribution of the
-                    %  daily returns of liquid shares are NIG. 
-                    %
-                    %   The NIG density is a variance-mean mixture of a Gaussian density with 
-                    %  an inverse Gaussian.                    
-                    %   The shape of the NIG density is specified by the four-dimensional 
-                    %  parameter vector [alpha, beta , mu, delta]. The rich parametrization
-                    %  makes the NIG density a suitable model for a variety of unimodal positive 
-                    %  kurtotic data. The alpha-parameter controls the steepness or pointiness 
-                    %  of the density, which increases monotonically with increasing alpha.
-                    %  A large alpha implies light tails, a small value implies heavy tails.
-                    %  The beta-parameter controls the skewness. For beta<0, the density is skewed to
-                    %  the left, for beta>0 the density is skewed to the right, while
-                    %  beta=0 implies a symmetric density around mu, which is a centrality parameter.
-                    %  The delta-parameter is a scale-like parameter.
-                    %
-                    %  pdf(y; alpha, beta, mu, delta) = ...
-                    %      alpha/pi * exp(delta*sqrt(alpha^2-beta^2) - beta*mu) * ...
-                    %      1/sqrt(1+((y-mu)/delta).^2) .* ...
-                    %      besselk(1, alpha*delta*sqrt(1+((y-mu)/delta).^2)) .*...
-                    %      exp(beta*y);
-                    %
-                    %   Mean = mu+beta*delta/sqrt(alpha^2-beta^2);
-                    %   Variance = delta * (alpha^2 / sqrt(alpha^2 - beta^2)^3);
-                    %   Skewness = 3*beta/(alpha*sqrt(delta*sqrt(alpha^2 - beta^2)));
-                    %   Kurtosis = 3*(1 + 4*(beta/alpha)^2)/(delta*sqrt(alpha^2 - beta^2));
-                    %
-                    %  PARAMETERS:
-                    %    alpha,  alpha > 0
-                    %    beta,   0 <= abs(beta) < alpha
-                    %    mu,     -Inf < mu < Inf
-                    %    delta,  delta > 0 
-                    %
-                    %  SUPPORT:      
-                    %    y,   -Inf < y < Inf
-                    %
-                    % CLASS:
-                    %   Continuous skewed distribution
-                    %
-                    % USAGE:
-                    %   randraw('nig', [alpha, beta, mu, delta], sampleSize) - generate sampleSize
-                    %         number of variates from NIG distribution with parameters
-                    %         alpha, beta, mu and delta                    
-                    %   randraw('nig') - help for NIG distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('nig', [2, 1, 4, 2], [1 1e5]);
-                    %  2.   y = randraw('nig', [2, 1, 4, 2], 1, 1e5);
-                    %  3.   y = randraw('nig', [2, 1, 4, 2], 1e5 );
-                    %  4.   y = randraw('nig', [2, 1, 4, 2], [1e5 1] );
-                    %  5.   randraw('nig');
-                    %
-                    % SEE ALSO:
-                    %  INVERSE GAUSSIAN distribution                    
-                    % END nig HELP
-                    
-                    % REFERENCES:
-                    % 1. http://www.quantlet.com/mdstat/scripts/csa/html/node236.html
-                    % 2. http://www.anst.uu.se/larsfors/APRv1_5.pdf
-                    % 3. http://ica2001.ucsd.edu/index_files/pdfs/048-jenssen.pdf  
-                    % 4. http://www.freidok.uni-freiburg.de/volltexte/15/pdf/15_1.pdf
-
-                    
-                    checkParamsNum(funcName, 'NIG', 'nig', distribParams, [4]);
-                                        
-                    alpha = distribParams(1);
-                    beta  = distribParams(2);
-                    mu    = distribParams(3);
-                    delta = distribParams(4);
-                    
-                    validateParam(funcName, 'NIG', 'nig', '[alpha, beta, mu, delta]', 'alpha', alpha, {'> 0'});
-                    validateParam(funcName, 'NIG', 'nig', '[alpha, beta, mu, delta]', 'delta', delta, {'> 0'});
-                    validateParam(funcName, 'NIG', 'nig', '[alpha, beta, mu, delta]', 'alpha-abs(beta)', alpha-abs(beta), {'> 0'});
-                    
-                    invGaussY = feval(funcName, 'ig', [delta/sqrt(alpha^2-beta^2), delta^2], sampleSize);
-                    out = mu + beta*invGaussY + sqrt(invGaussY).*randn(sampleSize);
-                    
-               case {'pareto'}
-                    % START pareto HELP
-                    %   Pareto or "power law" distribution, used in the analysis of financial data
-                    %   and critical behavior
-                    %
-                    %  pdf = a*k^a ./ y.^(a+1);
-                    %  cdf = 1 - (k./y).^a;
-                    %
-                    %  Mean = k*a/(a-1);
-                    %  Variance = k^2*a/((a-2)*(a-1)^2);
-                    %  Skewness = 2*(a+1)*sqrt(a-2)/((a-3)*sqrt(a));
-                    %  Kurtosis = 6*(a^3+a^2-6*a-2)/(a*(a^2-7*a+12));
-                    %
-                    % PARAMETERS:
-                    %  k - location parameter  (k>0)
-                    %  a - shape parameter (a>0)                    
-                    %
-                    % SUPPORT:
-                    %  y,  y > k
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % USAGE:
-                    %   randraw('pareto', [k, a], sampleSize) - generate sampleSize
-                    %         number of variates from the Pareto distribution with parameters
-                    %         'k' and 'a'                    
-                    %   randraw('pareto') - help for the Pareto distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('pareto', [1, 2], [1 1e5]);
-                    %  2.   y = randraw('pareto', [3, 8], 1, 1e5);
-                    %  3.   y = randraw('pareto', [0.5, 2.4], 1e5 );
-                    %  4.   y = randraw('pareto', [3.5, 4.5], [1e5 1] );
-                    %  5.   randraw('pareto');                     
-                    % END pareto HELP
-
-                    checkParamsNum(funcName, 'Pareto', 'pareto', distribParams, [2]);
-                                        
-                    k = distribParams(1);
-                    a  = distribParams(2);
-                    validateParam(funcName, 'Pareto', 'pareto', '[k, a]', 'k', k, {'> 0'});
-                    validateParam(funcName, 'Pareto', 'pareto', '[k, a]', 'a', a, {'> 0'});
-
-                    out = k*rand( sampleSize ).^(-1/a);
-
-               case {'pareto2', 'lomax'}
-                    % START pareto2 HELP
-                    % THE PARETO DISTRIBUTION OF THE SECOND TYPE
-                    %  (sometimes Lomax distribution )
-                    %
-                    %  pdf = b*k^b ./ (k+y).^(b+1);   b>0, y>0;
-                    %  cdf = 1 - k^b./(k+y).^b; 
-                    %
-                    % PARAMETERS:
-                    %   k - location parameters (k>0)
-                    %   b - shape parameters (b>0)
-                    %
-                    % SUPPORT:
-                    %   y,  y>0
-                    %
-                    % CLASS;
-                    %  Continuous skewed distribution
-                    %
-                    % USAGE:
-                    %   randraw('pareto2', [k, b], sampleSize) - generate sampleSize
-                    %         number of variates from the Pareto Second Type distribution with parameters
-                    %         'k' and 'b'                    
-                    %   randraw('pareto2') - help for the Pareto Second Type distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('pareto2', [1, 2], [1 1e5]);
-                    %  2.   y = randraw('pareto2', [3, 8], 1, 1e5);
-                    %  3.   y = randraw('pareto2', [0.5, 2.4], 1e5 );
-                    %  4.   y = randraw('pareto2', [3.5, 4.5], [1e5 1] );
-                    %  5.   randraw('pareto2');
-                    % END pareto2 HELP
-                    
-                    checkParamsNum(funcName, 'Pareto Second Type', 'pareto2', distribParams, [2]);
-                    
-                    k = distribParams(1);
-                    b  = distribParams(2);
-                    validateParam(funcName, 'Pareto Second Type', 'pareto2', '[k, b]', 'k', k, {'> 0'});
-                    validateParam(funcName, 'Pareto Second Type', 'pareto2', '[k, b]', 'b', b, {'> 0'});
-                    
-                    out = k*(1 - rand( sampleSize )).^(-1/b) - k;
-                    
-               case 'planck'
-                    % START planck HELP
-                    % THE PLANCK DISTRIBUTION
-                    % The Planck distribution widely used in Physics.
-                    %
-                    % The Planck distribution ia a two parameter distribution:
-                    % pdf(y) = b^(a+1)/(gamma(a+1)*zeta(a+1)) * y^a/(exp(b*y)-1);
-                    %    where zeta(c) is the Riemann zeta function defined as
-                    %       zeta(c) = sum from k=1 to Inf of 1/k^c.
-                    % 
-                    % PARAMETERS:
-                    %  a > 0 is a shape parameter
-                    %  b > 0 is a scale parameter
-                    %
-                    % SUPPORT:
-                    %  y, y>0
-                    %
-                    % CLASS:
-                    %  Continuous skewed distributions
-                    %
-                    % USAGE:
-                    %   randraw('planck', [a, b], sampleSize) - generate sampleSize
-                    %         number of variates from the Planck distribution with parameters
-                    %         'a' and 'b'                    
-                    %   randraw('planck') - help for the Planck distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('planck', [1, 2], [1 1e5]);
-                    %  2.   y = randraw('planck', [3, 8], 1, 1e5);
-                    %  3.   y = randraw('planck', [0.5, 2.4], 1e5 );
-                    %  4.   y = randraw('planck', [3.5, 4.5], [1e5 1] );
-                    %  5.   randraw('planck');                           
-                    % END planck HELP
-                    
-                    % Reference:
-                    % Luc Devroye, "Non-Uniform Random Variate Generation,"
-                    % Springer 1986, 850p. 3-540-96305-7
-
-                    checkParamsNum(funcName, 'Planck', 'planck', distribParams, [2]);
-                    
-                    a = distribParams(1);
-                    b  = distribParams(2);
-                    validateParam(funcName, 'Planck', 'planck', '[a, b]', 'a', a, {'> 0'});
-                    validateParam(funcName, 'Planck', 'planck', '[a, b]', 'b', b, {'> 0'});
-
-                    zetav = feval(funcName, 'zeta', a+1, sampleSize);
-                    out = feval(funcName, 'gamma', a+1, sampleSize) ./ ...
-                         (b * zetav);
-
-               case {'poisson', 'po'}
-                    % START po HELP START poisson HELP
-                    % THE POISSON DISTRIBUTION
-                    %    ~ Poisson(lambda)
-                    %
-                    % pdf(y) = exp(-lambda)*lambda^y/factorial(y) = ...
-                    %           exp( -lambda + y*log(lambda) - gammaln(y+1) ); lambda>0
-                    %
-                    %  Mean = lambda;
-                    %  Variance = lambda
-                    %  Mode = floor(lambda);
-                    %
-                    % PARAMETERS:
-                    %  lambda,  lambda > 0
-                    %
-                    % SUPPORT:
-                    %  y,  y = 0, 1, 2, 3, 4, ...
-                    %
-                    % CLASS:
-                    %  Discrete distributions
-                    %
-                    % NOTES:
-                    %  1. If lambda is an integer, Mode also equals (lambda+1).
-                    %  2. The Poisson distribution is commonly used as an approximation 
-                    %     to the Binomial distribution when probability of success is very small.
-                    %  3. In queueing theory, when interarrival times are ~Exponential, the number of arrivals in a
-                    %     fixed interval are ~Poisson.
-                    %  4. Errors in observations with integer values (i.e., miscounting) are ~Poisson.   
-                    %  
-                    % USAGE:
-                    %   randraw('po', lambda, sampleSize) - generate sampleSize
-                    %         number of variates from the Poisson distribution with 
-                    %         parameter lambda;
-                    %   randraw('po') - help for the Poisson distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('po', [2], [1 1e5]);
-                    %  2.   y = randraw('po', [3], 1, 1e5);
-                    %  3.   y = randraw('po', [10.4], 1e5 );
-                    %  4.   y = randraw('po', [100.25], [1e5 1] );
-                    %  5.   randraw('po');
-                    %
-                    % SEE ALSO:
-                    %  BINOMIAL distribution                    
-                    %
-                    % END po HELP END poisson HELP
-                    
-                    % Method:
-                    % 1) If lambda > 1000 we use normal approximation to poisson distribution
-                    %      mean=lambda, variance=lambda^2
-                    % 2) If lambda < 1000 we use the following reference:
-                    %    George Marsaglia, Fast Generation Of Discrete Random Variables,
-                    %    Journal of Statistical Software, July 2004, Volume 11, Issue 4
-                    %
-                    %    (Note: this method does not support lambda<5e-10.
-                    %          So for lambda<5e-10 we return 0 )
-
-                    if numel(distribParams) ~= 1
-                         error('Poisson Distribution: Wrong numebr of parameters (run randraw(''poisson'') for help) ');
-                    end
-                    lam = distribParams(1);
-                    if lam < 0
-                         error('Poisson Distribution: Parameter ''lambda'' should be positive (run randraw(''poisson'') for help) ');
-                    end
-
-                    if lam > 1e3
-                         % For sufficiently large values of lambda (lambda > 1000 say),
-                         % the normal distribution with mean lambda and variance lambda is
-                         % an excellent approximation to the Poisson distribution.
-
-                         out = round( lam + sqrt(lam) * randn( sampleSize ) );
-
-                    else % lam <= 1e3
-
-                         if lam<21.4
-                              if lam<5e-10
-                                   varargout{1} = zeros( sampleSize );
-                                   return;
-                              end
-                              t=exp(-lam);
-                              p = t;
-                              ii = 1;
-                              while t*2147483648 > 1
-                                   t = t * (lam/ii);
-                                   ii = ii + 1;
-                              end
-                              sizeP = ii-1;
-                              offset = 0;
-                              %/* Given size, fill P array (30-bit integers) */
-
-                              P = round( 2^30*p*cumprod([1, lam./(1:sizeP-1)] ) );
-                         else %lam>21.4
-
-                              % maximum lam = 1940;
-
-                              mode = floor(lam);
-                              
-                              loglam = log(lam);
-                              log2147483648 = log(2147483648);
-                              tmode = -lam + mode*loglam - gammaln(mode+1);
-                              pmode = exp( tmode );
-
-                              t = tmode;
-                              ii = mode + 1;
-                              while t + log2147483648 > 0
-                                   t = t + loglam - log(ii);
-                                   ii = ii + 1;
-                              end                                   
-                              last = ii-2;
-                              
-                              t = tmode;
-                              j=-1;
-                              for ii=mode-1:-1:0
-                                   t = t - loglam + log(ii+1);
-                                   if t + log2147483648 < 0
-                                        j=ii;
-                                        break;
-                                   end
-                              end
-                    
-                              offset = j+1;
-                              sizeP = last-offset+1;
-
-                              P = zeros(1, sizeP);
-                     
-                              ii = (mode+1):last;
-                              P(mode-offset+1:last-offset+1) = round( 2^30*pmode*cumprod([1, lam./ii]) );
-                             
-                              ii = (mode-1):-1:offset;
-                              P(mode-offset:-1:1) = round( 2^30*pmode*cumprod((ii+1)/lam) );
-
-                         end
-
-                         out = randFrom5Tbls( P, offset, sampleSize);
-                         
-                    end
-                    
-               case {'quadratic', 'quad', 'quadr'}
-                    % START quadratic HELP  START quad HELP START quadr HELP
-                    % THE QUADRATIC DISTRIBUTION
-                    %
-                    % Standard form of the quadratic distribution:
-                    %
-                    %   pdf(y) = 3/4*(1-y.^2); -1<=y<=1;
-                    %
-                    %  Mean = 0;
-                    %  Variance = 1/5;
-                    %
-                    % General form of the quadratic distribution:
-                    %
-                    %   pdf(y) = 3/(4*s) * (1-((y-t)/s).^2); t-s<=y<=t+s; s>0
-                    %   cdf(y) = 1/2 + 3/4*(y-t)/s - 1/4*((y-t)/s).^3; ; t-s<=y<=t+s; s>0
-                    %
-                    %  Mean = t;
-                    %  Variance = s^2/5;
-                    %
-                    % PARAMETERS:  
-                    %   t - location
-                    %   s -scale; s>0
-                    %
-                    % SUPPORT:      
-                    %   y,   -1 <= y <= 1   - standard Quadratic distribution
-                    %    or
-                    %   y,   t-s <= y <= t+s  - generalized Quadratic distribution
-                    %
-                    % CLASS:
-                    %   Continuous distributions
-                    %
-                    % USAGE:
-                    %   randraw('quadr', [], sampleSize) - generate sampleSize number
-                    %         of variates from standard Quadratic distribution;
-                    %   randraw('quadr', [t, s], sampleSize) - generate sampleSize number
-                    %         of variates from generalized Quadratic distribution
-                    %         with location parameter 't' and scale parameter 's';
-                    %   randraw('quadr') - help for Quadratic distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('quadr', [], [1 1e5]);
-                    %  2.   y = randraw('quadr', [], 1, 1e5);
-                    %  3.   y = randraw('quadr', [], 1e5 );
-                    %  4.   y = randraw('quadr', [10 3], [1e5 1] );
-                    %  5.   randraw('quadr');                   
-                    % END quadratic HELP END quad HELP END quadr HELP
-                    
-                    
-                    % Method:
-                    %
-                    % Inverse CDF transformation method.
-                    % We use Vi`ete formula to solve cubic equation.
-                    
-                    checkParamsNum(funcName, 'Quadratic', 'quadratic', distribParams, [0, 2]);  
-                    if numel(distribParams)==2
-                         t  = distribParams(1);
-                         s  = distribParams(2);  
-                         validateParam(funcName, 'Quadratic', 'quadratic', '[t, s]', 's', s, {'> 0'});
-                    else
-                         t = 0;
-                         s = 1;                        
-                    end                      
-                    
-                    out = t + s * 2*sin(1/3*asin(2*rand( sampleSize )-1));
-                                                         
-               case {'rademacher'}
-                    % START rademacher HELP
-                    % THE RADEMACHER DISTRIBUTION
-                    %   The Rademacher distribution takes value 1 with probability 1/2
-                    %   and value -1 with probability 1/2 (it is simply a random sign)
-                    %   ( Hans Rademacher (1892-1969) )
-                    %
-                    % PARAMETERS:
-                    %    None
-                    %
-                    % SUPPORT:
-                    %   y = -1 or 1
-                    %
-                    % CLASS:
-                    %   Descrete distributions
-                    %
-                    % USAGE:
-                    %   randraw('rademacher', [], sampleSize) - generate sampleSize number
-                    %         of variates from the Rademacher distribution;
-                    %   randraw('rademacher') - help for the Rademacher distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('rademacher', [], [1 1e5]);
-                    %  2.   y = randraw('rademacher', [], 1, 1e5);
-                    %  3.   y = randraw('rademacher', [], 1e5 );
-                    %  4.   y = randraw('rademacher', [], [1e5 1] );
-                    %  5.   randraw('rademacher');  
-                    % END rademacher HELP
-
-                    checkParamsNum(funcName, 'Rademacher', 'rademacher', distribParams, [0]); 
-                    
-                    out = 2*round(rand(sampleSize)) - 1;
-
-               case {'rayl', 'rayleigh'}
-                    % START rayl HELP START rayleigh HELP
-                    % THE RAYLEIGH DISTRIBUTION
-                    %
-                    %  pdf  = y./sigma^2 * exp(-y.^2/(2*sigma^2)); y >= 0
-                    %  cdf  = 1 - exp(-y.^2/(2*sigma^2));
-                    %
-                    %  Mean = sqrt(pi/2)*sigma;
-                    %  Variance = (4-pi)/2*sigma^2;
-                    %
-                    % PARAMETERS:
-                    %   sigma - scale parameter (-Inf < sigma < Inf)
-                    %
-                    % SUPPORT:
-                    %   y,  y >= 0 
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    %  USAGE:
-                    %   randraw('rayl', sigma, sampleSize) - generate sampleSize number
-                    %         of variates from the Rayleigh distribution with scale parameter 'sigma';
-                    %   randraw('rayl') - help for the Rayleigh distribution;
-                    %
-                    %  EXAMPLES:
-                    %   1.   y = randraw('rayl', 1, [1 1e5]);
-                    %   2.   y = randraw('rayl', 2.5, 1, 1e5);
-                    %   3.   y = randraw('rayl', 3, 1e5 );
-                    %   4.   y = randraw('rayl', 4, [1e5 1] );
-                    %   5.   randraw('rayl'); 
-                    %
-                    %  SEE ALSO:
-                    %    CHI, MAXWELL, RICE, WEIBULL  distributions
-                    % END rayl HELP END rayleigh HELP
-
-                    checkParamsNum(funcName, 'Rayleigh', 'rayl', distribParams, [1]);
-                    sigma = distribParams(1);
-                    
-                    out = sqrt(-2 * sigma^2 * log(rand( sampleSize ) ));
-
-               case {'rice', 'rician'}
-                    % START rice HELP START rician HELP
-                    % THE RICE DISTRIBUTION
-                    %
-                    %  (Rician distribution)
-                    %
-                    %  pdf  = besseli(0,y*v/sigma^2).*y/sigma^2.*exp(-(y.^2+v^2)/(2*sigma^2));
-                    %
-                    %  Mean = sigma*sqrt(pi/2)*L;
-                    %  Variance = 2*sigma^2 + v^2 - pi*sigma^2/2*L^2;                   
-                    %    where L = exp(-v^2/(4*sigma^2))*((1+v^2/(2*sigma^2))*besseli(0,v^2/(4*sigma^2)) + v^2/(2*sigma^2)*besseli(1,v^2/(4*sigma^2)));
-                    %
-                    % PARAMETERS:
-                    %   v - noncentrality parameter (v>=0)
-                    %   sigma - scale parameter (sigma>0)
-                    %
-                    % SUPPORT:
-                    %   y,  y > 0 
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % NOTES:
-                    %  1. When v=0 the distribution reduces to a Rayleigh distribution.
-                    %  2. If Y has a Rice distribution with noncentrality parameter v and
-                    %     scale parameter sigma, then (Y/sigma)^2 has a noncentral chi-square
-                    %     distribution with two degrees of freedom and noncentrality parameter
-                    %     (v/sigma)^2
-                    %
-                    %  USAGE:
-                    %   randraw('rice', [v, sigma], sampleSize) - generate sampleSize number
-                    %         of variates from the Rice distribution with noncentrality 
-                    %         parameter 'v' and scale parameter 'sigma';
-                    %   randraw('rice') - help for the Rice distribution;
-                    %
-                    %  EXAMPLES:
-                    %   1.   y = randraw('rice', [0, 1], [1 1e5]);
-                    %   2.   y = randraw('rice', [0.5, 2], 1, 1e5);
-                    %   3.   y = randraw('rice', [1, 3], 1e5 );
-                    %   4.   randraw('rice'); 
-                    %
-                    %  SEE ALSO:
-                    %    RAYLEIGH distribution
-                    % END rice HELP END rician HELP
-
-                    checkParamsNum(funcName, 'Rice', 'rice', distribParams, [2]);
-                    v = distribParams(1);
-                    validateParam(funcName, 'Rice', 'rice', '[v, sigma]', 'v', v, {'>= 0'});
-                    sigma = distribParams(2);
-                    validateParam(funcName, 'Rice', 'rice', '[v, sigma]', 'sigma', sigma, {'> 0'});
-
-                    out = sigma*sqrt(randraw('chisqnc', [(v/sigma)^2, 2], sampleSize));
-
-               case {'semicirc', 'semicircle', 'wigner'}
-                    % START semicirc HELP START semicircle HELP START wigner HELP
-                    % THE SEMICIRCLE DISTRIBUTION
-                    %   ( Wigner semicircle distribution)
-                    %
-                    % The Wigner semicircle distribution, named after the physicist Eugene Wigner, 
-                    % is the probability distribution supported on the interval [m?R, m+R] the graph 
-                    % of whose probability density function is a semicircle of radius R centered at 
-                    % (m, 0) and then suitably normalized (so that it is really a semi-ellipse).
-                    %
-                    %  pdf = 2/(pi*R^2) * sqrt(1-(y-m).^2);
-                    %
-                    %  Mean = m;
-                    %  Variance = R^2/4;
-                    %
-                    %  PARAMETERS:
-                    %    m - location;
-                    %    R - semicircle radius; (R>0)
-                    %
-                    %  SUPPORT:
-                    %    y,  m-R <= y <= m+R
-                    %
-                    %  CLASS:
-                    %    Continuous symmetric distributions
-                    %
-                    %  USAGE:
-                    %   randraw('semicirc', [m, R], sampleSize) - generate sampleSize number
-                    %         of variates from the Semicircle distribution on the interval [m-R, m+R];
-                    %   randraw('semicirc') - help for the Semicircle distribution;
-                    %
-                    %  EXAMPLES:
-                    %   1.   y = randraw('semicirc', [0, 1], [1 1e5]);
-                    %   2.   y = randraw('semicirc', [-1.5, 5], 1, 1e5);
-                    %   3.   y = randraw('semicirc', [2, 10], 1e5 );
-                    %   4.   y = randraw('semicirc', [11, 1], [1e5 1] );
-                    %   5.   randraw('semicirc');                     
-                    % END semicirc HELP END semicircle HELP END wigner HELP
-
-                    checkParamsNum(funcName, 'Semicircle', 'semicirc', distribParams, [2]);
-                    m = distribParams(1);
-                    R = distribParams(2);
-                    validateParam(funcName, 'Semicircle', 'semicirc', '[m, R]', 'R', R, {'> 0'});                                                  
-                    
-                    out = m + R*sqrt(rand(sampleSize)) .* cos( rand(sampleSize)*pi );
-
-               case {'skellam'}
-                    % START skellam HELP
-                    % THE SKELLAM DISTRIBUTION
-                    %
-                    %  The Skellam distribution is the probability distribution of the difference N1 - N2
-                    %  of two uncorrelated random variables N1 and N2 having Poisson distributions
-                    %  with different expected values lambda1 and lambda2.
-                    %  The Skellam probability density function is:
-                    %
-                    %    pdf(n) = exp(-lambda1+lambda2)*(lambda1/lambda2)^(n/2)*besseli(n,2*sqrt(lambda1*lambda2));
-                    %     where besseli is the modified Bessel function of the first kind.
-                    % 
-                    %  Mean = lambda1 - lambda2;
-                    %  Variance = lambda1 + lambda2;
-                    %  Kurtosis = 1/(lambda1 + lambda2);
-                    %  Skewness = (lambda1 - lambda2)/(lambda1 + lambda2)^(3/2);
-                    %
-                    % PARAMETERS:
-                    %   lambda1 >= 0;
-                    %   lambda2 >= 0;
-                    %
-                    % SUPPORT:
-                    %   n = ..., -2, -1, 0, 1, 2, 3 ...
-                    %
-                    % CLASS:
-                    %   Discrete distributions
-                    %
-                    % USAGE:
-                    %   randraw('skellam', [lambda1, lambda2], sampleSize) - generate sampleSize number
-                    %         of variates from the Skellam distribution with parameters
-                    %         lambda1 and lambda2;                   
-                    %   randraw('skellam') - help for the Skellam distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('skellam', [1, 2], [1 1e5]);
-                    %  2.   y = randraw('skellam', [3, 3], 1, 1e5);
-                    %  3.   y = randraw('skellam', [5, 6], 1e5 );
-                    %  4.   y = randraw('skellam', [1.5, 5.6], [1e5 1] );
-                    %  5.   randraw('skellam');     
-                    %
-                    % SEE ALSO:
-                    %   Poisson Distribution ( randraw('po') );                    
-                    % END skellam HELP
-
-
-                    checkParamsNum(funcName, 'Skellam', 'skellam', distribParams, [2]);
-                    lambda1 = distribParams(1);
-                    lambda2 = distribParams(2);
-                    validateParam(funcName, 'Skellam', 'skellam', '[lambda1, lambda2]', 'lambda1', lambda1, {'> 0'});                                                  
-                    validateParam(funcName, 'Skellam', 'skellam', '[lambda1, lambda2]', 'lambda2', lambda2, {'> 0'});    
-                    
-                    poiss1 = feval(funcName,'poisson',lambda1, sampleSize);
-                    out    = feval(funcName,'poisson',lambda2, sampleSize);
-
-                    out = poiss1 - out;
-
-               case {'studentst', 't'} 
-                    % START studentst HELP START t HELP 
-                    % THE STUDENT'S-T DISTRIBUTION
-                    %    ( t-distribution )
-                    %
-                    %  Standard form of Student's-t distribution:
-                    %
-                    %   pdf = gamma((nu+1)/2)/(sqrt(nu*pi)*gamma(nu/2)) *(1+y.^2/nu)^(-(nu+1)/2);
-                    %        or alternatively:
-                    %   pdf = (1+y.^2/nu)^(-(nu+1)/2) / (sqrt(nu)*beta(1/2,nu/2));
-                    %
-                    %   cdf = 1/2 + ( -(y<0) + (y>=0) ) .* ...
-                    %          1/2*betainc( y.^2./(nu+y.^2), 1/2, nu/2 );
-                    %
-                    %  Mean = 0; 
-                    %  Variance = nu/(nu-2);
-                    %  Skewness = 0;
-                    %  Kurtosis = 3*( (nu-2)^2*gamma(nu/2-2)/(4*gamma(nu/2)) - 1 );
-                    %
-                    %  General form of Student's-t distribution:
-                    %
-                    %   pdf = gamma((nu+1)/2)/(sqrt(nu*pi)*gamma(nu/2)) *(1+((y-chi)/eta).^2/nu)^(-(nu+1)/2);
-                    %        or alternatively:
-                    %   pdf = (1+((y-chi)/eta).^2/nu)^(-(nu+1)/2) / (sqrt(nu)*beta(1/2,nu/2));
-                    %
-                    %   cdf = 1/2 + ( -(y<chi) + (y>=chi) ) .* ...
-                    %          1/2*betainc( ((y-chi)/eta).^2./(nu+((y-chi)/eta).^2), 1/2, nu/2 );
-                    %
-                    %  Mean = chi;
-                    %  Variance = nu/(nu-2)*eta^2;  (nu>2)
-                    %  Skewness = 0;
-                    %  Kurtosis = 3*( (nu-2)^2*gamma(nu/2-2)/(4*gamma(nu/2)) - 1 );
-                    %
-                    % PARAMETERS:
-                    %   nu - degrees of freedom (nu = 1, 2, 3, ...)
-                    %   chi - location parameter
-                    %   eta - scale parameter ( eta > 0 )
-                    %
-                    %  SUPPORT:
-                    %   y , -Inf < y < Inf
-                    %
-                    %  CLASS:
-                    %   Continuous symmetric distributions
-                    %
-                    % USAGE:
-                    %   randraw('t', nu, sampleSize) - generate sampleSize number
-                    %         of variates from the standard Student's t-distribution with degrees of
-                    %         freedom 'nu'
-                    %   randraw('t', [nu, chi, eta], sampleSize) - generate sampleSize number
-                    %         of variates from the generalized Student's t-distribution with degrees of
-                    %         freedom 'nu', location 'chi' and scale parameter 'eta'                    
-                    %   randraw('t') - help for the Student's t-distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('t', 3, [1 1e5]);
-                    %  2.   y = randraw('t', [4, -10, 3], 1, 1e5);
-                    %  3.   y = randraw('t', [5, 6.5, 10.5], 1e5 );
-                    %  4.   y = randraw('t', [6, 7, 8], [1e5 1] );
-                    %  5.   randraw('t');                      
-                    % END studentst HELP END t HELP 
-                    
-                    % Method:
-                    %
-                    % If nu<=100 we utilize the following transformation:
-                    %
-                    % Y = X/sqrt(Z/nu) ~ Student's-t(nu),
-                    % where X~Normal(0,1) and Z~Chi^2(nu);
-                    %
-                    % Else, we use Normal(0, 1) instead of Student's-t
-                    %
-                    
-                    checkParamsNum(funcName, 'Student''s'' t', 't', distribParams, [1 3]);
-                    if numel(distribParams)==3
-                         nu = distribParams(1);
-                         chi = distribParams(2);
-                         eta = distribParams(3);
-                         validateParam(funcName, 'Student''s'' t', 't', '[nu, chi, eta]', 'nu', nu, {'> 0','==integer'});                                                  
-                         validateParam(funcName, 'Student''s'' t', 't', '[nu, chi, eta]', 'eta', eta, {'> 0'});
-                    else
-                         nu = distribParams(1);
-                         validateParam(funcName, 'Student''s'' t', 't', 'nu', 'nu', nu, {'> 0','==integer'});                                                                           
-                         chi = 0;
-                         eta = 1;                         
-                    end
-                    
-
-                    if nu <= 100
-                         chisq = feval(funcName, 'chisq', nu, sampleSize);
-                         out = chi + eta * sqrt(nu)*randn( sampleSize ) ./ sqrt( chisq );
-                    else
-                         out = chi + eta * randn( sampleSize );
-                    end
-
-               case {'tri', 'triangular'}
-                    % START tri HELP START triangular HELP
-                    % THE TRIANGULAR DISTRIBUTION
-                    %
-                    %  pdf  = (a <= y & y <= c) .* ( 2*(y-a)/((b-a)*(c-a)) ) + ...
-                    %           (c <  y & y <= b) .* ( 2*(b-y)/((b-a)*(b-c)) ) + ...
-                    %            (y < a | y > b) .* 0;
-                    %
-                    %  cdf =  ( y < a ) .* 0 + ... 
-                    %           (a <= y & y <= c) .* ( (y-a).^2/((b-a)*(c-a)) ) + ...
-                    %           (c <  y & y <= b) .* ( 1- (b-y).^2/((b-a)*(b-c)) ) + ...
-                    %            (y > b) .* 1;
-                    %
-                    %  Mean = 1/3*(a+b+c);
-                    %  Variance = 1/18*(a^2+b^2+c^2-a*b-a*c-b*c);
-                    %  Skewness = sqrt(2)*(a+b-2*c)*(2*a-b-c)*(a-2*b+c) / (5*(a^2+b^2+c^2-a*b-a*c-b*c)^(3/2));
-                    %  Kurtosis = -3/5;
-                    %
-                    %  PARAMETERS:
-                    %    a - lower bound
-                    %    c - mode (c>a)
-                    %    b - upper bound (b>c>a)
-                    %
-                    %  SUPPORT:
-                    %   y, a <= y <= c
-                    %
-                    %  CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % USAGE:
-                    %   randraw('tri', [a, c, b], sampleSize) - generate sampleSize number
-                    %         of variates from the Triangular distribution with parameters
-                    %         'a', 'c' and 'b';
-                    %   randraw('tri') - help for the Triangular distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('tri', [0, 1, 2], [1 1e5]);
-                    %  2.   y = randraw('tri', [1, 10, 20], 1, 1e5);
-                    %  3.   y = randraw('tri', [0.5, 5, 10.5], 1e5 );
-                    %  4.   y = randraw('tri', [2.4, 3.4, 5.4], [1e5 1] );
-                    %  5.   randraw('tri');  
-                    % END tri HELP END triangular HELP
-
-                    checkParamsNum(funcName, 'Triangular', 'tri', distribParams, [3]);
-                    a = distribParams(1);
-                    c = distribParams(2);
-                    b = distribParams(3);
-                    validateParam(funcName, 'Triangular', 'tri', '[a, b, c]', 'c-a', c-a, {'> 0'});
-                    validateParam(funcName, 'Triangular', 'tri', '[a, b, c]', 'b-c', b-c, {'> 0'});
-                    validateParam(funcName, 'Triangular', 'tri', '[a, b, c]', 'b-a', b-a, {'> 0'});
-                    
-                    t = (c-a) / (b-a);
-                    u1 = rand( sampleSize );
-                    out = a + (b-a) * ...
-                         ((u1 <= t) .* sqrt( t*u1 ) + (u1 > t) .* ( 1 - sqrt((1-t)*(1-u1)) ));
-
-               case {'tukeylambda'}
-                    % START tukeylambda HELP
-                    % THE TUKEY-LAMBDA DISTRIBUTION
-                    %
-                    % The Tukey-Lambda Distribution with shape parameter lambda.
-                    %
-                    % The Tukey-Lambda distribution does not have a simple closed form 
-                    % for either the probability density function or the cumulative
-                    % distribution function. The cumulative distribution function is 
-                    % calculated numerically. Some special cases are:
-                    % lambda = -1 - approximately Cauchy;
-                    % lambda = 0 - exactly logistic;
-                    % lambda = 0.14 - approximately normal;
-                    % lambda = 0.5 - U-shaped;
-                    % lambda= 1 - exactly uniform.
-                    %
-                    % PARAMETERS:
-                    %    lambda - shape parameter
-                    %
-                    % SUPPORT: 
-                    %    y,   -1/lambdal <= y <= 1/lambda
-                    %
-                    % CLASS:
-                    %   Continuous symmetric distributions
-                    %
-                    % USAGE:
-                    %   randraw('tukeylambda', lambda, sampleSize) - generate sampleSize number
-                    %         of variates from the Tukey-Lambda distribution with shale parameter 
-                    %         'lambda';
-                    %   randraw('tukeylambda') - help for the Tukey-Lambda distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('tukeylambda', -1, [1 1e5]);
-                    %  2.   y = randraw('tukeylambda', 0, 1, 1e5);
-                    %  3.   y = randraw('tukeylambda', 0.14, 1e5 );
-                    %  4.   y = randraw('tukeylambda', 0.5, [1e5 1] );
-                    %  5.   randraw('tukeylambda');                                 
-                    % END tukeylambda HELP
-                    
-                    checkParamsNum(funcName, 'Tukey-Lambda', 'tukeylambda', distribParams, [1]);
-                    lambda = distribParams(1);
-                    if lambda ~= 0
-                         u = rand( sampleSize );
-                         out = (u.^lambda - (1-u).^lambda) / lambda;
-                    else
-                         out = feval(funcName,'logistic', [0 1], sampleSize);
-                    end
-                    
-               case {'u', 'ushape'}
-                    % START u HELP  START ushape HELP
-                    % THE U DISTRIBUTION
-                    %   ( U-shape distribution )
-                    %
-                    % Standard form of the U distribution:
-                    %
-                    %   pdf(y) = 1./(pi*sqrt(1-y.^2)); -1<=y<=1;
-                    %   cdf(y) = 1/2 + 1/pi*asin(y); -1<=y<=1;
-                    %
-                    %  Mean = 0;
-                    %  Variance = 1/2;
-                    %
-                    % General form of the U distribution:
-                    %
-                    %   pdf(y) = 1./(pi*sqrt(s^2-(y-t).^2));  t-s<=y<=t+s; s>0
-                    %   cdf(y) = 1/2 + 1/pi*asin((y-t)/a); -1<=y<=1;
-                    %
-                    %  Mean = t;
-                    %  Variance = s^2/2;
-                    %
-                    % PARAMETERS:  
-                    %   t - location
-                    %   s -scale; s>0
-                    %
-                    % SUPPORT:      
-                    %   y,   -1 <= y <= 1   - standard U distribution
-                    %    or
-                    %   y,   t-s <= y <= t+s  - generalized U distribution
-                    %
-                    % CLASS:
-                    %   Continuous symmetric distributions
-                    %
-                    % USAGE:
-                    %   randraw('u', [], sampleSize) - generate sampleSize number
-                    %         of variates from standard U distribution;
-                    %   randraw('u', [t, s], sampleSize) - generate sampleSize number
-                    %         of variates from generalized U distribution
-                    %         with location parameter 't' and scale parameter 's';
-                    %   randraw('u') - help for U distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('u', [], [1 1e5]);
-                    %  2.   y = randraw('u', [], 1, 1e5);
-                    %  3.   y = randraw('u', [], 1e5 );
-                    %  4.   y = randraw('u', [10 3], [1e5 1] );
-                    %  5.   randraw('u');
-                    %
-                    % SEE ALSO:
-                    %    ARCSIN distribution                    
-                    % END u HELP END ushape HELP
-                    
-                    checkParamsNum(funcName, 'U', 'u', distribParams, [0, 2]);  
-                    if numel(distribParams)==2
-                         t  = distribParams(1);
-                         s  = distribParams(2);  
-                         validateParam(funcName, 'U', 'u', '[t, s]', 's', s, {'> 0'});
-                    else
-                         t = 0;
-                         s = 1;                        
-                    end   
-                    
-                    out = t + s * sin(pi*(rand(sampleSize)-0.5));
-                    
-               case {'uniform', 'unif'}
-                    % START uniform HELP START unif HELP
-                    % THE UNIFORM DISTRIBUTION
-                    % 
-                    % pdf = 1/(b-a);
-                    % cdf = (y-a)/(b-a);
-                    % 
-                    %  Mean = (a+b)/2;
-                    %  Variance = (b-a)^2/12;
-                    %
-                    % PARAMETERS:
-                    %   a is location of y (lower bound);
-                    %   b is scale of y (upper bound)  (b > a);
-                    %
-                    % SUPPORT:
-                    %   y,  a < y < b
-                    %
-                    % CLASS:
-                    %  Continuous symmetric distributions
-                    %
-                    % USAGE:
-                    %   randraw('uniform', [], sampleSize) - generate sampleSize number
-                    %         of variates from standard Uniform distribution (a=0, b=1);
-                    %   randraw('uniform', [a, b], sampleSize) - generate sampleSize number
-                    %         of variates from the Uniform distribution
-                    %         with parameters 'a' and 'b';
-                    %   randraw('uniform') - help for the Uniform distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('uniform', [], [1 1e5]);
-                    %  2.   y = randraw('uniform', [2, 3], 1, 1e5);
-                    %  3.   y = randraw('uniform', [5, 6], 1e5 );
-                    %  4.   y = randraw('uniform', [10.5, 11.5], [1e5 1] );
-                    %  5.   randraw('uniform');                    
-                    % END uniform HELP END unif HELP
-                    
-                    checkParamsNum(funcName, 'Uniform', 'uniform', distribParams, [0, 2]);  
-                    if numel(distribParams)==2
-                         a  = distribParams(1);
-                         b  = distribParams(2);  
-                         validateParam(funcName, 'Uniform', 'uniform', '[a, b]', 'b-a', b-a, {'> 0'});
-                    else
-                         a = 0;
-                         b = 1;                        
-                    end   
-                    
-                    out = a + (b-a)*rand( sampleSize );
-
-               case {'vonmises'}
-                    % START vonmises HELP
-                    % THE VON MISES DISTRIBUTION
-                    % A continuous distribution defined on the range [0, 2*pi)
-                    % with probability density function:
-                    %
-                    %  pdf(y) = exp(k*cos(y-a)) ./ (2*pi*besseli(0,k));
-                    %
-                    %  where besseli(0,x) is a modified Bessel function of the
-                    %  first kind of order 0.
-                    %  Here,  'a' (a>=0 and a<2*pi) is the mean direction and k > 0 is a
-                    %  concentration parameter
-                    %  The von Mises distribution is the circular analog of the normal
-                    %  distribution on a line.
-                    %
-                    %  Mean = a;
-                    %
-                    %  PARAMETERS:
-                    %    a - location parameter, (a>=0 and a<2*pi)
-                    %    k - shape parameter,  (k>0)
-                    %
-                    %  SUPPORT:
-                    %    y,  -pi < y < pi
-                    %
-                    %  CLASS:
-                    %     Continuous distribution
-                    %
-                    % USAGE:
-                    %   randraw('vonmises', [a, k], sampleSize) - generate sampleSize number
-                    %         of variates from the von Mises distribution with parameters 'a' and 'k';
-                    %   randraw('vonmises') - help for the von Mises distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('vonmises', [pi/2, 3], [1 1e5]);
-                    %  2.   y = randraw('vonmises', [2*pi/3, 2], 1, 1e5);
-                    %  3.   y = randraw('vonmises', [pi/4, 10], 1e5 );
-                    %  4.   y = randraw('vonmises', [pi, 2.2], [1e5 1] );
-                    %  5.   randraw('vonmises');                       
-                    % END vonmises HELP
-                    
-                    %  Method:
-                    %   1) For large k (say, k>700) von Mises distribution tends
-                    %      to a Normal Distribution with variance 1/?
-                    %   2) For a small k we implement method suggested in:
-                    %      L. Yuan and J.D. Kalbleisch, "On the Bessel distribution and
-                    %      related problems," Annals of the Institute of Statistical
-                    %      Mathematics, vol. 52, pp. 438-447, 2000
-                    %      and described in:
-                    %      Luc Devroye, "Simulating Bessel Random Variables,"
-                    %      Statistics and Probability Letters, vol. 57, pp. 249-257, 2002.
-                    %
-
-
-                    a = distribParams(1);
-                    k = distribParams(2);
-
-                    if k > 700
-                         % for large k it tends to a Normal Distribution with variance 1/k
-                         out = a + sqrt(1/k)*randn( sampleSize );
-                    else
-                         % Generate X <- Bessel(0,k)
-                         x = feval(funcName,'bessel', [0 k], sampleSize);
-
-                         % Generate B <- beta(X+1/2, 1/2);
-                         u2 = rand( sampleSize );
-                         l = (x>0);
-                         d1 = (cos(2*pi*u2(l))).^2;
-                         d2 = (cos(pi*u2(~l))).^2;
-                         clear('u2');
-                         t = 2./(2*(x(l)+0.5)-1);
-                         clear('x');
-                         b = zeros( sampleSize );
-                         u1 = rand(sum(l(:)),1);
-                         b(l) = 1 - (1-u1.^t(:)) .* d1(:);
-                         clear('t');
-                         b(~l) = d2;
-                         clear('d1');
-                         clear('d2');
-
-                         % if U < 1/(1+exp(-2*k*sqrt(B))),
-                         %       then return S*acos(sqrt(B))
-                         %       else return S*acos(-sqrt(B))
-                         %     where S is a random sign
-                         l = rand(sampleSize) < 1./(1+exp(-2*k*sqrt(b)));
-                         out = zeros( sampleSize );
-                         out(l) = acos(sqrt(b(l)));
-                         out(~l) = acos(-sqrt(b(~l)));
-                         clear('b');
-                         clear('l');
-
-                         out = a + (2*round(rand(sampleSize))-1) .* out;
-                    end
-
-               case {'wald'}
-                    % START wald HELP
-                    % THE WALD DISTRIBUTION
-                    %
-                    % The Wald distribution is as special case of the Inverse Gaussian Distribution
-                    % where the mean is a constant with the value one.
-                    %
-                    % pdf = sqrt(chi/(2*pi*y^3)) * exp(-chi./(2*y).*(y-1).^2);
-                    %
-                    % Mean     = 1;
-                    % Variance = 1/chi;
-                    % Skewness = sqrt(9/chi);
-                    % Kurtosis = 3+ 15/scale;
-                    %
-                    % PARAMETERS:
-                    %  chi - scale parameter; (chi>0)
-                    %
-                    % SUPPORT:
-                    %  y,  y>0
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % USAGE:
-                    %   randraw('wald', chi, sampleSize) - generate sampleSize number
-                    %         of variates from the Wald distribution with scale parameter 'chi';
-                    %   randraw('wald') - help for the Wald distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('wald', 0.5, [1 1e5]);
-                    %  2.   y = randraw('wald', 1, 1, 1e5);
-                    %  3.   y = randraw('wald', 1.5, 1e5 );
-                    %  4.   y = randraw('wald', 2, [1e5 1] );
-                    %  5.   randraw('wald');                       
-                    % END wald HELP
-                                        
-                    checkParamsNum(funcName, 'Wald', 'wald', distribParams, [1]);
-                    chi = distribParams(1);
-                    validateParam(funcName, 'Wald', 'wald', 'chi', 'chi', chi, {'> 0'});
-                    
-                    out = feval(funcName, 'ig', [1 chi], sampleSize);
-
-               case {'weibull', 'frechet', 'wbl'} 
-                    % START weibull HELP START frechet HELP START wbl HELP
-                    %  THE WEIBULL DISTRIBUTION
-                    %  ( sometimes: Frechet distribution )
-                    % 
-                    %  cdf = 1 - exp(-((y-theta)/beta).^alpha)
-                    %  pdf = alpha / beta * ((y-theta)/beta).^(alpha-1) .* exp(-((y-theta)/beta).^alpha);
-                    %
-                    %  Mean = theta + beta*gamma((alpha+1)/alpha);  
-                    %  Variance = beta^2 * ( gamma((alpha+2)/alpha) - gamma((alpha+1)/alpha)^2 );
-                    %       where gamma is the gamma function
-                    %
-                    % PARAMETERS:
-                    %   theta - location parameter;
-                    %   alpha - shape parameter ( alpha>0 );
-                    %   beta  - scale parameter ( beta>0 );
-                    %
-                    % SUPPORT:
-                    %   y,  y > theta
-                    %
-                    % CLASS:
-                    %   Continuous skewed distributions
-                    %
-                    % NOTES:
-                    %   If alpha=1 , it is the exponential distribution
-                    %   If beta=1; alpha=2, theta=0; it is the standard Rayleigh distribution (sigma=1)
-                    %
-                    % USAGE:
-                    %   randraw('weibull', [theta, alpha, beta], sampleSize) - generate sampleSize number
-                    %         of variates from the Weibull distribution with location parameter 'theta',
-                    %         shape parameter 'alpha' and scale parameter 'beta';
-                    %   randraw('weibull') - help for the Weibull distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('weibull', [-10, 2, 3], [1 1e5]);
-                    %  2.   y = randraw('weibull', [0, 2, 1], 1, 1e5);
-                    %  3.   y = randraw('weibull', [0, 1, 2], 1e5 );
-                    %  4.   y = randraw('weibull', [2.1, 5.4, 10.2], [1e5 1] );
-                    %  5.   randraw('weibull');                        
-                    % END weibull HELP END frechet HELP END wbl HELP
-
-                    checkParamsNum(funcName, 'Weibull', 'weibull', distribParams, [3]);
-                    theta = distribParams(1);
-                    alpha = distribParams(2);
-                    beta  = distribParams(3);
-                    validateParam(funcName, 'Weibull', 'weibull', '[theta, alpha, beta]', 'alpha', alpha, {'> 0'});
-                    validateParam(funcName, 'Weibull', 'weibull', '[theta, alpha, beta]', 'beta', beta, {'> 0'});                    
-                    
-                    out = theta + beta * (-log(rand( sampleSize ))).^(1/alpha);
-
-               case {'yule', 'yulesimon'}
-                    % START yule HELP START yulesimon HELP
-                    % THE YULE-SIMON DISTRIBUTION 
-                    %
-                    %  pmf(y) = (p-1)*beta(y, p); p>1; y = 1, 2, 3, 4, ...
-                    %  cdf(y) = 1-(y+1).*beta(y+1,p);
-                    %
-                    %  Mean = (p-1)/(p-2); for p>2;
-                    %  Variance = (p-1)^2/((p-2)^2*(p-3)); for p>3;
-                    %
-                    %  PARAMETERS:
-                    %    p,  p>1
-                    %
-                    %  SUPPORT:
-                    %    y,  y = 1, 2, 3, 4, ...
-                    %
-                    %  CLASS:
-                    %    Discrete distributions
-                    %
-                    %  NOTES:
-                    %    1. It is named after George Udny Yule and Herbert Simon. 
-                    %       Simon originally called it the Yule distribution.
-                    %    2. The probability mass function pmf(y) has the property that 
-                    %       for sufficiently large y we have
-                    %        pmf(y) = (p-1)*gamma(p)./y.^p;
-                    %       This means that the tail of the Yule-Simon distribution is a 
-                    %       realization of Zipf's law: pmf(y) can be used to model, 
-                    %       for example, the relative frequency of the y'th most frequent 
-                    %       word in a large collection of text, which according to Zipf's law
-                    %       is inversely proportional to a (typically small) power of y.
-                    %  
-                    % USAGE:
-                    %   randraw('yule', p, sampleSize) - generate sampleSize number
-                    %         of variates from the Yule-Simon distribution with parameter 'p';
-                    %   randraw('yule') - help for the Yule-Simon distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('yule', 2, [1 1e5]);
-                    %  2.   y = randraw('yule', 3.2, 1, 1e5);
-                    %  3.   y = randraw('yule', 100.5, 1e5 );
-                    %  4.   y = randraw('yule', 33, [1e5 1] );
-                    %  5.   randraw('yule');                                        
-                    % END yule HELP END yulesimon HELP
-                    
-                    % Rference:
-                    %    Luc Devroye,
-                    %    "Non-Uniform Random Variate Generation,"
-                    %    Springer Verlag, 1986, pages 550-551.
-                    
-                    checkParamsNum(funcName, 'Yule-Simon', 'yule', distribParams, [1]);
-                    p = distribParams(1);
-                    validateParam(funcName, 'Yule-Simon', 'yule', 'p', 'p', p, {'> 1'});
-                                        
-                    out = ceil( log(rand(sampleSize)) ./ log(1-exp(log(rand(sampleSize))/(p-1))) ); 
-                    
-               case {'zeta', 'zipf'}
-                    % START zeta HELP  START zipf HELP
-                    % ZETA DISTRIBUTION
-                    %   (sometimes: Zipf distribution)
-                    %
-                    %  pmf(n) = 1. / (n^a * zeta(a)),
-                    %    where zeta(s) is a Riemann Zeta function:
-                    %         sum from i=1 to Inf of 1/i^a
-                    %    a>1
-                    %        
-                    %  Mean = zeta(a-1)/zeta(a), for a>2
-                    %  Variance = zeta(a-2)/zeta(a) - (zeta(a-1)/zeta(a))^2;
-                    %
-                    % PARAMETERS:  
-                    %   a > 1
-                    %
-                    % SUPPORT:      
-                    %   n = 1, 2, 3, ... (positive integers)
-                    %
-                    % CLASS:
-                    %   Discrete distributions
-                    %
-                    % NOTES:
-                    % The zeta distribution is a long-tailed distribution that is useful for 
-                    % size-frequency data. It is sometimes used in insurance as a model for
-                    % the number of policies held by a single person in an insurance portfolio. 
-                    % It is also used for the analysis of the frequency of words in long 
-                    % sequences of text. When used in linguistics the zeta distribution is 
-                    % known as the Zipf distribution.
-                    %
-                    % USAGE:
-                    %   randraw('zeta', a, sampleSize) - generate sampleSize number
-                    %         of variates from standard Zeta distribution with parameter a;
-                    %   randraw('zeta') - help for Zeta distribution;
-                    %
-                    % EXAMPLES:
-                    %  1.   y = randraw('zeta', 2, [1 1e5]);
-                    %  2.   y = randraw('zeta', 3.5, 1, 1e5);
-                    %  3.   y = randraw('zeta', 10, 1e5 );
-                    %  4.   y = randraw('zeta', 100, [1e5 1] );
-                    %  5.   randraw('zeta');
-                    % END zeta HELP  END zipf HELP                    
-                    
-                    %  Reference:
-                    %    Luc Devroye,
-                    %    "Non-Uniform Random Variate Generation,"
-                    %    Springer Verlag, 1986, pages 550-551.
-
-                    a = distribParams(1);
-
-                    b = 2^(a-1);
-                    am1 = a - 1;
-                    bm1 = b - 1;
-
-                    u1 = rand( sampleSize );
-                    out = floor( u1.^(-1/am1) );
-                    clear('u1');
-                    u2 = rand( sampleSize );
-                    t = ( 1 + 1./out ).^(a-1);
-
-                    indxs = find( u2.*out.*(t-1)/bm1 > t/b );
-
-                    while ~isempty(indxs)
-                         indxsSize = size( indxs );
-                         u1 = rand( indxsSize );
-                         outNew = floor( u1.^(-1/am1) );
-                         clear('u1');
-                         u2 = rand( indxsSize );
-                         t = ( 1 + 1./outNew ).^(a-1);
-
-                         l = u2.*outNew.*(t-1)/bm1 <= t/b;
-
-                         out( indxs(l) ) = outNew(l);
-                         indxs = indxs(~l);
-                    end
-
-               otherwise
-                    fprintf('\n RANDRAW: Unknown distribution name: %s \n', distribName);
-                    
-          end % switch lower( distribNameInner )
-          
-     end % if prod(sampleSize)>0
-
-     varargout{1} = out;
-
-     return;
-
-end % if strcmp(runMode, 'genRun')
-
-return;
-
-
-function checkParamsNum(funcName, distribName, runDistribName, distribParams, correctNum)
-if ~any( numel(distribParams) == correctNum )
-     error('%s Variates Generation:\n %s%s%s%s%s', ...
-          distribName, ...
-          'Wrong numebr of parameters (run ',...
-          funcName, ...
-          '(''', ...
-          runDistribName, ...
-          ''') for help) ');
-end
-return;
-
-
-function validateParam(funcName, distribName, runDistribName, distribParamsName, paramName, param, conditionStr)
-condLogical = 1;
-eqCondStr = [];
-for nn = 1:length(conditionStr)
-     if nn==1
-          eqCondStr = [eqCondStr conditionStr{nn}];
-     else
-          eqCondStr = [eqCondStr ' and ' conditionStr{nn}];          
-     end
-     eqCond = conditionStr{nn}(1:2);
-     eqCond = eqCond(~isspace(eqCond));
-     switch eqCond
-          case{'<'}
-               condLogical = condLogical & (param<str2num(conditionStr{nn}(3:end)));
-          case{'<='}
-               condLogical = condLogical & (param<=str2num(conditionStr{nn}(3:end)));               
-          case{'>'}
-               condLogical = condLogical & (param>str2num(conditionStr{nn}(3:end))); 
-          case{'>='}
-               condLogical = condLogical & (param>=str2num(conditionStr{nn}(3:end)));
-          case{'~='}
-               condLogical = condLogical & (param~=str2num(conditionStr{nn}(3:end)));
-          case{'=='}
-               if strcmp(conditionStr{nn}(3:end),'integer')
-                    condLogical = condLogical & (param==floor(param));                    
-               else
-                    condLogical = condLogical & (param==str2num(conditionStr{nn}(3:end)));
-               end
-     end
-end
-
-if ~condLogical
-     error('%s Variates Generation: %s(''%s'',%s, SampleSize);\n Parameter %s should be %s\n (run %s(''%s'') for help)', ...
-          distribName, ...
-          funcName, ...
-          runDistribName, ...
-          distribParamsName, ...
-          paramName, ...
-          eqCondStr, ...
-          funcName, ...
-          runDistribName);
-end
-return;
-
-function cdf = normcdf(y)
-cdf = 0.5*(1+erf(y/sqrt(2)));
-return;
-
-function pdf = normpdf(y)
-pdf = 1/sqrt(2*pi) * exp(-1/2*y.^2);
-return;
-
-function cdfinv = norminv(y)
-cdfinv = sqrt(2) * erfinv(2*y - 1);
-return;
-
-function out = randFrom5Tbls( P, offset, sampleSize)
-sizeP = length(P);
-
-if sizeP == 0
-     out = [];
-     return;
-end
-
-a = mod(floor([0 P]/16777216), 64);
-na = cumsum( a );
-b = mod(floor([0 P]/262144), 64);
-nb = cumsum( b );
-c = mod(floor([0 P]/4096), 64);
-nc = cumsum( c );
-d = mod(floor([0 P]/64), 64);
-nd = cumsum( d );
-e =  mod([0 P], 64);
-ne = cumsum( e );
-
-AA = zeros(1, na(end));
-BB = zeros(1, nb(end));
-CC = zeros(1, nc(end));
-DD = zeros(1, nd(end));
-EE = zeros(1, ne(end));
-
-t1 = na(end)*16777216;
-t2 = t1 + nb(end)*262144;
-t3 = t2 + nc(end)*4096;
-t4 = t3 + nd(end)*64;
-
-k = (1:sizeP)+offset-1;
-for ii = 1:sizeP
-     AA(na(ii)+(0:a(ii+1))+1) = k(ii);
-     BB(nb(ii)+(0:b(ii+1))+1) = k(ii);
-     CC(nc(ii)+(0:c(ii+1))+1) = k(ii);
-     DD(nd(ii)+(0:d(ii+1))+1) = k(ii);
-     EE(ne(ii)+(0:e(ii+1))+1) = k(ii);
-end
-
-%jj = round(1073741823*rand(sampleSize));
-jj = round(min(sum(P),1073741823) *rand(sampleSize));
-out = zeros(sampleSize);
-N = prod(sampleSize);
-for ii = 1:N
-     if jj(ii) < t1
-          out(ii) = AA( floor(jj(ii)/16777216)+1 );
-     elseif jj(ii) < t2
-          out(ii) = BB(floor((jj(ii)-t1)/262144)+1);
-     elseif jj(ii) < t3
-          out(ii) = CC(floor((jj(ii)-t2)/4096)+1);
-     elseif jj(ii) < t4
-          out(ii) = DD(floor((jj(ii)-t3)/64)+1);
-     else
-          out(ii) = EE(floor(jj(ii)-t4) + 1);
-     end
-end
-
-return;
-
-
-
-
-% Pearsonb type 4
-%http://www-cdf.fnal.gov/publications/cdf6820_pearson4.pdf
-
-
-
-
-
-
-
-
-
-% Lognormal
-% pdf = 1/(y*sigma*sqrt(2*pi)) * exp(-1/2*((log(y)-mu)/sigma)^2)
-% cdf = 1/2*(1 + erf((log(y)-mu)/(sigma*sqrt(2))));
-
-% % Truncated Lognormal
-% N=0;
-% m0 = 0.5 * exp(N*mu + N^2*sigma.^2/2).*(erf((log(b)-mu)./sigma/sqrt(2)-N*sigma/sqrt(2))-erf((log(a)-mu)./sigma/sqrt(2)-N*sigma/sqrt(2)));
-% N=1;
-% m1 = 0.5 * exp(N*mu + N^2*sigma.^2/2).*(erf((log(b)-mu)./sigma/sqrt(2)-N*sigma/sqrt(2))-erf((log(a)-mu)./sigma/sqrt(2)-N*sigma/sqrt(2)));
-% N=2;
-% m2 = 0.5 * exp(N*mu + N^2*sigma.^2/2).*(erf((log(b)-mu)./sigma/sqrt(2)-N*sigma/sqrt(2))-erf((log(a)-mu)./sigma/sqrt(2)-N*sigma/sqrt(2)));
-% 
-% Mean = m1./m0;
-% Variance = m2./m0 - (m1./m0).^2;
-% 
-% PHIl = 1/2*(1 + erf((log(a)-mu)/(sigma*sqrt(2))));
-% PHIr = 1/2*(1 + erf((log(b)-mu)/(sigma*sqrt(2))));
-% out = exp( mu + sigma*( sqrt(2)*erfinv(2*(PHIl+(PHIr-PHIl)*rand(sampleSize))-1) ) );
\ No newline at end of file
diff --git a/Generator/library/readhdf5complex.m b/Generator/library/readhdf5complex.m
deleted file mode 100755
index c27294d..0000000
--- a/Generator/library/readhdf5complex.m
+++ /dev/null
@@ -1,128 +0,0 @@
-function [s,desc]=readhdf5complex(fn)
-% [s,desc]=readhdf5complex(fn)
-% Reads and HDF5 file, consisting of attributes and datasets with as much
-% complexity as is present -- i.e. folders within folders.  Differs from
-% readhdf5both which assumes one layer of structure.
-%
-% Optional output desc holds a list of all the fields as (1) hdf5 names and as
-% (2) field names, (3) data size, (4) isstr and (5) isattribute
-%
-% NOTE: field names with spaces become double underscores, e.g. 
-% 'a b' becomes 'a__b' so it can be legal field name in a structure.
-% writehdf5complex converts double underscores back to spaces.
-% 
-% Updated 04/05/2011 to fix the problem of naming fields of the structure
-% starting with a number, i.e. 35_ngs_wfs_quad, which when attempting to
-% place in a structure will give you an error, because variables or
-% fieldnames cannot start with an integer -  must be an alphanumeric
-% character.  I put an X in front of the name, so now it will return the
-% 35_ngs_wfs_quad info in a field labeled X35_ngs_wfs_quad.  - LAK
-
-global desc ptr currfld
-
-if ~isstruct(fn)
-    if isstr(fn)
-        fn = hdf5info(fn);
-    else
-        error('Input must be a structure or a filename')
-    end
-end
-g=fn.GroupHierarchy;
-desc=cell(100,5);  % leaving room
-ptr=1;
-currfld='.';
-s=proc(g);
-desc=desc(1:ptr-1,:);
-return
-
-%%%%%%%%%%%%%%%%%%%%%%%%
-function s=proc(g)
-%%%%%%%%%%%%%%%%%%%%%%%%
-global desc ptr currfld
-% ATTRIBUTES
-attr=g.Attributes;
-if ~isempty(attr)
-    for i=1:length(attr)
-        a=attr(i);
-        name=nameonly(a.Name);
-        aa=a.Value;
-        if isa(aa,'hdf5.h5string')|isa(aa,'hdf5.h5array')
-            aa=aa.Data;
-        end
-        s.(name) = aa;
-        desc(ptr,:)={a.Name [currfld name] size(aa) isstr(aa) 1};
-        ptr=ptr+1;
-    end
-end
-% DATASETS
-data=g.Datasets;
-if ~isempty(data)
-    for i=1:length(data)
-        d=data(i);
-        name = nameonly(d.Name);
-        dd=hdf5read(d);
-        if isa(dd,'hdf5.h5string')
-            dd=dd.Data;
-            f=find(dd==char(10));
-            if ~isempty(f)
-                dd=reshape(dd,f(1),length(dd)/f(1))';
-                dd=dd(:,1:end-1); % clip off the char(10)'s
-            end
-        elseif isa(dd,'hdf5.h5array')
-            dd=dd.Data;
-        end
-        s.(name) = dd;
-        desc(ptr,:)={d.Name [currfld name] size(dd) isstr(dd) 0};
-        ptr=ptr+1;
-    end
-end
-% GROUPS
-grp=g.Groups;
-if ~isempty(grp)
-    currfld0=currfld;
-    for i=1:length(grp)
-        g=grp(i);
-        name = nameonly(g.Name);
-        currfld=[currfld0 name '.'];
-        try
-            s.(name) = proc( g );
-        catch
-            name = ['X' name];
-            s.(name) = proc( g );
-        end
-    end
-end
-try
-    isstruct(s);
-catch
-    s=struct([]);
-end
-return
-        
-
-%%%%%%%%
-function n = nameonly(nn)
-%%%%%%%%
-% FIND "LAST" NAME
-f=find(nn=='/');
-n=nn((f(end)+1):end);
-% REPLACE SPACES WITH DOUBLE UNDERSCORES __
-f=find(' '==n);
-if ~isempty(f)
-    for i=1:length(f)
-        f=find(' '==n);
-        f0=f(1);
-        n=[n(1:f0-1) '__' n(f0+1:end)];
-    end
-end
-% REPLACE NON-ALPHANUMERICS WITH SINGLE UNDERSCORES
-f=~isalpha(n);
-n(f)='_';
-return
-
-%%%%%%%%%%%%
-function f = isalpha(str)
-%%%%%%%%%%%%
-% returns ones for alphanumerics
-f = (64<str & str<91)|(96<str & str<123)|(47<str & str<58);
-return
diff --git a/Generator/library/rndcheck.m b/Generator/library/rndcheck.m
deleted file mode 100644
index 6255207..0000000
--- a/Generator/library/rndcheck.m
+++ /dev/null
@@ -1,283 +0,0 @@
-function [errorcode, rows, columns] = rndcheck(nargs,nparms,arg1,arg2,arg3,arg4,arg5)
-%RNDCHECK error checks the argument list for the random number generators.
-
-%   Copyright 1993-2002 The MathWorks, Inc. 
-%   $Revision: 2.10 $  $Date: 2002/03/31 22:26:57 $
-
-sizeinfo = nargs - nparms;
-errorcode = 0;
-rows = [];
-columns = [];
-
-if sizeinfo == 0        
-    if nparms == 1
-        [rows columns] = size(arg1);
-    elseif nparms == 2
-        scalararg1 = (prod(size(arg1)) == 1);
-        scalararg2 = (prod(size(arg2)) == 1);
-        if ~scalararg1 & ~scalararg2
-            [r1 c1] = size(arg1);
-            [r2 c2] = size(arg2);
-            if r1 ~= r2 | c1 ~= c2
-                errorcode = 1;
-                return;         
-            end
-        end
-        if ~scalararg1
-            [rows columns] = size(arg1);
-        elseif ~scalararg2
-            [rows columns] = size(arg2);
-        else
-            [rows columns] = size(arg1);
-        end
-    elseif nparms == 3
-        [r1 c1] = size(arg1);
-        [r2 c2] = size(arg2);
-        [r3 c3] = size(arg3);
-        scalararg1 = (prod(size(arg1)) == 1);
-        scalararg2 = (prod(size(arg2)) == 1);
-        scalararg3 = (prod(size(arg3)) == 1);
-        
-        if ~scalararg1 & ~scalararg2
-            if r1 ~= r2 | c1 ~= c2
-                errorcode = 1;
-                return;         
-            end
-        end
-        
-        if ~scalararg1 & ~scalararg3
-            if r1 ~= r3 | c1 ~= c3
-                errorcode = 1;
-                return;                 
-            end
-        end
-        
-        if ~scalararg3 & ~scalararg2
-            if r3 ~= r2 | c3 ~= c2
-                errorcode = 1;
-                return;         
-            end
-        end
-        if ~scalararg1
-            [rows columns] = size(arg1);
-        elseif ~scalararg2
-            [rows columns] = size(arg2);
-        else
-            [rows columns] = size(arg3);
-        end
-    end 
-elseif sizeinfo == 1
-    scalararg1 = (prod(size(arg1)) == 1);
-    if nparms == 1
-        if prod(size(arg2)) ~= 2
-            errorcode = 2;
-            return;
-        end
-        if  ~scalararg1 & arg2 ~= size(arg1)
-            errorcode = 3;
-            return;
-        end
-        if (arg2(1) < 0 | arg2(2) < 0 | arg2(1) ~= round(arg2(1)) | arg2(2) ~= round(arg2(2))),
-            errorcode = 4;
-            return;
-        end 
-        rows    = arg2(1);
-        columns = arg2(2);
-    elseif nparms == 2
-        [r1 c1] = size(arg1);
-        [r2 c2] = size(arg2);
-        if prod(size(arg3)) ~= 2
-            errorcode = 2;
-            return;
-        end
-        scalararg2 = (prod(size(arg2)) == 1);
-        if ~scalararg1 & ~scalararg2
-            if r1 ~= r2 | c1 ~= c2
-                errorcode = 1;
-                return;         
-            end
-        end
-        if (arg3(1) < 0 | arg3(2) < 0 | arg3(1) ~= round(arg3(1)) | arg3(2) ~= round(arg3(2))),
-            errorcode = 4;
-            return;
-        end 
-        if ~scalararg1
-            if any(arg3 ~= size(arg1))
-                errorcode = 3;
-                return;
-            end
-            [rows columns] = size(arg1);
-        elseif ~scalararg2
-            if any(arg3 ~= size(arg2))
-                errorcode = 3;
-                return;
-            end
-            [rows columns] = size(arg2);
-        else
-            rows    = arg3(1);
-            columns = arg3(2);
-        end
-    elseif nparms == 3
-        [r1 c1] = size(arg1);
-        [r2 c2] = size(arg2);
-        [r3 c3] = size(arg3);
-        if prod(size(arg4)) ~= 2
-            errorcode = 2;
-            return;
-        end
-        scalararg1 = (prod(size(arg1)) == 1);
-        scalararg2 = (prod(size(arg2)) == 1);
-        scalararg3 = (prod(size(arg3)) == 1);
-        
-        if (arg4(1) < 0 | arg4(2) < 0 | arg4(1) ~= round(arg4(1)) | arg4(2) ~= round(arg4(2))),
-            errorcode = 4;
-            return;
-        end 
-        
-        if ~scalararg1 & ~scalararg2
-            if r1 ~= r2 | c1 ~= c2
-                errorcode = 1;
-                return;         
-            end
-        end
-        
-        if ~scalararg1 & ~scalararg3
-            if r1 ~= r3 | c1 ~= c3
-                errorcode = 1;
-                return;                 
-            end
-        end
-        
-        if ~scalararg3 & ~scalararg2
-            if r3 ~= r2 | c3 ~= c2
-                errorcode = 1;
-                return;         
-            end
-        end
-        if ~scalararg1
-            if any(arg4 ~= size(arg1))
-                errorcode = 3;
-                return;
-            end
-            [rows columns] = size(arg1);
-        elseif ~scalararg2
-            if any(arg4 ~= size(arg2))
-                errorcode = 3;
-                return;
-            end
-            [rows columns] = size(arg2);
-        elseif ~scalararg3
-            if any(arg4 ~= size(arg3))
-                errorcode = 3;
-                return;
-            end
-            [rows columns] = size(arg3);
-        else
-            rows    = arg4(1);
-            columns = arg4(2);
-        end
-    end 
-elseif sizeinfo == 2
-    if nparms == 1
-        scalararg1 = (prod(size(arg1)) == 1);
-        if ~scalararg1
-            [rows columns] = size(arg1);
-            if rows ~= arg2 | columns ~= arg3 
-                errorcode = 3;
-                return;
-            end
-        end
-        if (arg2 < 0 | arg3 < 0 | arg2 ~= round(arg2) | arg3 ~= round(arg3)),
-            errorcode = 4;
-            return;
-        end 
-        rows = arg2;
-        columns = arg3;
-    elseif nparms == 2
-        [r1 c1] = size(arg1);
-        [r2 c2] = size(arg2);
-        scalararg1 = (prod(size(arg1)) == 1);
-        scalararg2 = (prod(size(arg2)) == 1);
-        if ~scalararg1 & ~scalararg2
-            if r1 ~= r2 | c1 ~= c2
-                errorcode = 1;
-                return;         
-            end
-        end
-        if ~scalararg1
-            [rows columns] = size(arg1);
-            if rows ~= arg3 | columns ~= arg4 
-                errorcode = 3;
-                return;
-            end     
-        elseif ~scalararg2
-            [rows columns] = size(arg2);
-            if rows ~= arg3 | columns ~= arg4 
-                errorcode = 3;
-                return;
-            end     
-        else
-            if (arg3 < 0 | arg4 < 0 | arg3 ~= round(arg3) | arg4 ~= round(arg4)),
-                errorcode = 4;
-                return;
-            end 
-            rows = arg3;
-            columns = arg4;
-        end
-    elseif nparms == 3
-        [r1 c1] = size(arg1);
-        [r2 c2] = size(arg2);
-        [r3 c3] = size(arg3);
-        scalararg1 = (prod(size(arg1)) == 1);
-        scalararg2 = (prod(size(arg2)) == 1);
-        scalararg3 = (prod(size(arg3)) == 1);
-        
-        if ~scalararg1 & ~scalararg2
-            if r1 ~= r2 | c1 ~= c2
-                errorcode = 1;
-                return;         
-            end
-        end
-        
-        if ~scalararg1 & ~scalararg3
-            if r1 ~= r3 | c1 ~= c3
-                errorcode = 1;
-                return;                 
-            end
-        end
-        
-        if ~scalararg3 & ~scalararg2
-            if r3 ~= r2 | c3 ~= c2
-                errorcode = 1;
-                return;         
-            end
-        end
-        
-        if ~scalararg1
-            [rows columns] = size(arg1);
-            if rows ~= arg4 | columns ~= arg5 
-                errorcode = 3;
-                return;
-            end     
-        elseif ~scalararg2
-            [rows columns] = size(arg2);
-            if rows ~= arg4 | columns ~= arg5 
-                errorcode = 3;
-                return;
-            end
-        elseif ~scalararg3
-            [rows columns] = size(arg3);
-            if rows ~= arg4 | columns ~= arg5 
-                errorcode = 3;
-                return;
-            end     
-        else
-            if (arg4 < 0 | arg5 < 0 | arg4 ~= round(arg4) | arg5 ~= round(arg5)),
-                errorcode = 4;
-                return;
-            end 
-            rows    = arg4;
-            columns = arg5;
-        end
-    end 
-end
\ No newline at end of file
diff --git a/Generator/library/sepblockfun.m b/Generator/library/sepblockfun.m
deleted file mode 100755
index 3059f42..0000000
--- a/Generator/library/sepblockfun.m
+++ /dev/null
@@ -1,38 +0,0 @@
-function X=sepblockfun(X,blockdims,fun)
-
-if issparse(X)&& exist('ndSparse','class') && ~isa(X,'ndSparse')
-     X=ndSparse(X);
-end
-if ischar(fun)
-  switch fun
-    case 'max'
-         fun=@(b,d) max(b,[],d);
-    case 'min'
-         fun=@(b,d) min(b,[],d);
-    case 'sum'
-         fun=@sum;
-    case 'mean'
-         fun=@mean;
-    case 'prod'
-        fun=@prod;
-    otherwise
-     error 'Unrecognized fun() selection'
-  end
-end
-
-nn=max(length(blockdims),ndims(X));
-blockdims(end+1:nn)=1;
-
-[sz{1:nn}]=size(X); %M is the original array
-sz=[sz{:}];
-
-idx=~isfinite(blockdims);
-blockdims(idx)=sz(idx);
-
-newdims=(sz./blockdims);
-args=(num2cell([blockdims;newdims]));
-X=reshape(X,args{:});
-for ii=1:nn
- X=fun(X,2*ii-1);
-end
-X=reshape(X,newdims);
\ No newline at end of file
diff --git a/Generator/library/shiftd.m b/Generator/library/shiftd.m
deleted file mode 100755
index 7313793..0000000
--- a/Generator/library/shiftd.m
+++ /dev/null
@@ -1,75 +0,0 @@
-function y = shiftd(A,column,shift,type)
-
-%    PURPOSE:
-%  --------
-%  y = shiftd (A, column, shift) moves #column of matrix A downwards
-%                                   by #shift positions. 
-% 
-%  INPUT ARGUMENTS:
-%  ----------------
-%  'A' is the input matrix. ('A' can be a vector)
-%
-%  'column' is the number of the column to be shifted. If 'column'
-%  is zero, then all columns in the matrix are shifted.
-%
-%  'shift' is the number of positions by which the column is shifted
-%  downwards.
-%
-%  'type' is an optional argument.
-%
-%         The shifted matrix-elements are discarded if this argument
-%         is 0 or is omitted,
-%         then vacated spaces at the top are filled with zeroes.
-%
-%         The shifted matrix-elements are retained if 'type' is 1
-%         or any other non-zero value,
-%         then vacated spaces at the top are filled with the
-%         shifted column-elements from the bottom (i.e. "wraparound").
-%
-%  EXAMPLES:   A = [1 2 3;
-%                   4 5 6;
-%                   7 8 9]
-%              y = shiftd(A,0,1)   --> [0 0 0;
-%                                       1 2 3;
-%                                       4 5 6]
-%              y = shiftd(A,2,1)   --> [1 0 3;
-%                                       4 2 6;
-%                                       7 5 9]
-%              y = shiftd(A,2,1,0) --> [1 0 3;
-%                                       4 2 6;
-%                                       7 5 9]
-%              y = shiftd(A,2,1,1) --> [1 8 3;
-%                                       4 2 6;
-%                                       7 5 9]
-%              y = shiftd(A,0,1,1) --> [7 8 9;
-%                                       1 2 3;
-%                                       4 5 6]
-%             
-%              B = [1;       z = shiftd(B,1,3) --> [0;
-%                   2;                              0;
-%                   3;                              0;
-%                   4;                              1;
-%                   5]                              2]
-%
-%  SEE ALSO:  shiftl, shiftr, shiftu.
-
-[M,N] = size(A);
-if column > N | column < 0, error('Invalid Column'); end
-if shift < 0, error('Negative shift value - use "shiftu" instead'); end
-if shift > M, error('Shift value exceeds number of rows'); end
-
-if column == 0
-   if nargin == 4 & type ~= 0
-      A = [A(M-shift+1:M,:); A(1:M-shift,:)];
-   else
-      A = [zeros(shift,N); A(1:M-shift,:)];
-   end
-else
-   if nargin == 4 & type ~= 0
-      A(:,column) = [A(M-shift+1:M,column); A(1:M-shift,column)];
-   else
-      A(:,column) = [zeros(shift,1); A(1:M-shift,column)];
-   end
-end
-y = A;
-
diff --git a/Generator/library/shiftl.m b/Generator/library/shiftl.m
deleted file mode 100755
index b7fa64a..0000000
--- a/Generator/library/shiftl.m
+++ /dev/null
@@ -1,66 +0,0 @@
-function y = shiftl(A,row,shift,type)
-
-%   PURPOSE:
-%  --------
-%  y = shiftl (A, row, shift) moves #row of matrix A to the left 
-%                                by #shift positions.
-% 
-%  INPUT ARGUMENTS:
-%  ----------------
-%  'A' is the input matrix. ('A' can be a vector)
-%  
-%  'row' is the number of the row to be shifted. If 'row' is zero,
-%  then all rows in the matrix are shifted.
-%
-%  'shift' is the number of positions by which the row is shifted
-%  to the right.
-%
-%  'type' is an optional argument.
-%
-%         The shifted matrix-elements are discarded if this argument
-%         is 0 or is omitted,
-%         then vacated spaces to the right are filled with zeros.
-%  
-%         The shifted matrix-elements are retained if 'type' is 1 
-%         or any other non-zero value,
-%         then vacated spaces to the right are filled with the shifted
-%         row-elements from the left (i.e. "wraparound").
-%
-%  EXAMPLES:   A = [1 2 3 4 5;
-%  ---------        6 7 8 9 0]
-%
-%              y = shiftl(A,0,2)   --> [3 4 5 0 0;
-%                                       8 9 0 0 0]
-%              y = shiftl(A,1,2)   --> [3 4 5 0 0;
-%                                       6 7 8 9 0]
-%              y = shiftl(A,1,2,0) --> [3 4 5 0 0;
-%                                       6 7 8 9 0]
-%              y = shiftl(A,1,2,1) --> [3 4 5 1 2;
-%                                       6 7 8 9 0]
-%              y = shiftl(A,0,2,1) --> [3 4 5 1 2;
-%                                       8 9 0 6 7]
-%              B = [1 2 3 4 5]
-% 
-%              z = shiftl(B,1,3)   --> [4 5 0 0 0]
-%
-%  SEE ALSO:  shiftr, shiftu, shiftd.
-
-[M,N] = size(A);
-if row > M | row < 0, error('Invalid Row'); end
-if shift < 0, error('Negative shift value - use "shiftr" instead'); end
-if shift > N, error('Shift value exceeds number of columns'); end
-
-if row == 0
-   if nargin == 4 & type ~= 0
-      A = [A(:,1+shift:N) A(:,1:shift)];
-   else
-      A = [A(:,1+shift:N) zeros(M,shift)];
-   end
-else
-   if nargin == 4 & type ~= 0
-      A(row,:) = [A(row,1+shift:N) A(row,1:shift)]; 
-   else
-      A(row,:) = [A(row,1+shift:N) zeros(1,shift)];
-   end
-end
-y = A;
diff --git a/Generator/library/shiftr.m b/Generator/library/shiftr.m
deleted file mode 100755
index 4b9370c..0000000
--- a/Generator/library/shiftr.m
+++ /dev/null
@@ -1,66 +0,0 @@
-function y = shiftr(A,row,shift,type)
-
-%  PURPOSE:
-%  --------
-%  y = shiftr (A, row, shift) moves #row of matrix A to the right
-%                                 by #shift positions. 
-% 
-%  INPUT ARGUMENTS:
-%  ----------------
-%  'A' is the input matrix. ('A' can be a vector)
-%
-%  'row' is the number of the row to be shifted. If 'row' is zero,
-%  then all rows in the matrix are shifted.
-%
-%  'shift' is the number of positions by which the row is shifted
-%  to the right.
-%
-%  'type' is an optional argument.
-%
-%         The shifted matrix-elements are discarded if this argument 
-%         is 0 or is omitted,
-%         then vacated spaces to the left are filled with zeroes.
-%  
-%         The shifted matrix-elements are retained if 'type' is 1 
-%         or any other non-zero value,
-%         then vacated spaces to the left are filled with the shifted
-%         row-elements from the right (i.e. "wraparound").
-%
-%  EXAMPLES:   A = [1 2 3 4 5;
-%  ---------        6 7 8 9 0]
-%
-%              y = shiftr(A,0,2)   --> [0 0 1 2 3;
-%                                       0 0 6 7 8]
-%              y = shiftr(A,1,2)   --> [0 0 1 2 3;
-%                                       6 7 8 9 0]
-%              y = shiftr(A,1,2,0) --> [0 0 1 2 3;
-%                                       6 7 8 9 0]
-%              y = shiftr(A,1,2,1) --> [4 5 1 2 3;
-%                                       6 7 8 9 0]
-%              y = shiftr(A,0,2,1) --> [4 5 1 2 3;
-%                                       9 0 6 7 8]
-%              B = [1 2 3 4 5]
-%
-%              z = shiftr(B,1,3)   --> [0 0 0 1 2]
-%
-%  SEE ALSO:  shiftl, shiftu, shiftd.
-
-[M,N] = size(A);
-if row > M | row < 0, error('Invalid Row'); end
-if shift < 0, error('Negative shift value - use "shiftl" instead'); end
-if shift > N, error('Shift value exceeds number of columns'); end
-
-if row == 0
-   if nargin == 4 & type ~= 0
-      A = [A(:,N-shift+1:N)  A(:,1:N-shift)];
-   else
-      A = [zeros(M,shift) A(:,1:N-shift)];
-   end
-else
-   if nargin == 4 & type ~= 0
-      A(row,:) = [A(row,N-shift+1:N)  A(row,1:N-shift)];
-   else
-      A(row,:) = [zeros(1,shift) A(row,1:N-shift)];
-   end
-end
-y = A;
diff --git a/Generator/library/shiftu.m b/Generator/library/shiftu.m
deleted file mode 100755
index 5d8e420..0000000
--- a/Generator/library/shiftu.m
+++ /dev/null
@@ -1,75 +0,0 @@
-function y = shiftu(A,column,shift,type)
-
-%   PURPOSE:
-%  --------
-%  y = shiftu (A, column, shift) moves #column of matrix A upwards
-%                                    by #shift positions.
-%
-%  INPUT ARGUMENTS:
-%  ----------------
-%  'A' is the input matrix. ('A' can be a vector)
-%
-%  'column' is the number of the column to be shifted. If 'column'
-%  is zero, then all columns in the matrix are shifted.
-%
-%  'shift' is the number of positions by which the column is shifted
-%  vertically.
-%
-%  'type' is an optional argument.
-%
-%         The shifted matrix-elements are discarded if this argument
-%         is 0 or is omitted,
-%         then vacated spaces on the bottom are filled with zeroes.
-%
-%         The shifted matrix-elements are retained if 'type' is 1
-%         or any other non-zero value,
-%         then vacated spaces on the bottom are filled with the
-%         shifted column-elements from the top (i.e. "wraparound").
-%
-%  EXAMPLES:   A = [1 2 3;
-%  ---------        4 5 6;
-%                   7 8 9]
-%
-%              y = shiftu(A,0,1)   --> [4 5 6;
-%                                       7 8 9;
-%                                       0 0 0]
-%              y = shiftu(A,2,1)   --> [1 5 3;
-%                                       4 8 6;
-%                                       7 0 9]
-%              y = shiftu(A,2,1,0) --> [1 5 3;
-%                                       4 8 6;
-%                                       7 0 9]
-%              y = shiftu(A,2,1,1) --> [1 5 3;
-%                                       4 8 6;
-%                                       7 2 9]
-%              y = shiftu(A,0,1,1) --> [4 5 6;
-%                                       7 8 9;
-%                                       1 2 3]
-%
-%              B = [1;       z = shiftu(B,1,3) --> [4;
-%                   2;                              5;
-%                   3;                              0;
-%                   4;                              0;
-%                   5]                              0]
-%
-%  SEE ALSO:  shiftl, shiftr, shiftd.
-
-[M,N] = size(A);
-if column > N | column < 0, error('Invalid Column'); end
-if shift < 0, error('Negative shift value - use "shiftd" instead'); end
-if shift > M, error('Shift value exceeds number of rows'); end
-
-if column == 0
-   if nargin == 4 & type ~= 0
-       A = [A(1+shift:M,:); A(1:shift,:)];
-   else
-       A = [A(1+shift:M,:); zeros(shift,N)];
-    end
-else
-   if nargin == 4 & type ~= 0
-      A(:,column) = [A(1+shift:M, column); A(1:shift, column)];
-   else
-      A(:,column) = [A(1+shift:M, column); zeros(shift,1)];
-   end
-end
-y = A;
diff --git a/Generator/library/sm_centroid.m b/Generator/library/sm_centroid.m
deleted file mode 100644
index 8b64d04..0000000
--- a/Generator/library/sm_centroid.m
+++ /dev/null
@@ -1,33 +0,0 @@
-function vecs = sm_centroid(im,T)
-
-% c = sm_centroid(im,T)
-%    Computes the centroid of 2D array im with respect to the center
-%    of the array
-
-if nargin==1;T=0;end
-v = zeros(2,size(im,3));
-s = size(im(:,:,1));   
-[x y] = meshgrid(1:s(2),1:s(1));
-
-mdim    = size(im,1);
-icen    = mdim/2;
-mask    = ones(mdim);
-
-%** calculate the centroids 
-pix_num  = -mdim/2:1:(mdim-1)/2; 
-vecs = zeros(2,size(im,3));
-for k=1:size(im,3)
-    if T>0
-        frm = im(:,:,k);
-        idx=find(im(:,:,k)<T.*max(frm(:)));
-        mask=zeros(mdim);mask(idx)=1.0;                
-    end
-    
-    img1_sum = sum(im(:,:,k).*mask,1);
-    img2_sum = sum(im(:,:,k).*mask,2);
-    c(2) = -sum(pix_num.*img1_sum)/sum(img1_sum);
-    c(1) = -sum(pix_num*img2_sum)/sum(img2_sum);
-    vecs(:,k) = [ c(1) c(2) ]';
-    
-end
-
diff --git a/Generator/library/sub_modes.m b/Generator/library/sub_modes.m
deleted file mode 100755
index 6d8b4bd..0000000
--- a/Generator/library/sub_modes.m
+++ /dev/null
@@ -1,30 +0,0 @@
-function [ phasep, zc ] = sub_modes(phase_maps,Zmodes,Zfrac,z_basis,mask)
-
-% subtract of zernike modes from a phase screen
-% 
-% [ phasep, coeff ] = sub_modes( phases, Zmodes, Zfrac, Zbasis )
-%
-if nargin == 4
-    mask = ones(size(phase_maps,1),size(phase_maps,2));
-end
-
-phasep      = zeros(size(phase_maps));
-phi_energy  = zeros(Zmodes,size(phase_maps,3));
-zc          = zeros(Zmodes,size(phase_maps,3));
-
-for k=1:size(phase_maps,3)
-    tmp     = phase_maps(:,:,k);
-    for q=1:Zmodes
-        c_q      = sum(sum(mask.*(tmp.*z_basis(:,:,q))));
-        c_area   = sum(sum(mask.*(z_basis(:,:,q)).^2));
-        a(q)        = c_q/c_area;  
-        zc(q,k)     = a(q);
-         amp         = a(q);% c_q/c_area; 
-      
-        if (q <= Zmodes)
-            tmp     = tmp - Zfrac*amp.*(mask.*z_basis(:,:,q));   
-        end      
-    %    tmp=tmp.*pupil_mask;
-    end  
-    phasep(:,:,k) = tmp.*z_basis(:,:,1);  
-end
diff --git a/Generator/library/tight_subplot.m b/Generator/library/tight_subplot.m
deleted file mode 100644
index 73e0d1f..0000000
--- a/Generator/library/tight_subplot.m
+++ /dev/null
@@ -1,66 +0,0 @@
-function [ha, pos] = tight_subplot(Nh, Nw, gap, marg_h, marg_w)
-
-% tight_subplot creates "subplot" axes with adjustable gaps and margins
-%
-% [ha, pos] = tight_subplot(Nh, Nw, gap, marg_h, marg_w)
-%
-%   in:  Nh      number of axes in hight (vertical direction)
-%        Nw      number of axes in width (horizontaldirection)
-%        gap     gaps between the axes in normalized units (0...1)
-%                   or [gap_h gap_w] for different gaps in height and width 
-%        marg_h  margins in height in normalized units (0...1)
-%                   or [lower upper] for different lower and upper margins 
-%        marg_w  margins in width in normalized units (0...1)
-%                   or [left right] for different left and right margins 
-%
-%  out:  ha     array of handles of the axes objects
-%                   starting from upper left corner, going row-wise as in
-%                   subplot
-%        pos    positions of the axes objects
-%
-%  Example: ha = tight_subplot(3,2,[.01 .03],[.1 .01],[.01 .01])
-%           for ii = 1:6; axes(ha(ii)); plot(randn(10,ii)); end
-%           set(ha(1:4),'XTickLabel',''); set(ha,'YTickLabel','')
-
-% Pekka Kumpulainen 21.5.2012   @tut.fi
-% Tampere University of Technology / Automation Science and Engineering
-
-
-if nargin<3; gap = .02; end
-if nargin<4 || isempty(marg_h); marg_h = .05; end
-if nargin<5; marg_w = .05; end
-
-if numel(gap)==1; 
-    gap = [gap gap];
-end
-if numel(marg_w)==1; 
-    marg_w = [marg_w marg_w];
-end
-if numel(marg_h)==1; 
-    marg_h = [marg_h marg_h];
-end
-
-axh = (1-sum(marg_h)-(Nh-1)*gap(1))/Nh; 
-axw = (1-sum(marg_w)-(Nw-1)*gap(2))/Nw;
-
-py = 1-marg_h(2)-axh; 
-
-% ha = zeros(Nh*Nw,1);
-ii = 0;
-for ih = 1:Nh
-    px = marg_w(1);
-    
-    for ix = 1:Nw
-        ii = ii+1;
-        ha(ii) = axes('Units','normalized', ...
-            'Position',[px py axw axh], ...
-            'XTickLabel','', ...
-            'YTickLabel','');
-        px = px+axw+gap(2);
-    end
-    py = py-axh-gap(1);
-end
-if nargout > 1
-    pos = get(ha,'Position');
-end
-ha = ha(:);
diff --git a/Generator/library/upsample_data2newgrid.m b/Generator/library/upsample_data2newgrid.m
deleted file mode 100644
index ccbbf58..0000000
--- a/Generator/library/upsample_data2newgrid.m
+++ /dev/null
@@ -1,26 +0,0 @@
-function [ new_pupil_mask, new_pupil_amp, gg2, dm2 ] = upsample_data2newgrid(native_grid_sz, PupilDiam1,PupilDiam2, gg, dm, br_factor  )
-
-% [ new_pupil_mask, new_pupil_amp, gg2, dm2 ] = upsample_data2newgrid( native_grid_sz, PupilDiam1,PupilDiam2, g, dm, br_factor  )
-%
-%
-grid_sz = native_grid_sz*br_factor;
-
-newPupil_Diam1 = br_factor*PupilDiam1;
-newPupil_Diam2 = br_factor*PupilDiam2;
-c1=circle(grid_sz,newPupil_Diam1);
-c2=circle(grid_sz,newPupil_Diam2);
-new_pupil_mask = c1-c2;
-
-g_sz0       = size(gg,1);
-g_pad_sz    = (br_factor.*g_sz0  - g_sz0 )/2;
-gg2          = padarray(gg,[g_pad_sz g_pad_sz],0,'both');
-
-dm2         = padarray(dm,[g_pad_sz g_pad_sz],0,'both');
-
-
-new_pupil_amp  = new_pupil_mask./max(new_pupil_mask(:));
-new_pupil_amp   = ( grid_sz.*new_pupil_amp )./sqrt(sum(sum(new_pupil_amp.^2)));
-a = ifft2(new_pupil_amp); h = abs(a).^2;
-fprintf('INFO: PSF computed on grid size %4.0f x %4.0f has volume %4.0f \n',size(new_pupil_amp,1),size(new_pupil_amp,2),sum(h(:)));
-
- 
diff --git a/Generator/library/xpadarray.m b/Generator/library/xpadarray.m
deleted file mode 100755
index 3bcfcf2..0000000
--- a/Generator/library/xpadarray.m
+++ /dev/null
@@ -1,29 +0,0 @@
-function [ out_arr ] = padarray(arr,pad_dim,where,where2)
-
-if  nargin > 3 | strcmpi(where,'both')
-    nslices = size(arr,3);
-    ndim = pad_dim(1) + size(arr,1) + pad_dim(2);
-    ndim2 = size(arr,1);
-    out_arr = zeros(ndim,ndim,nslices);
-    for kk=1:nslices
-        out_arr(pad_dim(1)+1:(pad_dim(1)+1 + ndim2-1),pad_dim(1)+1:(pad_dim(1)+1 + ndim2-1),kk) = arr(:,:,kk);
-    end
-end
-%  phasek_pad = padarray(padarray(phasek, pad_size_pre, 'pre'), pad_size_post, 'post');
-nslices = size(arr,3);
-if strcmpi(where,'pre')   
-        out_arr = zeros( size(arr,1) + pad_dim(1),size(arr,2) + pad_dim(2),nslices);
-        for kk=1:nslices
-            out_arr(pad_dim+1:end,pad_dim+1:end,kk) = arr(:,:,kk);
-        end        
-end
-if strcmpi(where,'post')
-    out_arr = zeros( size(arr,1) + pad_dim(1),size(arr,2) + pad_dim(2),nslices);
-    for kk=1:nslices 
-        out_arr(1:size(arr,1),1:size(arr,2),kk) = arr(:,:,kk);
-    end
-end
-
-
-end
-
diff --git a/Generator/library/zernfun.m b/Generator/library/zernfun.m
deleted file mode 100755
index 2f415f1..0000000
--- a/Generator/library/zernfun.m
+++ /dev/null
@@ -1,194 +0,0 @@
-function z = zernfun(n,m,r,theta,nflag)
-%ZERNFUN Zernike functions of order N and frequency M on the unit circle.
-%   Z = ZERNFUN(N,M,R,THETA) returns the Zernike functions of order N
-%   and angular frequency M, evaluated at positions (R,THETA) on the
-%   unit circle.  N is a vector of positive integers (including 0), and
-%   M is a vector with the same number of elements as N.  Each element
-%   k of M must be a positive integer, with possible values M(k) = -N(k)
-%   to +N(k) in steps of 2.  R is a vector of numbers between 0 and 1,
-%   and THETA is a vector of angles.  R and THETA must have the same
-%   length.  The output Z is a matrix with one column for every (N,M)
-%   pair, and one row for every (R,THETA) pair.
-%
-%   Z = ZERNFUN(N,M,R,THETA,'norm') returns the normalized Zernike
-%   functions.  The normalization factor sqrt((2-delta(m,0))*(n+1)/pi),
-%   with delta(m,0) the Kronecker delta, is chosen so that the integral
-%   of (r * [Znm(r,theta)]^2) over the unit circle (from r=0 to r=1,
-%   and theta=0 to theta=2*pi) is unity.  For the non-normalized
-%   polynomials, max(Znm(r=1,theta))=1 for all [n,m].
-%
-%   The Zernike functions are an orthogonal basis on the unit circle.
-%   They are used in disciplines such as astronomy, optics, and
-%   optometry to describe functions on a circular domain.
-%
-%   The following table lists the first 15 Zernike functions.
-%
-%       n    m    Zernike function             Normalization
-%       ----------------------------------------------------
-%       0    0    1                              1/sqrt(pi)
-%       1    1    r * cos(theta)                 2/sqrt(pi)
-%       1   -1    r * sin(theta)                 2/sqrt(pi)
-%       2    2    r^2 * cos(2*theta)             sqrt(6/pi)
-%       2    0    (2*r^2 - 1)                    sqrt(3/pi)
-%       2   -2    r^2 * sin(2*theta)             sqrt(6/pi)
-%       3    3    r^3 * cos(3*theta)             sqrt(8/pi)
-%       3    1    (3*r^3 - 2*r) * cos(theta)     sqrt(8/pi)
-%       3   -1    (3*r^3 - 2*r) * sin(theta)     sqrt(8/pi)
-%       3   -3    r^3 * sin(3*theta)             sqrt(8/pi)
-%       4    4    r^4 * cos(4*theta)             sqrt(10/pi)
-%       4    2    (4*r^4 - 3*r^2) * cos(2*theta) sqrt(10/pi)
-%       4    0    6*r^4 - 6*r^2 + 1              sqrt(5/pi)
-%       4   -2    (4*r^4 - 3*r^2) * sin(2*theta) sqrt(10/pi)
-%       4   -4    r^4 * sin(4*theta)             sqrt(10/pi)
-%       ----------------------------------------------------
-%
-%   Example 1:
-%
-%       % Display the Zernike function Z(n=5,m=1)
-%       x = -1:0.01:1;
-%       [X,Y] = meshgrid(x,x);
-%       [theta,r] = cart2pol(X,Y);
-%       idx = r<=1;
-%       z = nan(size(X));
-%       z(idx) = zernfun(5,1,r(idx),theta(idx));
-%       figure
-%       pcolor(x,x,z), shading interp
-%       axis square, colorbar
-%       title('Zernike function Z_5^1(r,\theta)')
-%
-%   Example 2:
-%
-%       % Display the first 10 Zernike functions
-%       x = -1:0.01:1;
-%       [X,Y] = meshgrid(x,x);
-%       [theta,r] = cart2pol(X,Y);
-%       idx = r<=1;
-%       z = nan(size(X));
-%       n = [0  1  1  2  2  2  3  3  3  3];
-%       m = [0 -1  1 -2  0  2 -3 -1  1  3];
-%       Nplot = [4 10 12 16 18 20 22 24 26 28];
-%       y = zernfun(n,m,r(idx),theta(idx));
-%       figure('Units','normalized')
-%       for k = 1:10
-%           z(idx) = y(:,k);
-%           subplot(4,7,Nplot(k))
-%           pcolor(x,x,z), shading interp
-%           set(gca,'XTick',[],'YTick',[])
-%           axis square
-%           title(['Z_{' num2str(n(k)) '}^{' num2str(m(k)) '}'])
-%       end
-%
-%   See also ZERNPOL, ZERNFUN2.
-
-%   Paul Fricker 2/28/2012
-
-% Check and prepare the inputs:
-% -----------------------------
-if ( ~any(size(n)==1) ) || ( ~any(size(m)==1) )
-    error('zernfun:NMvectors','N and M must be vectors.')
-end
-
-if length(n)~=length(m)
-    error('zernfun:NMlength','N and M must be the same length.')
-end
-
-n = n(:);
-m = m(:);
-if any(mod(n-m,2))
-    error('zernfun:NMmultiplesof2', ...
-          'All N and M must differ by multiples of 2 (including 0).')
-end
-
-if any(m>n)
-    error('zernfun:MlessthanN', ...
-          'Each M must be less than or equal to its corresponding N.')
-end
-
-if any( r>1 | r<0 )
-    error('zernfun:Rlessthan1','All R must be between 0 and 1.')
-end
-
-if ( ~any(size(r)==1) ) || ( ~any(size(theta)==1) )
-    error('zernfun:RTHvector','R and THETA must be vectors.')
-end
-
-r = r(:);
-theta = theta(:);
-length_r = length(r);
-if length_r~=length(theta)
-    error('zernfun:RTHlength', ...
-          'The number of R- and THETA-values must be equal.')
-end
-
-% Check normalization:
-% --------------------
-if nargin==5 && ischar(nflag)
-    isnorm = strcmpi(nflag,'norm');
-    if ~isnorm
-        error('zernfun:normalization','Unrecognized normalization flag.')
-    end
-else
-    isnorm = false;
-end
-
-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-% Compute the Zernike Polynomials
-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-
-% Determine the required powers of r:
-% -----------------------------------
-m_abs = abs(m);
-rpowers = [];
-for j = 1:length(n)
-    rpowers = [rpowers m_abs(j):2:n(j)];
-end
-rpowers = unique(rpowers);
-
-% Pre-compute the values of r raised to the required powers,
-% and compile them in a matrix:
-% -----------------------------
-if rpowers(1)==0
-    rpowern = arrayfun(@(p)r.^p,rpowers(2:end),'UniformOutput',false);
-    rpowern = cat(2,rpowern{:});
-    rpowern = [ones(length_r,1) rpowern];
-else
-    rpowern = arrayfun(@(p)r.^p,rpowers,'UniformOutput',false);
-    rpowern = cat(2,rpowern{:});
-end
-
-% Compute the values of the polynomials:
-% --------------------------------------
-z = zeros(length_r,length(n));
-for j = 1:length(n)
-    s = 0:(n(j)-m_abs(j))/2;
-    pows = n(j):-2:m_abs(j);
-    for k = length(s):-1:1
-        p = (1-2*mod(s(k),2))* ...
-                   prod(2:(n(j)-s(k)))/              ...
-                   prod(2:s(k))/                     ...
-                   prod(2:((n(j)-m_abs(j))/2-s(k)))/ ...
-                   prod(2:((n(j)+m_abs(j))/2-s(k)));
-        idx = (pows(k)==rpowers);
-        z(:,j) = z(:,j) + p*rpowern(:,idx);
-    end
-    
-    if isnorm
-        z(:,j) = z(:,j)*sqrt((1+(m(j)~=0))*(n(j)+1)/pi);
-    end
-end
-% END: Compute the Zernike Polynomials
-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-
-% Compute the Zernike functions:
-% ------------------------------
-idx_pos = m>0;
-idx_neg = m<0;
-
-if any(idx_pos)
-    z(:,idx_pos) = z(:,idx_pos).*cos(theta*m_abs(idx_pos)');
-end
-if any(idx_neg)
-    z(:,idx_neg) = z(:,idx_neg).*sin(theta*m_abs(idx_neg)');
-end
-
-% EOF zernfun
\ No newline at end of file
diff --git a/Generator/library/zernfun2.m b/Generator/library/zernfun2.m
deleted file mode 100755
index 0674cb0..0000000
--- a/Generator/library/zernfun2.m
+++ /dev/null
@@ -1,76 +0,0 @@
-function z = zernfun2(p,r,theta,nflag)
-%ZERNFUN2 Single-index Zernike functions on the unit circle.
-%   Z = ZERNFUN2(P,R,THETA) returns the Pth Zernike functions evaluated
-%   at positions (R,THETA) on the unit circle.  P is a vector of positive
-%   integers between 0 and 35, R is a vector of numbers between 0 and 1,
-%   and THETA is a vector of angles.  R and THETA must have the same
-%   length.  The output Z is a matrix with one column for every P-value,
-%   and one row for every (R,THETA) pair.
-%
-%   Z = ZERNFUN2(P,R,THETA,'norm') returns the normalized Zernike
-%   functions, defined such that the integral of (r * [Zp(r,theta)]^2)
-%   over the unit circle (from r=0 to r=1, and theta=0 to theta=2*pi)
-%   is unity.  For the non-normalized polynomials, max(Zp(r=1,theta))=1
-%   for all p.
-%
-%   NOTE: ZERNFUN2 returns the same output as ZERNFUN, for the first 36
-%   Zernike functions (order N<=7).  In some disciplines it is 
-%   traditional to label the first 36 functions using a single mode
-%   number P instead of separate numbers for the order N and azimuthal
-%   frequency M.
-%
-%   Example:
-%
-%       % Display the first 16 Zernike functions
-%       x = -1:0.01:1;
-%       [X,Y] = meshgrid(x,x);
-%       [theta,r] = cart2pol(X,Y);
-%       idx = r<=1;
-%       p = 0:15;
-%       z = nan(size(X));
-%       y = zernfun2(p,r(idx),theta(idx));
-%       figure('Units','normalized')
-%       for k = 1:length(p)
-%           z(idx) = y(:,k);
-%           subplot(4,4,k)
-%           pcolor(x,x,z), shading interp
-%           set(gca,'XTick',[],'YTick',[])
-%           axis square
-%           title(['Z_{' num2str(p(k)) '}'])
-%       end
-%
-%   See also ZERNPOL, ZERNFUN.
-
-%   Paul Fricker 11/13/2006
-
-
-% Check and prepare the inputs:
-% -----------------------------
-if min(size(p))~=1
-    error('zernfun2:Pvector','Input P must be vector.')
-end
-
-if any(p)>35
-    error('zernfun2:P36', ...
-          ['ZERNFUN2 only computes the first 36 Zernike functions ' ...
-           '(P = 0 to 35).'])
-end
-
-% Get the order and frequency corresonding to the function number:
-% ----------------------------------------------------------------
-p = p(:);
-n = ceil((-3+sqrt(9+8*p))/2);
-m = 2*p - n.*(n+2);
-
-% Pass the inputs to the function ZERNFUN:
-% ----------------------------------------
-switch nargin
-    case 3
-        z = zernfun(n,m,r,theta);
-    case 4
-        z = zernfun(n,m,r,theta,nflag);
-    otherwise
-        error('zernfun2:nargin','Incorrect number of inputs.')
-end
-
-% EOF zernfun2
\ No newline at end of file
diff --git a/Generator/library/zernike.m b/Generator/library/zernike.m
deleted file mode 100644
index ab36f24..0000000
--- a/Generator/library/zernike.m
+++ /dev/null
@@ -1,45 +0,0 @@
-function z = zernike(n,m,size)
-
-% z = zernike(n,m,size)
-%     Generates the (n,m) Zernike polynomial, where n>=m, on the inscribed circle
-%     in a square raster of side 'size'. 
-%
-%     Inputs:
-%	n	Radial order of polynomial; must be non-negative
-%	m	Azimuthal order: in the range m = -n:2:n
-%	size	Linear size of output raster
-%
-%     Output:
-%	z	2D raster
-
-
-ma = abs(m);
-if (n<ma) | (n<0)
-   error('n must be non-negative and n>=|m|');
-end
-
-s = (n-ma)/2;
-if (s-floor(s)~=0)
-   error('n-m must be even');
-end
-
-c1 = -((size-1)/2);
-c2 = size+c1-1;
-
-[x y] = meshgrid([c1:c2],[c1:c2]);
-rho = sqrt(x.*x+y.*y)/size*2;
-theta = atan2(y,x);
-
-R = 0;
-for k=0:s
-   R = R+((-1)^k*factorial(n-k))/(factorial(k)*factorial((n+ma)/2-k)*factorial(s-k)).*rho.^(n-2*k);
-end
-
-R = R.*circle(size,size,[(size+1)/2 (size+1)/2]);
-if m<0
-   z = sqrt(2*(n+1))*R.*sin(ma*theta);
-elseif m>0
-   z = sqrt(2*(n+1))*R.*cos(ma*theta);
-else
-   z = sqrt(n+1)*R;
-end
diff --git a/Generator/library/zernikes.m b/Generator/library/zernikes.m
deleted file mode 100644
index 01b1b36..0000000
--- a/Generator/library/zernikes.m
+++ /dev/null
@@ -1,20 +0,0 @@
-function zerns = zernikes(pdim,nz)
- 
-v=1:pdim;
-icen = 1+(pdim-1)/2;
-x = (v-icen);
-x = x./abs(x(1));
-
-[X,Y] = meshgrid(x,x);
-[theta,r] = cart2pol(X,Y);
-idx = r<=1;
-p = 0:(nz-1);
-z = zeros(size(X));
-y = zernfun2(p,r(idx),theta(idx));
-zerns = zeros(pdim,pdim,nz);
-for k=1:nz
-    z(idx) = y(:,k);
-    zerns(:,:,k) = z;
-end
-
-
diff --git a/Generator/ml_tools/._blur_object_poses.m b/Generator/ml_tools/._blur_object_poses.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/ml_tools/._blur_object_poses.m and /dev/null differ
diff --git a/Generator/ml_tools/._gen_object_poses.m b/Generator/ml_tools/._gen_object_poses.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/ml_tools/._gen_object_poses.m and /dev/null differ
diff --git a/Generator/ml_tools/._increase_fov.m b/Generator/ml_tools/._increase_fov.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/ml_tools/._increase_fov.m and /dev/null differ
diff --git a/Generator/ml_tools/._scale_fov.m b/Generator/ml_tools/._scale_fov.m
deleted file mode 100644
index e3fbea4..0000000
Binary files a/Generator/ml_tools/._scale_fov.m and /dev/null differ
diff --git a/Generator/ml_tools/.ipynb_checkpoints/gen_object_poses-checkpoint.m b/Generator/ml_tools/.ipynb_checkpoints/gen_object_poses-checkpoint.m
deleted file mode 100644
index ed9d0d7..0000000
--- a/Generator/ml_tools/.ipynb_checkpoints/gen_object_poses-checkpoint.m
+++ /dev/null
@@ -1,100 +0,0 @@
-function [g4, v_az, v_el] = gen_object_poses(stl_fname, n_poses, dsf, v_az, v_el ) 
-
-% g = gen_object_poses(stl_fname, n_poses, dsf,  v_az, v_el ) 
-%
-% stl_fname         file name to STL file (full path)
-% n_poses           number of random poses
-% dsf               downsampling factor
-% v_az              vector azimuthal camera positions
-% v_el              vector of elevation camera positions
-%
-% returns: g        NxNxn_poses 3D array of object poses
-%
-
-if nargin==3
-    % Camera view angle (degrees) random
-    v_az =  rand(1,n_poses).*180;
-    v_el =  rand(1,n_poses).*180;
-end
-n_poses = length(v_az);
-
-
-% Camera view angle (degrees) sequence
-% v_az = -30:1:0;
-% v_el = 40:1:70;
-
-%% Load STL mesh
-% Stereolithography (STL) files are a common format for storing mesh data. STL
-% meshes are simply a collection of triangular faces. This type of model is very
-% suitable for use with MATLAB's PATCH graphics object.
-
-% Import an STL mesh, returning a PATCH-compatible face-vertex structure
-
-% stl_fname = '/Users/douglashope/Dropbox/hsr/ML/Objects STL/cassini.stl';
-fits_fname = strrep(stl_fname,'.stl','.fits');
-
-fv = stlread1(stl_fname);
-
-
-%% Render
-% The model is rendered with a PATCH graphics object. We also add some dynamic
-% lighting, and adjust the material properties to change the specular
-% highlighting.
-figure(5)
-clf
-set(gcf,'Color','w');
-patch('Faces',fv.faces,'Vertices',fv.vertices,'FaceColor',[0.8 0.8 1.0], 'EdgeColor','none','FaceLighting', 'gouraud','AmbientStrength', 0.15);
-
-% Add a camera light, and tone down the specular highlighting
-camlight('left');
-material('dull');
-lighting('GOURAUD');
-% Fix the axes scaling, and set a nice view angle
-axis('image');axis off
-
-set(gca,'CameraTarget',[0 0 0]);
-set(gca,'DataAspectRatio',[1 1 1],'PlotBoxAspectRatio',[1 1 1]);
-camtarget('manual')
-
-view([v_az(1) v_el(1)]);
-gg=zeros(896,896,length(v_az));
-
-parfor k=1:length(v_az)
-    az_view = v_az(k);
-    el_view = v_el(k);
-    view(az_view,el_view);
-    camva(10)
-        
-    FF=getframe;
-    g1 = double(rgb2gray(FF.cdata));
-    g1 = abs(g1 - g1(1,1));
-
-    pad_size = (896 - size(g1))/2;
-    
-    if pad_size(1) ~= fix(pad_size(1))
-        pad_size1_pre  = fix(pad_size(1));
-        pad_size1_post    = 896-size(g1,1)-pad_size1_pre;
-    else
-         pad_size1_pre  = pad_size(1);
-         pad_size1_post = pad_size(1);
-    end
-    if pad_size(2) ~= fix(pad_size(2))
-        pad_size2_pre  = fix(pad_size(2));
-        pad_size2_post    = 896-size(g1,2)-pad_size2_pre;
-    else
-        pad_size2_pre  = pad_size(2);
-        pad_size2_post = pad_size(2);
-    end
-    pad_pre     = [ pad_size1_pre pad_size2_pre ];
-    pad_post    = [ pad_size1_post pad_size2_post ];
-    g2          = padarray(padarray(g1, pad_pre, 'pre'), pad_post, 'post');
-    gg(:,:,k) = g2;
-end
-
-if dsf>1 
-    g4=sepblockfun(gg,[dsf dsf],@mean);
-    h=fspecial('Gaussian',1);
-    g4 = imfilter(g4,h);
-else
-    g4 = gg;
-end
\ No newline at end of file
diff --git a/Generator/ml_tools/blur_object_poses.m b/Generator/ml_tools/blur_object_poses.m
deleted file mode 100644
index 94c323c..0000000
--- a/Generator/ml_tools/blur_object_poses.m
+++ /dev/null
@@ -1,28 +0,0 @@
-function gp = blur_object_poses( g, Dr0 )
-
-grid_sz = size(g,1);
-gp = zeros(size(g));
-
-pdim            = grid_sz./2; % Nyquist sample by default
-pupil_pix_pri   = pdim;
-pupil_pix_sec   = pdim.*0.09375;
-
-% Generate aperture with Nyquist sampling
-pupil1 = make_circle_mask(pdim ,pupil_pix_pri/2 );
-pupil2 = make_circle_mask(pdim, pupil_pix_sec/2 );
-pupil_mask  = pupil1 - pupil2;
-pupil_mask  = padarray(pupil_mask,[ (grid_sz-pdim)/2 (grid_sz-pdim)/2 ],0,'both');
-pupil_amp   = pupil_mask;
-
-
-pupil_amp  = pupil_amp./max(pupil_amp(:));
-pupil_amp  = (size(g,1).*pupil_amp)./sqrt(sum(sum(pupil_amp.^2)));        
-
-for k=1:size(g,3)
-    phase       = kolmogorov(grid_sz, Dr0 );    
-    a   = ifft2(pupil_amp.*exp(sqrt(-1).*phase));
-    h   = abs(abs(a).^2);
-    gp(:,:,k) = real(ifft2(fft2(h).*fft2(g(:,:,k))));
-%     figure(9);imagesc(ifftshift(h));pause(0.5);
-end
-
diff --git a/Generator/ml_tools/gen_object_poses.m b/Generator/ml_tools/gen_object_poses.m
deleted file mode 100644
index ed9d0d7..0000000
--- a/Generator/ml_tools/gen_object_poses.m
+++ /dev/null
@@ -1,100 +0,0 @@
-function [g4, v_az, v_el] = gen_object_poses(stl_fname, n_poses, dsf, v_az, v_el ) 
-
-% g = gen_object_poses(stl_fname, n_poses, dsf,  v_az, v_el ) 
-%
-% stl_fname         file name to STL file (full path)
-% n_poses           number of random poses
-% dsf               downsampling factor
-% v_az              vector azimuthal camera positions
-% v_el              vector of elevation camera positions
-%
-% returns: g        NxNxn_poses 3D array of object poses
-%
-
-if nargin==3
-    % Camera view angle (degrees) random
-    v_az =  rand(1,n_poses).*180;
-    v_el =  rand(1,n_poses).*180;
-end
-n_poses = length(v_az);
-
-
-% Camera view angle (degrees) sequence
-% v_az = -30:1:0;
-% v_el = 40:1:70;
-
-%% Load STL mesh
-% Stereolithography (STL) files are a common format for storing mesh data. STL
-% meshes are simply a collection of triangular faces. This type of model is very
-% suitable for use with MATLAB's PATCH graphics object.
-
-% Import an STL mesh, returning a PATCH-compatible face-vertex structure
-
-% stl_fname = '/Users/douglashope/Dropbox/hsr/ML/Objects STL/cassini.stl';
-fits_fname = strrep(stl_fname,'.stl','.fits');
-
-fv = stlread1(stl_fname);
-
-
-%% Render
-% The model is rendered with a PATCH graphics object. We also add some dynamic
-% lighting, and adjust the material properties to change the specular
-% highlighting.
-figure(5)
-clf
-set(gcf,'Color','w');
-patch('Faces',fv.faces,'Vertices',fv.vertices,'FaceColor',[0.8 0.8 1.0], 'EdgeColor','none','FaceLighting', 'gouraud','AmbientStrength', 0.15);
-
-% Add a camera light, and tone down the specular highlighting
-camlight('left');
-material('dull');
-lighting('GOURAUD');
-% Fix the axes scaling, and set a nice view angle
-axis('image');axis off
-
-set(gca,'CameraTarget',[0 0 0]);
-set(gca,'DataAspectRatio',[1 1 1],'PlotBoxAspectRatio',[1 1 1]);
-camtarget('manual')
-
-view([v_az(1) v_el(1)]);
-gg=zeros(896,896,length(v_az));
-
-parfor k=1:length(v_az)
-    az_view = v_az(k);
-    el_view = v_el(k);
-    view(az_view,el_view);
-    camva(10)
-        
-    FF=getframe;
-    g1 = double(rgb2gray(FF.cdata));
-    g1 = abs(g1 - g1(1,1));
-
-    pad_size = (896 - size(g1))/2;
-    
-    if pad_size(1) ~= fix(pad_size(1))
-        pad_size1_pre  = fix(pad_size(1));
-        pad_size1_post    = 896-size(g1,1)-pad_size1_pre;
-    else
-         pad_size1_pre  = pad_size(1);
-         pad_size1_post = pad_size(1);
-    end
-    if pad_size(2) ~= fix(pad_size(2))
-        pad_size2_pre  = fix(pad_size(2));
-        pad_size2_post    = 896-size(g1,2)-pad_size2_pre;
-    else
-        pad_size2_pre  = pad_size(2);
-        pad_size2_post = pad_size(2);
-    end
-    pad_pre     = [ pad_size1_pre pad_size2_pre ];
-    pad_post    = [ pad_size1_post pad_size2_post ];
-    g2          = padarray(padarray(g1, pad_pre, 'pre'), pad_post, 'post');
-    gg(:,:,k) = g2;
-end
-
-if dsf>1 
-    g4=sepblockfun(gg,[dsf dsf],@mean);
-    h=fspecial('Gaussian',1);
-    g4 = imfilter(g4,h);
-else
-    g4 = gg;
-end
\ No newline at end of file
diff --git a/Generator/ml_tools/increase_fov.m b/Generator/ml_tools/increase_fov.m
deleted file mode 100644
index eb3190c..0000000
--- a/Generator/ml_tools/increase_fov.m
+++ /dev/null
@@ -1,9 +0,0 @@
-function gg = increase_fov( g, scale )
-
-scale = min(1,scale);
-
-gg = zeros(size(g));
-for k=1:size(g,3)
-    gg(:,:,k) = p_ImgScale(g(:,:,k), scale);
-end
-
diff --git a/Generator/ml_tools/scale_fov.m b/Generator/ml_tools/scale_fov.m
deleted file mode 100644
index 5221cad..0000000
--- a/Generator/ml_tools/scale_fov.m
+++ /dev/null
@@ -1,7 +0,0 @@
-function gg = increase_fov( g, scale )
-
-gg = zeros(size(g));
-for k=1:size(g,3)
-    gg(:,:,k) = p_ImgScale(g(:,:,k), scale);
-end
-
diff --git a/Generator/objects_training/ACRIMSAT_05.stl b/Generator/objects_training/ACRIMSAT_05.stl
deleted file mode 100644
index cbe52fb..0000000
Binary files a/Generator/objects_training/ACRIMSAT_05.stl and /dev/null differ
diff --git a/Generator/objects_training/Aqua_13.stl b/Generator/objects_training/Aqua_13.stl
deleted file mode 100644
index bd6c461..0000000
Binary files a/Generator/objects_training/Aqua_13.stl and /dev/null differ
diff --git a/Generator/objects_training/Deep Space 1_11.stl b/Generator/objects_training/Deep Space 1_11.stl
deleted file mode 100644
index d2e44c4..0000000
Binary files a/Generator/objects_training/Deep Space 1_11.stl and /dev/null differ
diff --git a/Generator/objects_training/Juno.stl b/Generator/objects_training/Juno.stl
deleted file mode 100644
index 0ac4c13..0000000
Binary files a/Generator/objects_training/Juno.stl and /dev/null differ
diff --git a/Generator/objects_training/LRO_35.stl b/Generator/objects_training/LRO_35.stl
deleted file mode 100644
index 24efb9f..0000000
Binary files a/Generator/objects_training/LRO_35.stl and /dev/null differ
diff --git a/Generator/objects_training/MGS_moi.stl b/Generator/objects_training/MGS_moi.stl
deleted file mode 100644
index e01fe81..0000000
Binary files a/Generator/objects_training/MGS_moi.stl and /dev/null differ
diff --git a/Generator/objects_training/agena-c.stl b/Generator/objects_training/agena-c.stl
deleted file mode 100644
index acf7f92..0000000
Binary files a/Generator/objects_training/agena-c.stl and /dev/null differ
diff --git a/Generator/objects_training/agena_carbajal.stl b/Generator/objects_training/agena_carbajal.stl
deleted file mode 100644
index 40c3bbf..0000000
Binary files a/Generator/objects_training/agena_carbajal.stl and /dev/null differ
diff --git a/Generator/objects_training/aqua.stl b/Generator/objects_training/aqua.stl
deleted file mode 100644
index bd6c461..0000000
Binary files a/Generator/objects_training/aqua.stl and /dev/null differ
diff --git a/Generator/objects_training/cassini.stl b/Generator/objects_training/cassini.stl
deleted file mode 100644
index f42fa80..0000000
Binary files a/Generator/objects_training/cassini.stl and /dev/null differ
diff --git a/Generator/objects_training/chandra_v09.stl b/Generator/objects_training/chandra_v09.stl
deleted file mode 100644
index 03f0521..0000000
Binary files a/Generator/objects_training/chandra_v09.stl and /dev/null differ
diff --git a/Generator/objects_training/cloudsat_v19.stl b/Generator/objects_training/cloudsat_v19.stl
deleted file mode 100644
index 0815efb..0000000
Binary files a/Generator/objects_training/cloudsat_v19.stl and /dev/null differ
diff --git a/Generator/output/.gitignore b/Generator/output/.gitignore
deleted file mode 100644
index 72e8ffc..0000000
--- a/Generator/output/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-*
diff --git a/Generator/output/.gitkeep b/Generator/output/.gitkeep
deleted file mode 100644
index e69de29..0000000
diff --git a/Generator/script_training_data.m b/Generator/script_training_data.m
deleted file mode 100644
index 3ff6342..0000000
--- a/Generator/script_training_data.m
+++ /dev/null
@@ -1,46 +0,0 @@
-addpath('library');
-addpath('ml_tools');
-addpath('asim');
-addpath('objects_training')
-
-% Where are the STL files stored 
-object_dir = 'objects_training/';
-
-%object_dir = fullfile('E:\','objects_training',filesep);
-Dr0        = 5;            % turbulence strength D/r0 =5 (low) /D/r0 = 15 (medium) / D/r0=21 (strong)
-n_poses    = 100;             % how many random or specified poses 
-dsf        = 4;             % downsample factor (controls image grid size)
-fov        = 0.5;           % field of view
-
-% generate specific object poses 
-% v_az = zeros(1,11);
-% v_el = 0:10:100;
-% n_poses = length(v_el);
-
-% measure elapsed time
-t = cputime;
-
-adir = dir([ object_dir '*.stl']);
-for ss=1:length(adir)
-    if adir(ss).isdir==0
-        [toss,name,ext] = fileparts(adir(ss).name);
-        name = strrep(name, "._", "");
-        stl_fname   = join([ object_dir filesep name ext ], '');
-        
-       [g, v_az, v_el]   = gen_object_poses(stl_fname, n_poses, dsf);  % generate random poses 
-%        [g, ~, ~]  = gen_object_poses(stl_fname, n_poses, dsf, v_az, v_el);  % generate specific poses 
-        g2   = scale_fov(g, 0.5);           % change the FOV - make object smaller<1 /bigger >1
-        gp  = blur_object_poses(g2, Dr0);       % Specify turbulence strength via D/r0 value
-        
-        for n=1:n_poses
-            imwrite(gp(:,:,n), join(["output" filesep name "_" int2str(n) ".JPEG"], ''), "JPEG");
-        end
-    end
-end
-
-% record elapsed time
-e = cputime -t;
-
-% diplay elapsed time
-disp('elapsed time:')
-disp(e)
diff --git a/Generator/stlread1.m b/Generator/stlread1.m
deleted file mode 100755
index 10c5162..0000000
--- a/Generator/stlread1.m
+++ /dev/null
@@ -1,135 +0,0 @@
-function varargout = stlread(file)
-% STLREAD imports geometry from an STL file into MATLAB.
-%    FV = STLREAD(FILENAME) imports triangular faces from the ASCII or binary
-%    STL file idicated by FILENAME, and returns the patch struct FV, with fields
-%    'faces' and 'vertices'.
-%
-%    [F,V] = STLREAD(FILENAME) returns the faces F and vertices V separately.
-%
-%    [F,V,N] = STLREAD(FILENAME) also returns the face normal vectors.
-%
-%    The faces and vertices are arranged in the format used by the PATCH plot
-%    object.
-
-% Copyright 2011 The MathWorks, Inc.
-
-    if ~exist(file,'file')
-        error(['File ''%s'' not found. If the file is not on MATLAB''s path' ...
-               ', be sure to specify the full path to the file.'], file);
-    end
-
-    fid = fopen(file,'r');    
-    if ~isempty(ferror(fid))
-        error(lasterror); %#ok
-    end
-    
-    M = fread(fid,inf,'uint8=>uint8');
-    fclose(fid);
-    
-    [f,v,n] = stlbinary(M);
-    %if( isbinary(M) ) % This may not be a reliable test
-    %    [f,v,n] = stlbinary(M);
-    %else
-    %    [f,v,n] = stlascii(M);
-    %end
-    
-    varargout = cell(1,nargout);
-    switch nargout        
-        case 2
-            varargout{1} = f;
-            varargout{2} = v;
-        case 3
-            varargout{1} = f;
-            varargout{2} = v;
-            varargout{3} = n;
-        otherwise
-            varargout{1} = struct('faces',f,'vertices',v);
-    end
-
-end
-
-
-function [F,V,N] = stlbinary(M)
-
-    F = [];
-    V = [];
-    N = [];
-    
-    if length(M) < 84
-        error('MATLAB:stlread:incorrectFormat', ...
-              'Incomplete header information in binary STL file.');
-    end
-    
-    % Bytes 81-84 are an unsigned 32-bit integer specifying the number of faces
-    % that follow.
-    numFaces = typecast(M(81:84),'uint32');
-    %numFaces = double(numFaces);
-    if numFaces == 0
-        warning('MATLAB:stlread:nodata','No data in STL file.');
-        return
-    end
-    
-    T = M(85:end);
-    F = NaN(numFaces,3);
-    V = NaN(3*numFaces,3);
-    N = NaN(numFaces,3);
-    
-    numRead = 0;
-    while numRead < numFaces
-        % Each facet is 50 bytes
-        %  - Three single precision values specifying the face normal vector
-        %  - Three single precision values specifying the first vertex (XYZ)
-        %  - Three single precision values specifying the second vertex (XYZ)
-        %  - Three single precision values specifying the third vertex (XYZ)
-        %  - Two unused bytes
-        i1    = 50 * numRead + 1;
-        i2    = i1 + 50 - 1;
-        facet = T(i1:i2)';
-        
-        n  = typecast(facet(1:12),'single');
-        v1 = typecast(facet(13:24),'single');
-        v2 = typecast(facet(25:36),'single');
-        v3 = typecast(facet(37:48),'single');
-        
-        n = double(n);
-        v = double([v1; v2; v3]);
-        
-        % Figure out where to fit these new vertices, and the face, in the
-        % larger F and V collections.        
-        fInd  = numRead + 1;        
-        vInd1 = 3 * (fInd - 1) + 1;
-        vInd2 = vInd1 + 3 - 1;
-        
-        V(vInd1:vInd2,:) = v;
-        F(fInd,:)        = vInd1:vInd2;
-        N(fInd,:)        = n;
-        
-        numRead = numRead + 1;
-    end
-    
-end
-
-
-function [F,V,N] = stlascii(M)
-    warning('MATLAB:stlread:ascii','ASCII STL files currently not supported.');
-    F = [];
-    V = [];
-    N = [];
-end
-
-% TODO: Change the testing criteria! Some binary STL files still begin with
-% 'solid'.
-function tf = isbinary(A)
-% ISBINARY uses the first line of an STL file to identify its format.
-    if isempty(A) || length(A) < 5
-        error('MATLAB:stlread:incorrectFormat', ...
-              'File does not appear to be an ASCII or binary STL file.');
-    end    
-    if strcmpi('solid',char(A(1:5)'))
-        tf = false; % ASCII
-    else
-        tf = true;  % Binary
-    end
-end
-
-
nbdiff /tmp/pHlAgk_Neuronetwork-checkpoint.ipynb /dev/null
--- /tmp/pHlAgk_Neuronetwork-checkpoint.ipynb  2020-04-16 19:16:43.994522
+++ /dev/null  2020-04-16 19:06:50.148000
[34m## deleted /cells:[0m
[31m-  code cell:
[31m-    execution_count: 1
[31m-    source:
[31m-      # initialisation to set the number of input, hidden and output nodes
[31m-      #  train refine the weights after being given a training set example to learn from
[31m-      #  query give an answer from the output nodes after being given an input
[31m-  code cell:
[31m-    execution_count: 1
[31m-    source:
[31m-      #initialize the neuro network
[31m-      import numpy as numpy
[31m-      import scipy.special
[31m-      class NeuroNetwork:
[31m-          
[31m-          def __init__(self, inputnodes, hiddennodes, outputnodes, learningrate):
[31m-              self.inodes = inputnodes
[31m-              self.hnodes = hiddennodes
[31m-              self.onodes = outputnodes
[31m-              
[31m-              #learning rate
[31m-              self.lr = learningrate
[31m-              
[31m-              self.wih = (numpy.random.rand(self.hnodes,self.inodes)-0.5)
[31m-              #W = 0.1* np.random.randn(D,H)
[31m-              self.who = (numpy.random.rand(self.onodes,self.hnodes)-0.5)
[31m-              #activation function
[31m-              self.activation_function = lambda x: scipy.special.expit(x)
[31m-              pass
[31m-          #train your data
[31m-          def train(self,inputs_list,targets_list):
[31m-              #convert inputs list to 2d array
[31m-              inputs = numpy.array(inputs_list,ndmin=2).T
[31m-              targets = numpy.array(targets_list,ndmin=2).T
[31m-      
[31m-              
[31m-              #calculate the signals into the hidden layer
[31m-              hidden_inputs = numpy.dot(self.wih,inputs)
[31m-              hidden_outputs = self.activation_function(hidden_inputs)
[31m-      
[31m-              
[31m-              #calculate signals intot he final output layer
[31m-              final_inputs = numpy.dot(self.who,hidden_outputs)
[31m-              final_outputs = self.activation_function(final_inputs)
[31m-              
[31m-              #output erros
[31m-              output_errors = targets-final_outputs
[31m-              
[31m-              #calculating the back-propagated errors or the hidden layers nodes.
[31m-              #errors_hidden = weight_hidden_output.T - output_erros
[31m-              
[31m-              #backpropagating
[31m-              
[31m-              hidden_errors = numpy.dot(self.who.T,output_errors)
[31m-              
[31m-               # update the weights for the links between the hidden and output layers
[31m-              self.who += self.lr * numpy.dot((output_errors * final_outputs * (1.0 - final_outputs)), numpy.transpose(hidden_outputs))
[31m-              
[31m-              # update the weights for the links between the input and hidden layers
[31m-              self.wih += self.lr * numpy.dot((hidden_errors * hidden_outputs * (1.0 - hidden_outputs)), numpy.transpose(inputs))
[31m-              
[31m-              
[31m-              pass
[31m-       
[31m-      
[31m-          def sigmoid(a):
[31m-              return 1 / (1 + numpy.exp(-a))
[31m-          
[31m-          def sigmoid_prime(x):
[31m-              return x*(1.0-x)
[31m-      
[31m-          
[31m-          #query the neural network
[31m-          def query(self,inputs_list):
[31m-              #convert inputs list to 2d array
[31m-              inputs = numpy.array(inputs_list,ndmin=2).T
[31m-              
[31m-              #calculate the signals into the hidden layer
[31m-              hidden_inputs = numpy.dot(self.wih,inputs)
[31m-              
[31m-              #calculate the signals emerginf from hidden layer
[31m-      #         hidden_outputs = sigmoid(hidden_inputs)
[31m-              hidden_outputs = self.activation_function(hidden_inputs)
[31m-      
[31m-              
[31m-              #calculate signals intot he final output layer
[31m-              final_inputs = numpy.dot(self.who,hidden_outputs)
[31m-              #calculate the signals emrtging from the final outputs
[31m-      #         final_outputs = sigmoid(final_inputs)
[31m-              final_outputs = self.activation_function(final_inputs)
[31m-              
[31m-              return final_outputs
[31m-  code cell:
[31m-    execution_count: 2
[31m-    source:
[31m-      #number of input, hidden, and output nodes
[31m-      input_nodes = 784
[31m-      hidden_nodes = 200
[31m-      output_nodes = 10 
[31m-  code cell:
[31m-    execution_count: 12
[31m-    source:
[31m-      input_nodes
[31m-    outputs:
[31m-      output 0:
[31m-        output_type: execute_result
[31m-        execution_count: 12
[31m-        data:
[31m-          text/plain: 784
[31m-  code cell:
[31m-    execution_count: 19
[31m-    source:
[31m-      numpy.random.randn(3,5)-0.5
[31m-    outputs:
[31m-      output 0:
[31m-        output_type: execute_result
[31m-        execution_count: 19
[31m-        data:
[31m-          text/plain:
[31m-            array([[ 0.47700713, -1.88279861, -0.62541591, -0.25131254, -0.21935739],
[31m-                   [ 1.01924778, -2.31023972, -0.88742301, -1.62682328, -0.26566537],
[31m-                   [-1.14514412,  0.21658726,  0.73854138, -1.28905776, -1.37216351]])
[31m-  code cell:
[31m-  code cell:
[31m-  code cell:
[31m-  code cell:
[31m-  code cell:
[31m-  code cell:
[31m-  code cell:
[31m-  code cell:
[31m-    execution_count: 3
[31m-    source:
[31m-      #learning rate will be 0.3
[31m-      learning_rate = 0.3
[31m-  code cell:
[31m-    execution_count: 4
[31m-    source:
[31m-      n = NeuroNetwork(input_nodes,hidden_nodes,output_nodes,learning_rate)
[31m-  code cell:
[31m-    execution_count: 5
[31m-    source:
[31m-      #load the mnist training data CSV file into a list
[31m-      data_file = open("mnist_train.csv",'r')
[31m-      data_list = data_file.readlines()
[31m-      data_file.close()
[31m-  code cell:
[31m-    execution_count: 6
[31m-    source:
[31m-      #train the neural network
[31m-  code cell:
[31m-    execution_count: 8
[31m-    source:
[31m-      
[31m-      # train the neural network
[31m-      
[31m-      # epochs is the number of times the training data set is used for training
[31m-      epochs = 2
[31m-      
[31m-      for e in range(epochs):
[31m-          # go through all records in the training data set
[31m-          for record in data_list:
[31m-              # split the record by the ',' commas
[31m-              all_values = record.split(',')
[31m-              # scale and shift the inputs
[31m-              inputs = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01
[31m-              # create the target output values (all 0.01, except the desired label which is 0.99)
[31m-              targets = numpy.zeros(output_nodes) + 0.01
[31m-              # all_values[0] is the target label for this record
[31m-              targets[int(all_values[0])] = 0.99
[31m-              n.train(inputs, targets)
[31m-              pass
[31m-          pass
[31m-  code cell:
[31m-    execution_count: 9
[31m-    source:
[31m-      # load the mnist test data CSV file into a list
[31m-      test_data_file = open("mnist_test.csv", 'r')
[31m-      test_data_list = test_data_file.readlines()
[31m-      test_data_file.close()
[31m-  code cell:
[31m-    execution_count: 10
[31m-    source:
[31m-       #test the neural network
[31m-      
[31m-      # scorecard for how well the network performs, initially empty
[31m-      scorecard = []
[31m-      
[31m-      # go through all the records in the test data set
[31m-      for record in test_data_list:
[31m-          # split the record by the ',' commas
[31m-          all_values = record.split(',')
[31m-          # correct answer is first value
[31m-          correct_label = int(all_values[0])
[31m-          # scale and shift the inputs
[31m-          inputs = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01
[31m-          # query the network
[31m-          outputs = n.query(inputs)
[31m-          # the index of the highest value corresponds to the label
[31m-          label = numpy.argmax(outputs)
[31m-          # append correct or incorrect to list
[31m-          if (label == correct_label):
[31m-              # network's answer matches correct answer, add 1 to scorecard
[31m-              scorecard.append(1)
[31m-          else:
[31m-              # network's answer doesn't match correct answer, add 0 to scorecard
[31m-              scorecard.append(0)
[31m-              pass
[31m-          
[31m-          pass
[31m-  code cell:
[31m-    execution_count: 11
[31m-    source:
[31m-      
[31m-      # calculate the performance score, the fraction of correct answers
[31m-      scorecard_array = numpy.asarray(scorecard)
[31m-      print ("performance = ", scorecard_array.sum() / scorecard_array.size)
[31m-    outputs:
[31m-      output 0:
[31m-        output_type: stream
[31m-        name: stdout
[31m-        text:
[31m-          performance =  0.958
[31m-  code cell:

[0m[34m## deleted /metadata:[0m
[31m-  kernelspec:
[31m-    display_name: Python 3
[31m-    language: python
[31m-    name: python3
[31m-  language_info:
[31m-    codemirror_mode:
[31m-      name: ipython
[31m-      version: 3
[31m-    file_extension: .py
[31m-    mimetype: text/x-python
[31m-    name: python
[31m-    nbconvert_exporter: python
[31m-    pygments_lexer: ipython3
[31m-    version: 3.7.4

[0m[34m## deleted /nbformat:[0m
[31m-  4

[0m[34m## deleted /nbformat_minor:[0m
[31m-  4

[0mdiff --git a/model/.ipynb_checkpoints/__init__-checkpoint.py b/model/.ipynb_checkpoints/__init__-checkpoint.py
deleted file mode 100644
index e69de29..0000000
nbdiff /tmp/QoQ7Vu_sat-resnet-checkpoint.ipynb /dev/null
--- /tmp/QoQ7Vu_sat-resnet-checkpoint.ipynb  2020-04-16 19:16:44.270546
+++ /dev/null  2020-04-16 19:06:50.148000
[34m## deleted /cells:[0m
[31m-  code cell:
[31m-    execution_count: 35
[31m-    source:
[31m-      from PIL import Image
[31m-      import os
[31m-      
[31m-      def format_image(image):
[31m-          r
[31m-      
[31m-      def load_data(train_ratio = 0.8, image_dir = '/home/jupyter/SSA Project/Generator/output'):    
[31m-          labels = []
[31m-          
[31m-          x = []
[31m-          y = []
[31m-          
[31m-          for filename in os.listdir(image_dir):
[31m-              if filename.endswith('.JPEG'):
[31m-                  with Image.open(os.path.join(image_dir, filename), 'r') as img:
[31m-                      label_name = ''.join(filename.split('_')[:-1])
[31m-                      if label_name not in labels:
[31m-                          labels.append(label_name)
[31m-                      y.append(labels.indexOf(label_name))
[31m-                      x.append(format_image(img))
[31m-                          
[31m-          
[31m-          return (x_train, y_train), (x_test, y_test)
[31m-      
[31m-      load_data()
[31m-    outputs:
[31m-      output 0:
[31m-        output_type: stream
[31m-        name: stdout
[31m-        text:
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-          (224, 224)
[31m-      output 1:
[31m-        output_type: execute_result
[31m-        execution_count: 35
[31m-        data:
[31m-          text/plain: (([], []), ([], []))
[31m-  code cell:
[31m-  code cell:
[31m-    execution_count: 29
[31m-    source:
[31m-      import numpy as np
[31m-      import keras
[31m-      from keras.preprocessing.image import ImageDataGenerator
[31m-      from keras.models import Sequential
[31m-      from keras.layers import Dense, Dropout, Activation, Flatten
[31m-      from keras.layers import Conv2D, MaxPooling2D
[31m-      
[31m-      # from lib import datasets
[31m-      from keras.datasets import cifar10 as datasets
[31m-  code cell:
[31m-    execution_count: 30
[31m-    source:
[31m-      batch_size = 32
[31m-      num_classes = 10
[31m-      epochs = 5
[31m-      data_augmentation = True
[31m-      num_predictions = 20
[31m-      save_dir = os.path.join(os.getcwd(), 'saved_models')
[31m-      model_name = 'satellite_classification_trained_model.h5'
[31m-      
[31m-      # The data, split between train and test sets:
[31m-      (x_train, y_train), (x_test, y_test) = datasets.load_data()
[31m-      num_classes = len(np.unique(y_train))
[31m-      
[31m-      print('x_train shape:', x_train.shape)
[31m-      print(x_train.shape[0], 'train samples')
[31m-      print(x_test.shape[0], 'test samples')
[31m-      print(num_classes, 'classes')
[31m-    outputs:
[31m-      output 0:
[31m-        output_type: stream
[31m-        name: stdout
[31m-        text:
[31m-          x_train shape: (50000, 32, 32, 3)
[31m-          50000 train samples
[31m-          10000 test samples
[31m-          10 classes
[31m-  code cell:
[31m-    execution_count: 20
[31m-    source:
[31m-      # Convert class vectors to binary class matrices.
[31m-      y_train = keras.utils.to_categorical(y_train, num_classes)
[31m-      y_test = keras.utils.to_categorical(y_test, num_classes)
[31m-  code cell:
[31m-    execution_count: 21
[31m-    source:
[31m-      model = Sequential()
[31m-      model.add(Conv2D(32, (3, 3), padding='same',
[31m-                       input_shape=x_train.shape[1:]))
[31m-      model.add(Activation('relu'))
[31m-      model.add(Conv2D(32, (3, 3)))
[31m-      model.add(Activation('relu'))
[31m-      model.add(MaxPooling2D(pool_size=(2, 2)))
[31m-      model.add(Dropout(0.25))
[31m-      
[31m-      model.add(Conv2D(64, (3, 3), padding='same'))
[31m-      model.add(Activation('relu'))
[31m-      model.add(Conv2D(64, (3, 3)))
[31m-      model.add(Activation('relu'))
[31m-      model.add(MaxPooling2D(pool_size=(2, 2)))
[31m-      model.add(Dropout(0.25))
[31m-      
[31m-      model.add(Flatten())
[31m-      model.add(Dense(512))
[31m-      model.add(Activation('relu'))
[31m-      model.add(Dropout(0.5))
[31m-      model.add(Dense(num_classes))
[31m-      model.add(Activation('softmax'))
[31m-  code cell:
[31m-    execution_count: 22
[31m-    source:
[31m-      # initiate RMSprop optimizer
[31m-      opt = keras.optimizers.RMSprop(learning_rate=0.0001, decay=1e-6)
[31m-      
[31m-      # Let's train the model using RMSprop
[31m-      model.compile(loss='categorical_crossentropy',
[31m-                    optimizer=opt,
[31m-                    metrics=['accuracy'])
[31m-      
[31m-      x_train = x_train.astype('float32')
[31m-      x_test = x_test.astype('float32')
[31m-      x_train /= 255
[31m-      x_test /= 255
[31m-  code cell:
[31m-    execution_count: 23
[31m-    source:
[31m-      if not data_augmentation:
[31m-          print('Not using data augmentation.')
[31m-          model.fit(x_train, y_train,
[31m-                    batch_size=batch_size,
[31m-                    epochs=epochs,
[31m-                    validation_data=(x_test, y_test),
[31m-                    shuffle=True)
[31m-      else:
[31m-          print('Using real-time data augmentation.')
[31m-          # This will do preprocessing and realtime data augmentation:
[31m-          datagen = ImageDataGenerator(
[31m-              featurewise_center=False,  # set input mean to 0 over the dataset
[31m-              samplewise_center=False,  # set each sample mean to 0
[31m-              featurewise_std_normalization=False,  # divide inputs by std of the dataset
[31m-              samplewise_std_normalization=False,  # divide each input by its std
[31m-              zca_whitening=False,  # apply ZCA whitening
[31m-              zca_epsilon=1e-06,  # epsilon for ZCA whitening
[31m-              rotation_range=0,  # randomly rotate images in the range (degrees, 0 to 180)
[31m-              # randomly shift images horizontally (fraction of total width)
[31m-              width_shift_range=0.1,
[31m-              # randomly shift images vertically (fraction of total height)
[31m-              height_shift_range=0.1,
[31m-              shear_range=0.,  # set range for random shear
[31m-              zoom_range=0.,  # set range for random zoom
[31m-              channel_shift_range=0.,  # set range for random channel shifts
[31m-              # set mode for filling points outside the input boundaries
[31m-              fill_mode='nearest',
[31m-              cval=0.,  # value used for fill_mode = "constant"
[31m-              horizontal_flip=True,  # randomly flip images
[31m-              vertical_flip=False,  # randomly flip images
[31m-              # set rescaling factor (applied before any other transformation)
[31m-              rescale=None,
[31m-              # set function that will be applied on each input
[31m-              preprocessing_function=None,
[31m-              # image data format, either "channels_first" or "channels_last"
[31m-              data_format=None,
[31m-              # fraction of images reserved for validation (strictly between 0 and 1)
[31m-              validation_split=0.0)
[31m-      
[31m-          # Compute quantities required for feature-wise normalization
[31m-          # (std, mean, and principal components if ZCA whitening is applied).
[31m-          datagen.fit(x_train)
[31m-      
[31m-          # Fit the model on the batches generated by datagen.flow().
[31m-          model.fit_generator(datagen.flow(x_train, y_train,
[31m-                                           batch_size=batch_size),
[31m-                              epochs=epochs,
[31m-                              validation_data=(x_test, y_test),
[31m-                              workers=4)
[31m-    outputs:
[31m-      output 0:
[31m-        output_type: stream
[31m-        name: stdout
[31m-        text:
[31m-          Using real-time data augmentation.
[31m-          Epoch 1/100
[31m-          1563/1563 [==============================] - 204s 131ms/step - loss: 1.8744 - accuracy: 0.3085 - val_loss: 1.5658 - val_accuracy: 0.4244
[31m-          Epoch 2/100
[31m-          1563/1563 [==============================] - 195s 124ms/step - loss: 1.5836 - accuracy: 0.4242 - val_loss: 1.3721 - val_accuracy: 0.5029
[31m-          Epoch 3/100
[31m-          1563/1563 [==============================] - 199s 127ms/step - loss: 1.4632 - accuracy: 0.4693 - val_loss: 1.2876 - val_accuracy: 0.5347
[31m-          Epoch 4/100
[31m-          1563/1563 [==============================] - 194s 124ms/step - loss: 1.3775 - accuracy: 0.5051 - val_loss: 1.2419 - val_accuracy: 0.5517
[31m-          Epoch 5/100
[31m-           441/1563 [=======>......................] - ETA: 2:14 - loss: 1.3366 - accuracy: 0.5184
[31m-      output 1:
[31m-        output_type: error
[31m-        ename: KeyboardInterrupt
[31m-        traceback:
[31m-          item[0]: [0;31m----------------------------------------------------------------[0m
[31m-          item[1]: [0;31mKeyboardInterrupt[0m              Traceback (most recent call last)
[31m-          item[2]:
[31m-            [0;32m<ipython-input-23-58db1f5097ea>[0m in [0;36m<module>[0;34m[0m
[31m-            [1;32m     47[0m                         [0mepochs[0m[0;34m=[0m[0mepochs[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [1;32m     48[0m                         [0mvalidation_data[0m[0;34m=[0m[0;34m([0m[0mx_test[0m[0;34m,[0m [0my_test[0m[0;34m)[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [0;32m---> 49[0;31m                         workers=4)
[31m-            [0m
[31m-          item[3]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/keras/legacy/interfaces.py[0m in [0;36mwrapper[0;34m(*args, **kwargs)[0m
[31m-            [1;32m     89[0m                 warnings.warn('Update your `' + object_name + '` call to the ' +
[31m-            [1;32m     90[0m                               'Keras 2 API: ' + signature, stacklevel=2)
[31m-            [0;32m---> 91[0;31m             [0;32mreturn[0m [0mfunc[0m[0;34m([0m[0;34m*[0m[0margs[0m[0;34m,[0m [0;34m**[0m[0mkwargs[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m[1;32m     92[0m         [0mwrapper[0m[0;34m.[0m[0m_original_function[0m [0;34m=[0m [0mfunc[0m[0;34m[0m[0m
[31m-            [1;32m     93[0m         [0;32mreturn[0m [0mwrapper[0m[0;34m[0m[0m
[31m-          item[4]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/keras/engine/training.py[0m in [0;36mfit_generator[0;34m(self, generator, steps_per_epoch, epochs, verbose, callbacks, validation_data, validation_steps, validation_freq, class_weight, max_queue_size, workers, use_multiprocessing, shuffle, initial_epoch)[0m
[31m-            [1;32m   1730[0m             [0muse_multiprocessing[0m[0;34m=[0m[0muse_multiprocessing[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [1;32m   1731[0m             [0mshuffle[0m[0;34m=[0m[0mshuffle[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [0;32m-> 1732[0;31m             initial_epoch=initial_epoch)
[31m-            [0m[1;32m   1733[0m [0;34m[0m[0m
[31m-            [1;32m   1734[0m     [0;34m@[0m[0minterfaces[0m[0;34m.[0m[0mlegacy_generator_methods_support[0m[0;34m[0m[0m
[31m-          item[5]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/keras/engine/training_generator.py[0m in [0;36mfit_generator[0;34m(model, generator, steps_per_epoch, epochs, verbose, callbacks, validation_data, validation_steps, validation_freq, class_weight, max_queue_size, workers, use_multiprocessing, shuffle, initial_epoch)[0m
[31m-            [1;32m    218[0m                                             [0msample_weight[0m[0;34m=[0m[0msample_weight[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [1;32m    219[0m                                             [0mclass_weight[0m[0;34m=[0m[0mclass_weight[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [0;32m--> 220[0;31m                                             reset_metrics=False)
[31m-            [0m[1;32m    221[0m [0;34m[0m[0m
[31m-            [1;32m    222[0m                 [0mouts[0m [0;34m=[0m [0mto_list[0m[0;34m([0m[0mouts[0m[0;34m)[0m[0;34m[0m[0m
[31m-          item[6]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/keras/engine/training.py[0m in [0;36mtrain_on_batch[0;34m(self, x, y, sample_weight, class_weight, reset_metrics)[0m
[31m-            [1;32m   1512[0m             [0mins[0m [0;34m=[0m [0mx[0m [0;34m+[0m [0my[0m [0;34m+[0m [0msample_weights[0m[0;34m[0m[0m
[31m-            [1;32m   1513[0m         [0mself[0m[0;34m.[0m[0m_make_train_function[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0;32m-> 1514[0;31m         [0moutputs[0m [0;34m=[0m [0mself[0m[0;34m.[0m[0mtrain_function[0m[0;34m([0m[0mins[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m[1;32m   1515[0m [0;34m[0m[0m
[31m-            [1;32m   1516[0m         [0;32mif[0m [0mreset_metrics[0m[0;34m:[0m[0;34m[0m[0m
[31m-          item[7]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/tensorflow_core/python/keras/backend.py[0m in [0;36m__call__[0;34m(self, inputs)[0m
[31m-            [1;32m   3725[0m         [0mvalue[0m [0;34m=[0m [0mmath_ops[0m[0;34m.[0m[0mcast[0m[0;34m([0m[0mvalue[0m[0;34m,[0m [0mtensor[0m[0;34m.[0m[0mdtype[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [1;32m   3726[0m       [0mconverted_inputs[0m[0;34m.[0m[0mappend[0m[0;34m([0m[0mvalue[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0;32m-> 3727[0;31m     [0moutputs[0m [0;34m=[0m [0mself[0m[0;34m.[0m[0m_graph_fn[0m[0;34m([0m[0;34m*[0m[0mconverted_inputs[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m[1;32m   3728[0m [0;34m[0m[0m
[31m-            [1;32m   3729[0m     [0;31m# EagerTensor.numpy() will often make a copy to ensure memory safety.[0m[0;34m[0m[0;34m[0m[0m
[31m-          item[8]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/tensorflow_core/python/eager/function.py[0m in [0;36m__call__[0;34m(self, *args, **kwargs)[0m
[31m-            [1;32m   1549[0m       [0mTypeError[0m[0;34m:[0m [0mFor[0m [0minvalid[0m [0mpositional[0m[0;34m/[0m[0mkeyword[0m [0margument[0m [0mcombinations[0m[0;34m.[0m[0;34m[0m[0m
[31m-            [1;32m   1550[0m     """
[31m-            [0;32m-> 1551[0;31m     [0;32mreturn[0m [0mself[0m[0;34m.[0m[0m_call_impl[0m[0;34m([0m[0margs[0m[0;34m,[0m [0mkwargs[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m[1;32m   1552[0m [0;34m[0m[0m
[31m-            [1;32m   1553[0m   [0;32mdef[0m [0m_call_impl[0m[0;34m([0m[0mself[0m[0;34m,[0m [0margs[0m[0;34m,[0m [0mkwargs[0m[0;34m,[0m [0mcancellation_manager[0m[0;34m=[0m[0;32mNone[0m[0;34m)[0m[0;34m:[0m[0;34m[0m[0m
[31m-          item[9]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/tensorflow_core/python/eager/function.py[0m in [0;36m_call_impl[0;34m(self, args, kwargs, cancellation_manager)[0m
[31m-            [1;32m   1589[0m       raise TypeError("Keyword arguments {} unknown. Expected {}.".format(
[31m-            [1;32m   1590[0m           list(kwargs.keys()), list(self._arg_keywords)))
[31m-            [0;32m-> 1591[0;31m     [0;32mreturn[0m [0mself[0m[0;34m.[0m[0m_call_flat[0m[0;34m([0m[0margs[0m[0;34m,[0m [0mself[0m[0;34m.[0m[0mcaptured_inputs[0m[0;34m,[0m [0mcancellation_manager[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m[1;32m   1592[0m [0;34m[0m[0m
[31m-            [1;32m   1593[0m   [0;32mdef[0m [0m_filtered_call[0m[0;34m([0m[0mself[0m[0;34m,[0m [0margs[0m[0;34m,[0m [0mkwargs[0m[0;34m)[0m[0;34m:[0m[0;34m[0m[0m
[31m-          item[10]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/tensorflow_core/python/eager/function.py[0m in [0;36m_call_flat[0;34m(self, args, captured_inputs, cancellation_manager)[0m
[31m-            [1;32m   1690[0m       [0;31m# No tape is watching; skip to running the function.[0m[0;34m[0m[0;34m[0m[0m
[31m-            [1;32m   1691[0m       return self._build_call_outputs(self._inference_function.call(
[31m-            [0;32m-> 1692[0;31m           ctx, args, cancellation_manager=cancellation_manager))
[31m-            [0m[1;32m   1693[0m     forward_backward = self._select_forward_and_backward_functions(
[31m-            [1;32m   1694[0m         [0margs[0m[0;34m,[0m[0;34m[0m[0m
[31m-          item[11]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/tensorflow_core/python/eager/function.py[0m in [0;36mcall[0;34m(self, ctx, args, cancellation_manager)[0m
[31m-            [1;32m    543[0m               [0minputs[0m[0;34m=[0m[0margs[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [1;32m    544[0m               [0mattrs[0m[0;34m=[0m[0;34m([0m[0;34m"executor_type"[0m[0;34m,[0m [0mexecutor_type[0m[0;34m,[0m [0;34m"config_proto"[0m[0;34m,[0m [0mconfig[0m[0;34m)[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [0;32m--> 545[0;31m               ctx=ctx)
[31m-            [0m[1;32m    546[0m         [0;32melse[0m[0;34m:[0m[0;34m[0m[0m
[31m-            [1;32m    547[0m           outputs = execute.execute_with_cancellation(
[31m-          item[12]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/tensorflow_core/python/eager/execute.py[0m in [0;36mquick_execute[0;34m(op_name, num_outputs, inputs, attrs, ctx, name)[0m
[31m-            [1;32m     59[0m     tensors = pywrap_tensorflow.TFE_Py_Execute(ctx._handle, device_name,
[31m-            [1;32m     60[0m                                                [0mop_name[0m[0;34m,[0m [0minputs[0m[0;34m,[0m [0mattrs[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [0;32m---> 61[0;31m                                                num_outputs)
[31m-            [0m[1;32m     62[0m   [0;32mexcept[0m [0mcore[0m[0;34m.[0m[0m_NotOkStatusException[0m [0;32mas[0m [0me[0m[0;34m:[0m[0;34m[0m[0m
[31m-            [1;32m     63[0m     [0;32mif[0m [0mname[0m [0;32mis[0m [0;32mnot[0m [0;32mNone[0m[0;34m:[0m[0;34m[0m[0m
[31m-          item[13]: [0;31mKeyboardInterrupt[0m: 
[31m-  code cell:
[31m-    execution_count: 1
[31m-    source:
[31m-      # Save model and weights
[31m-      if not os.path.isdir(save_dir):
[31m-          os.makedirs(save_dir)
[31m-      model_path = os.path.join(save_dir, model_name)
[31m-      model.save(model_path)
[31m-      print('Saved trained model at %s ' % model_path)
[31m-  code cell:
[31m-    execution_count: 1
[31m-    source:
[31m-      # Score trained model.
[31m-      scores = model.evaluate(x_test, y_test, verbose=1)
[31m-      print('Test loss:', scores[0])
[31m-      print('Test accuracy:', scores[1])
[31m-    outputs:
[31m-      output 0:
[31m-        output_type: stream
[31m-        name: stderr
[31m-        text:
[31m-          Using TensorFlow backend.

[0m[34m## deleted /metadata:[0m
[31m-  kernelspec:
[31m-    display_name: Python 3
[31m-    language: python
[31m-    name: python3
[31m-  language_info:
[31m-    codemirror_mode:
[31m-      name: ipython
[31m-      version: 3
[31m-    file_extension: .py
[31m-    mimetype: text/x-python
[31m-    name: python
[31m-    nbconvert_exporter: python
[31m-    pygments_lexer: ipython3
[31m-    version: 3.5.3

[0m[34m## deleted /nbformat:[0m
[31m-  4

[0m[34m## deleted /nbformat_minor:[0m
[31m-  4

[0mdiff --git a/model/__init__.py b/model/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/model/lib/.ipynb_checkpoints/__init__-checkpoint.py b/model/lib/.ipynb_checkpoints/__init__-checkpoint.py
deleted file mode 100644
index d886189..0000000
--- a/model/lib/.ipynb_checkpoints/__init__-checkpoint.py
+++ /dev/null
@@ -1 +0,0 @@
-from .datasets import load_data
diff --git a/model/lib/.ipynb_checkpoints/datasets-checkpoint.py b/model/lib/.ipynb_checkpoints/datasets-checkpoint.py
deleted file mode 100644
index b6b00de..0000000
--- a/model/lib/.ipynb_checkpoints/datasets-checkpoint.py
+++ /dev/null
@@ -1,8 +0,0 @@
-def load_data():
-    x_train = []
-    y_train = []
-    
-    x_test = []
-    y_test = []
-    
-    return (x_train, y_train), (x_test, y_test)
diff --git a/model/lib/__init__.py b/model/lib/__init__.py
deleted file mode 100644
index d886189..0000000
--- a/model/lib/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-from .datasets import load_data
diff --git a/model/lib/datasets.py b/model/lib/datasets.py
deleted file mode 100644
index b6b00de..0000000
--- a/model/lib/datasets.py
+++ /dev/null
@@ -1,8 +0,0 @@
-def load_data():
-    x_train = []
-    y_train = []
-    
-    x_test = []
-    y_test = []
-    
-    return (x_train, y_train), (x_test, y_test)
nbdiff /tmp/wYF8QL_sat-resnet.ipynb /dev/null
--- /tmp/wYF8QL_sat-resnet.ipynb  2020-04-16 19:16:44.538569
+++ /dev/null  2020-04-16 19:06:50.148000
[34m## deleted /cells:[0m
[31m-  code cell:
[31m-    execution_count: 10
[31m-    source:
[31m-      from PIL import Image
[31m-      import os
[31m-      
[31m-      def format_image(image):
[31m-          r
[31m-      
[31m-      def load_data(train_ratio = 0.8, image_dir = '/home/jupyter/SSA Project/Generator/output'):    
[31m-          labels = []
[31m-          
[31m-          x = []
[31m-          y = []
[31m-          
[31m-          for filename in os.listdir(image_dir):
[31m-              if filename.endswith('.JPEG'):
[31m-                  with Image.open(os.path.join(image_dir, filename), 'r') as img:
[31m-                      label_name = ''.join(filename.split('_')[:-1])
[31m-                      if label_name not in labels:
[31m-                          labels.append(label_name)
[31m-                      y.append(labels.indexOf(label_name))
[31m-                      x.append(format_image(img))
[31m-                          
[31m-          
[31m-          return (x_train, y_train), (x_test, y_test)
[31m-      
[31m-      load_data()
[31m-    outputs:
[31m-      output 0:
[31m-        output_type: error
[31m-        ename: AttributeError
[31m-        evalue: 'list' object has no attribute 'indexOf'
[31m-        traceback:
[31m-          item[0]: [0;31m---------------------------------------------------------------------------[0m
[31m-          item[1]: [0;31mAttributeError[0m                            Traceback (most recent call last)
[31m-          item[2]:
[31m-            [0;32m<ipython-input-10-83276b3bc6f5>[0m in [0;36m<module>[0;34m[0m
[31m-            [1;32m     23[0m     [0;32mreturn[0m [0;34m([0m[0mx_train[0m[0;34m,[0m [0my_train[0m[0;34m)[0m[0;34m,[0m [0;34m([0m[0mx_test[0m[0;34m,[0m [0my_test[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [1;32m     24[0m [0;34m[0m[0m
[31m-            [0;32m---> 25[0;31m [0mload_data[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m
[31m-          item[3]:
[31m-            [0;32m<ipython-input-10-83276b3bc6f5>[0m in [0;36mload_data[0;34m(train_ratio, image_dir)[0m
[31m-            [1;32m     17[0m                 [0;32mif[0m [0mlabel_name[0m [0;32mnot[0m [0;32min[0m [0mlabels[0m[0;34m:[0m[0;34m[0m[0m
[31m-            [1;32m     18[0m                     [0mlabels[0m[0;34m.[0m[0mappend[0m[0;34m([0m[0mlabel_name[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0;32m---> 19[0;31m                 [0my[0m[0;34m.[0m[0mappend[0m[0;34m([0m[0mlabels[0m[0;34m.[0m[0mindexOf[0m[0;34m([0m[0mlabel_name[0m[0;34m)[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m[1;32m     20[0m                 [0mx[0m[0;34m.[0m[0mappend[0m[0;34m([0m[0mformat_image[0m[0;34m([0m[0mimg[0m[0;34m)[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [1;32m     21[0m [0;34m[0m[0m
[31m-          item[4]: [0;31mAttributeError[0m: 'list' object has no attribute 'indexOf'
[31m-  code cell:
[31m-  code cell:
[31m-    execution_count: 11
[31m-    source:
[31m-      import os
[31m-      import numpy as np
[31m-      import tensorflow as tf
[31m-      from keras.preprocessing.image import ImageDataGenerator
[31m-      from tensorflow.keras.models import Sequential
[31m-      from tensorflow.keras.layers import Dense, Dropout, Activation, Flatten
[31m-      from tensorflow.keras.layers import Conv2D, MaxPooling2D
[31m-      
[31m-      # from lib import datasets
[31m-      from tensorflow.keras.datasets import cifar10 as datasets
[31m-  markdown cell:
[31m-    source:
[31m-      ## Grab the JPEGs
[31m-  code cell:
[31m-    source:
[31m-      for file in os.listdir(image_dir):
[31m-          
[31m-  code cell:
[31m-    execution_count: 9
[31m-    source:
[31m-      batch_size = 32
[31m-      num_classes = 10
[31m-      epochs = 5
[31m-      data_augmentation = True
[31m-      num_predictions = 20
[31m-      save_dir = os.path.join(os.getcwd(), 'saved_models')
[31m-      model_name = 'satellite_classification_trained_model.h5'
[31m-      
[31m-      # The data, split between train and test sets:
[31m-      (x_train, y_train), (x_test, y_test) = datasets.load_data()
[31m-      num_classes = len(np.unique(y_train))
[31m-      
[31m-      print('x_train shape:', x_train.shape)
[31m-      print(x_train.shape[0], 'train samples')
[31m-      print(x_test.shape[0], 'test samples')
[31m-      print(num_classes, 'classes')
[31m-    outputs:
[31m-      output 0:
[31m-        output_type: error
[31m-        ename: NameError
[31m-        evalue: name 'os' is not defined
[31m-        traceback:
[31m-          item[0]: [0;31m---------------------------------------------------------------------------[0m
[31m-          item[1]: [0;31mNameError[0m                                 Traceback (most recent call last)
[31m-          item[2]:
[31m-            [0;32m<ipython-input-9-a499bec68f6a>[0m in [0;36m<module>[0;34m[0m
[31m-            [1;32m      4[0m [0mdata_augmentation[0m [0;34m=[0m [0;32mTrue[0m[0;34m[0m[0m
[31m-            [1;32m      5[0m [0mnum_predictions[0m [0;34m=[0m [0;36m20[0m[0;34m[0m[0m
[31m-            [0;32m----> 6[0;31m [0msave_dir[0m [0;34m=[0m [0mos[0m[0;34m.[0m[0mpath[0m[0;34m.[0m[0mjoin[0m[0;34m([0m[0mos[0m[0;34m.[0m[0mgetcwd[0m[0;34m([0m[0;34m)[0m[0;34m,[0m [0;34m'saved_models'[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m[1;32m      7[0m [0mmodel_name[0m [0;34m=[0m [0;34m'satellite_classification_trained_model.h5'[0m[0;34m[0m[0m
[31m-            [1;32m      8[0m [0;34m[0m[0m
[31m-          item[3]: [0;31mNameError[0m: name 'os' is not defined
[31m-  code cell:
[31m-    execution_count: 8
[31m-    source:
[31m-      # Convert class vectors to binary class matrices.
[31m-      y_train = tf.keras.utils.to_categorical(y_train, num_classes)
[31m-      y_test = tf.keras.utils.to_categorical(y_test, num_classes)
[31m-    outputs:
[31m-      output 0:
[31m-        output_type: error
[31m-        ename: NameError
[31m-        evalue: name 'y_train' is not defined
[31m-        traceback:
[31m-          item[0]: [0;31m---------------------------------------------------------------------------[0m
[31m-          item[1]: [0;31mNameError[0m                                 Traceback (most recent call last)
[31m-          item[2]:
[31m-            [0;32m<ipython-input-8-80e044fc5538>[0m in [0;36m<module>[0;34m[0m
[31m-            [1;32m      1[0m [0;31m# Convert class vectors to binary class matrices.[0m[0;34m[0m[0;34m[0m[0m
[31m-            [0;32m----> 2[0;31m [0my_train[0m [0;34m=[0m [0mtf[0m[0;34m.[0m[0mkeras[0m[0;34m.[0m[0mutils[0m[0;34m.[0m[0mto_categorical[0m[0;34m([0m[0my_train[0m[0;34m,[0m [0mnum_classes[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m[1;32m      3[0m [0my_test[0m [0;34m=[0m [0mtf[0m[0;34m.[0m[0mkeras[0m[0;34m.[0m[0mutils[0m[0;34m.[0m[0mto_categorical[0m[0;34m([0m[0my_test[0m[0;34m,[0m [0mnum_classes[0m[0;34m)[0m[0;34m[0m[0m
[31m-          item[3]: [0;31mNameError[0m: name 'y_train' is not defined
[31m-  code cell:
[31m-    execution_count: 21
[31m-    source:
[31m-      model = Sequential()
[31m-      model.add(Conv2D(32, (3, 3), padding='same',
[31m-                       input_shape=x_train.shape[1:]))
[31m-      model.add(Activation('relu'))
[31m-      model.add(Conv2D(32, (3, 3)))
[31m-      model.add(Activation('relu'))
[31m-      model.add(MaxPooling2D(pool_size=(2, 2)))
[31m-      model.add(Dropout(0.25))
[31m-      
[31m-      model.add(Conv2D(64, (3, 3), padding='same'))
[31m-      model.add(Activation('relu'))
[31m-      model.add(Conv2D(64, (3, 3)))
[31m-      model.add(Activation('relu'))
[31m-      model.add(MaxPooling2D(pool_size=(2, 2)))
[31m-      model.add(Dropout(0.25))
[31m-      
[31m-      model.add(Flatten())
[31m-      model.add(Dense(512))
[31m-      model.add(Activation('relu'))
[31m-      model.add(Dropout(0.5))
[31m-      model.add(Dense(num_classes))
[31m-      model.add(Activation('softmax'))
[31m-  code cell:
[31m-    execution_count: 22
[31m-    source:
[31m-      # initiate RMSprop optimizer
[31m-      opt = keras.optimizers.RMSprop(learning_rate=0.0001, decay=1e-6)
[31m-      
[31m-      # Let's train the model using RMSprop
[31m-      model.compile(loss='categorical_crossentropy',
[31m-                    optimizer=opt,
[31m-                    metrics=['accuracy'])
[31m-      
[31m-      x_train = x_train.astype('float32')
[31m-      x_test = x_test.astype('float32')
[31m-      x_train /= 255
[31m-      x_test /= 255
[31m-  code cell:
[31m-    execution_count: 23
[31m-    source:
[31m-      if not data_augmentation:
[31m-          print('Not using data augmentation.')
[31m-          model.fit(x_train, y_train,
[31m-                    batch_size=batch_size,
[31m-                    epochs=epochs,
[31m-                    validation_data=(x_test, y_test),
[31m-                    shuffle=True)
[31m-      else:
[31m-          print('Using real-time data augmentation.')
[31m-          # This will do preprocessing and realtime data augmentation:
[31m-          datagen = ImageDataGenerator(
[31m-              featurewise_center=False,  # set input mean to 0 over the dataset
[31m-              samplewise_center=False,  # set each sample mean to 0
[31m-              featurewise_std_normalization=False,  # divide inputs by std of the dataset
[31m-              samplewise_std_normalization=False,  # divide each input by its std
[31m-              zca_whitening=False,  # apply ZCA whitening
[31m-              zca_epsilon=1e-06,  # epsilon for ZCA whitening
[31m-              rotation_range=0,  # randomly rotate images in the range (degrees, 0 to 180)
[31m-              # randomly shift images horizontally (fraction of total width)
[31m-              width_shift_range=0.1,
[31m-              # randomly shift images vertically (fraction of total height)
[31m-              height_shift_range=0.1,
[31m-              shear_range=0.,  # set range for random shear
[31m-              zoom_range=0.,  # set range for random zoom
[31m-              channel_shift_range=0.,  # set range for random channel shifts
[31m-              # set mode for filling points outside the input boundaries
[31m-              fill_mode='nearest',
[31m-              cval=0.,  # value used for fill_mode = "constant"
[31m-              horizontal_flip=True,  # randomly flip images
[31m-              vertical_flip=False,  # randomly flip images
[31m-              # set rescaling factor (applied before any other transformation)
[31m-              rescale=None,
[31m-              # set function that will be applied on each input
[31m-              preprocessing_function=None,
[31m-              # image data format, either "channels_first" or "channels_last"
[31m-              data_format=None,
[31m-              # fraction of images reserved for validation (strictly between 0 and 1)
[31m-              validation_split=0.0)
[31m-      
[31m-          # Compute quantities required for feature-wise normalization
[31m-          # (std, mean, and principal components if ZCA whitening is applied).
[31m-          datagen.fit(x_train)
[31m-      
[31m-          # Fit the model on the batches generated by datagen.flow().
[31m-          model.fit_generator(datagen.flow(x_train, y_train,
[31m-                                           batch_size=batch_size),
[31m-                              epochs=epochs,
[31m-                              validation_data=(x_test, y_test),
[31m-                              workers=4)
[31m-    outputs:
[31m-      output 0:
[31m-        output_type: stream
[31m-        name: stdout
[31m-        text:
[31m-          Using real-time data augmentation.
[31m-          Epoch 1/100
[31m-          1563/1563 [==============================] - 204s 131ms/step - loss: 1.8744 - accuracy: 0.3085 - val_loss: 1.5658 - val_accuracy: 0.4244
[31m-          Epoch 2/100
[31m-          1563/1563 [==============================] - 195s 124ms/step - loss: 1.5836 - accuracy: 0.4242 - val_loss: 1.3721 - val_accuracy: 0.5029
[31m-          Epoch 3/100
[31m-          1563/1563 [==============================] - 199s 127ms/step - loss: 1.4632 - accuracy: 0.4693 - val_loss: 1.2876 - val_accuracy: 0.5347
[31m-          Epoch 4/100
[31m-          1563/1563 [==============================] - 194s 124ms/step - loss: 1.3775 - accuracy: 0.5051 - val_loss: 1.2419 - val_accuracy: 0.5517
[31m-          Epoch 5/100
[31m-           441/1563 [=======>......................] - ETA: 2:14 - loss: 1.3366 - accuracy: 0.5184
[31m-      output 1:
[31m-        output_type: error
[31m-        ename: KeyboardInterrupt
[31m-        traceback:
[31m-          item[0]: [0;31m----------------------------------------------------------------[0m
[31m-          item[1]: [0;31mKeyboardInterrupt[0m              Traceback (most recent call last)
[31m-          item[2]:
[31m-            [0;32m<ipython-input-23-58db1f5097ea>[0m in [0;36m<module>[0;34m[0m
[31m-            [1;32m     47[0m                         [0mepochs[0m[0;34m=[0m[0mepochs[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [1;32m     48[0m                         [0mvalidation_data[0m[0;34m=[0m[0;34m([0m[0mx_test[0m[0;34m,[0m [0my_test[0m[0;34m)[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [0;32m---> 49[0;31m                         workers=4)
[31m-            [0m
[31m-          item[3]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/keras/legacy/interfaces.py[0m in [0;36mwrapper[0;34m(*args, **kwargs)[0m
[31m-            [1;32m     89[0m                 warnings.warn('Update your `' + object_name + '` call to the ' +
[31m-            [1;32m     90[0m                               'Keras 2 API: ' + signature, stacklevel=2)
[31m-            [0;32m---> 91[0;31m             [0;32mreturn[0m [0mfunc[0m[0;34m([0m[0;34m*[0m[0margs[0m[0;34m,[0m [0;34m**[0m[0mkwargs[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m[1;32m     92[0m         [0mwrapper[0m[0;34m.[0m[0m_original_function[0m [0;34m=[0m [0mfunc[0m[0;34m[0m[0m
[31m-            [1;32m     93[0m         [0;32mreturn[0m [0mwrapper[0m[0;34m[0m[0m
[31m-          item[4]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/keras/engine/training.py[0m in [0;36mfit_generator[0;34m(self, generator, steps_per_epoch, epochs, verbose, callbacks, validation_data, validation_steps, validation_freq, class_weight, max_queue_size, workers, use_multiprocessing, shuffle, initial_epoch)[0m
[31m-            [1;32m   1730[0m             [0muse_multiprocessing[0m[0;34m=[0m[0muse_multiprocessing[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [1;32m   1731[0m             [0mshuffle[0m[0;34m=[0m[0mshuffle[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [0;32m-> 1732[0;31m             initial_epoch=initial_epoch)
[31m-            [0m[1;32m   1733[0m [0;34m[0m[0m
[31m-            [1;32m   1734[0m     [0;34m@[0m[0minterfaces[0m[0;34m.[0m[0mlegacy_generator_methods_support[0m[0;34m[0m[0m
[31m-          item[5]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/keras/engine/training_generator.py[0m in [0;36mfit_generator[0;34m(model, generator, steps_per_epoch, epochs, verbose, callbacks, validation_data, validation_steps, validation_freq, class_weight, max_queue_size, workers, use_multiprocessing, shuffle, initial_epoch)[0m
[31m-            [1;32m    218[0m                                             [0msample_weight[0m[0;34m=[0m[0msample_weight[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [1;32m    219[0m                                             [0mclass_weight[0m[0;34m=[0m[0mclass_weight[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [0;32m--> 220[0;31m                                             reset_metrics=False)
[31m-            [0m[1;32m    221[0m [0;34m[0m[0m
[31m-            [1;32m    222[0m                 [0mouts[0m [0;34m=[0m [0mto_list[0m[0;34m([0m[0mouts[0m[0;34m)[0m[0;34m[0m[0m
[31m-          item[6]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/keras/engine/training.py[0m in [0;36mtrain_on_batch[0;34m(self, x, y, sample_weight, class_weight, reset_metrics)[0m
[31m-            [1;32m   1512[0m             [0mins[0m [0;34m=[0m [0mx[0m [0;34m+[0m [0my[0m [0;34m+[0m [0msample_weights[0m[0;34m[0m[0m
[31m-            [1;32m   1513[0m         [0mself[0m[0;34m.[0m[0m_make_train_function[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0;32m-> 1514[0;31m         [0moutputs[0m [0;34m=[0m [0mself[0m[0;34m.[0m[0mtrain_function[0m[0;34m([0m[0mins[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m[1;32m   1515[0m [0;34m[0m[0m
[31m-            [1;32m   1516[0m         [0;32mif[0m [0mreset_metrics[0m[0;34m:[0m[0;34m[0m[0m
[31m-          item[7]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/tensorflow_core/python/keras/backend.py[0m in [0;36m__call__[0;34m(self, inputs)[0m
[31m-            [1;32m   3725[0m         [0mvalue[0m [0;34m=[0m [0mmath_ops[0m[0;34m.[0m[0mcast[0m[0;34m([0m[0mvalue[0m[0;34m,[0m [0mtensor[0m[0;34m.[0m[0mdtype[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [1;32m   3726[0m       [0mconverted_inputs[0m[0;34m.[0m[0mappend[0m[0;34m([0m[0mvalue[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0;32m-> 3727[0;31m     [0moutputs[0m [0;34m=[0m [0mself[0m[0;34m.[0m[0m_graph_fn[0m[0;34m([0m[0;34m*[0m[0mconverted_inputs[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m[1;32m   3728[0m [0;34m[0m[0m
[31m-            [1;32m   3729[0m     [0;31m# EagerTensor.numpy() will often make a copy to ensure memory safety.[0m[0;34m[0m[0;34m[0m[0m
[31m-          item[8]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/tensorflow_core/python/eager/function.py[0m in [0;36m__call__[0;34m(self, *args, **kwargs)[0m
[31m-            [1;32m   1549[0m       [0mTypeError[0m[0;34m:[0m [0mFor[0m [0minvalid[0m [0mpositional[0m[0;34m/[0m[0mkeyword[0m [0margument[0m [0mcombinations[0m[0;34m.[0m[0;34m[0m[0m
[31m-            [1;32m   1550[0m     """
[31m-            [0;32m-> 1551[0;31m     [0;32mreturn[0m [0mself[0m[0;34m.[0m[0m_call_impl[0m[0;34m([0m[0margs[0m[0;34m,[0m [0mkwargs[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m[1;32m   1552[0m [0;34m[0m[0m
[31m-            [1;32m   1553[0m   [0;32mdef[0m [0m_call_impl[0m[0;34m([0m[0mself[0m[0;34m,[0m [0margs[0m[0;34m,[0m [0mkwargs[0m[0;34m,[0m [0mcancellation_manager[0m[0;34m=[0m[0;32mNone[0m[0;34m)[0m[0;34m:[0m[0;34m[0m[0m
[31m-          item[9]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/tensorflow_core/python/eager/function.py[0m in [0;36m_call_impl[0;34m(self, args, kwargs, cancellation_manager)[0m
[31m-            [1;32m   1589[0m       raise TypeError("Keyword arguments {} unknown. Expected {}.".format(
[31m-            [1;32m   1590[0m           list(kwargs.keys()), list(self._arg_keywords)))
[31m-            [0;32m-> 1591[0;31m     [0;32mreturn[0m [0mself[0m[0;34m.[0m[0m_call_flat[0m[0;34m([0m[0margs[0m[0;34m,[0m [0mself[0m[0;34m.[0m[0mcaptured_inputs[0m[0;34m,[0m [0mcancellation_manager[0m[0;34m)[0m[0;34m[0m[0m
[31m-            [0m[1;32m   1592[0m [0;34m[0m[0m
[31m-            [1;32m   1593[0m   [0;32mdef[0m [0m_filtered_call[0m[0;34m([0m[0mself[0m[0;34m,[0m [0margs[0m[0;34m,[0m [0mkwargs[0m[0;34m)[0m[0;34m:[0m[0;34m[0m[0m
[31m-          item[10]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/tensorflow_core/python/eager/function.py[0m in [0;36m_call_flat[0;34m(self, args, captured_inputs, cancellation_manager)[0m
[31m-            [1;32m   1690[0m       [0;31m# No tape is watching; skip to running the function.[0m[0;34m[0m[0;34m[0m[0m
[31m-            [1;32m   1691[0m       return self._build_call_outputs(self._inference_function.call(
[31m-            [0;32m-> 1692[0;31m           ctx, args, cancellation_manager=cancellation_manager))
[31m-            [0m[1;32m   1693[0m     forward_backward = self._select_forward_and_backward_functions(
[31m-            [1;32m   1694[0m         [0margs[0m[0;34m,[0m[0;34m[0m[0m
[31m-          item[11]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/tensorflow_core/python/eager/function.py[0m in [0;36mcall[0;34m(self, ctx, args, cancellation_manager)[0m
[31m-            [1;32m    543[0m               [0minputs[0m[0;34m=[0m[0margs[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [1;32m    544[0m               [0mattrs[0m[0;34m=[0m[0;34m([0m[0;34m"executor_type"[0m[0;34m,[0m [0mexecutor_type[0m[0;34m,[0m [0;34m"config_proto"[0m[0;34m,[0m [0mconfig[0m[0;34m)[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [0;32m--> 545[0;31m               ctx=ctx)
[31m-            [0m[1;32m    546[0m         [0;32melse[0m[0;34m:[0m[0;34m[0m[0m
[31m-            [1;32m    547[0m           outputs = execute.execute_with_cancellation(
[31m-          item[12]:
[31m-            [0;32m/usr/local/lib/python3.5/dist-packages/tensorflow_core/python/eager/execute.py[0m in [0;36mquick_execute[0;34m(op_name, num_outputs, inputs, attrs, ctx, name)[0m
[31m-            [1;32m     59[0m     tensors = pywrap_tensorflow.TFE_Py_Execute(ctx._handle, device_name,
[31m-            [1;32m     60[0m                                                [0mop_name[0m[0;34m,[0m [0minputs[0m[0;34m,[0m [0mattrs[0m[0;34m,[0m[0;34m[0m[0m
[31m-            [0;32m---> 61[0;31m                                                num_outputs)
[31m-            [0m[1;32m     62[0m   [0;32mexcept[0m [0mcore[0m[0;34m.[0m[0m_NotOkStatusException[0m [0;32mas[0m [0me[0m[0;34m:[0m[0;34m[0m[0m
[31m-            [1;32m     63[0m     [0;32mif[0m [0mname[0m [0;32mis[0m [0;32mnot[0m [0;32mNone[0m[0;34m:[0m[0;34m[0m[0m
[31m-          item[13]: [0;31mKeyboardInterrupt[0m: 
[31m-  code cell:
[31m-    execution_count: 1
[31m-    source:
[31m-      # Save model and weights
[31m-      if not os.path.isdir(save_dir):
[31m-          os.makedirs(save_dir)
[31m-      model_path = os.path.join(save_dir, model_name)
[31m-      model.save(model_path)
[31m-      print('Saved trained model at %s ' % model_path)
[31m-  code cell:
[31m-    execution_count: 1
[31m-    source:
[31m-      # Score trained model.
[31m-      scores = model.evaluate(x_test, y_test, verbose=1)
[31m-      print('Test loss:', scores[0])
[31m-      print('Test accuracy:', scores[1])
[31m-    outputs:
[31m-      output 0:
[31m-        output_type: stream
[31m-        name: stderr
[31m-        text:
[31m-          Using TensorFlow backend.

[0m[34m## deleted /metadata:[0m
[31m-  kernelspec:
[31m-    display_name: Python 3
[31m-    language: python
[31m-    name: python3
[31m-  language_info:
[31m-    codemirror_mode:
[31m-      name: ipython
[31m-      version: 3
[31m-    file_extension: .py
[31m-    mimetype: text/x-python
[31m-    name: python
[31m-    nbconvert_exporter: python
[31m-    pygments_lexer: ipython3
[31m-    version: 3.5.3

[0m[34m## deleted /nbformat:[0m
[31m-  4

[0m[34m## deleted /nbformat_minor:[0m
[31m-  4

[0m